-title mincod                                           : phase 2 translation from minimal tokens to 64 bit C code
-stitl description

*   Copyright 1987-2012 robert b. k. dewar and mark emmer.
*   Copyright 2012-2017 david shields
*   Copyright 2018 - Hib Engler

*   this file is part of macro spitbol -> lex into C code

*   macro spitbol is free software: you can redistribute it and/or modify
*   it under the terms of the gnu general public license as published by
*   the free software foundation, either version 2 of the license, or
*   (at your option) any later version.

*   macro spitbol is distributed in the hope that it will be useful,
*   but without any warranty; without even the implied warranty of
*   merchantability or fitness for a particular purpose.  see the
*   gnu general public license for more details.

*   you should have received a copy of the gnu general public license
*   along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.


*   this program takes input file in minimal token form and
*   produces C code.
*   So there will probably be two types of c code.  One type will have 
*   the dreaded "if" statement, and gotos all over the place.  The stack will
*   be mitigated and minimized, unless calling an osint function.
*
*   The other method will Queue the function labels that will be void pointers.
*   After a reurn is done, a SUCCESS/FAILURE/OTHER queue will be evaluated and called - gone to for the rest of the work.
*   this means that every label will be it's own function.
*   or a mini "kernel" if you will.
*
*   And heres the idea.
*   alot of kernels will basically be doing the same thing, except going to different labels.
*   that means that they could be consolidated through different parts, and simpleified,
*   so that each queue effectively can be a separate thread, or virtual thread,   where the threads on the computer
*   will swith the context and do the work.
*   That would mean the registers will be contexed per-queue.  Analysis of a block can determine what is going through, to limit the regs, but for the beginning
*   all regs would be through the stack.
*   This then means that things can happen at the same time.
*   Possibly a program can be compiled 100 lines at a time, but will it be fast?
*   on the CPU, yes,  but then for kernels.
*   All the variables can become streams, or something like it, now it could be possible to to thousands of pattern matches at once.
*   Well, thats the idea behind converting the code to C.
*   I want to use the brook idea of multidimensional streams, where the dimensions are determined at run time.
*   It might go that a CPU will reduce the streams,  although brook could do it with a sort, and then test for zero.
*   brook - brook gpu - and probably opencl and other stuff. to be figured out.
*   imagine all commands becoming something like spitbol:
*   [<label>] [[<expression> [?] [pattern] [= expression]] [goto]
*
*   variable assignments could be done multiple ways.  One way is to have a user file system map the elf file dynamically and provide memory maps to the parent data,
*   and have writes to that be locally administered.   There is code for this,  and if it is done right, the virtual memory system can contain the changes to global variables that 
*   are and are not important
*   would need something to contol input/output so that they can be streams instead of a single character stream.  
*   the parent data could be consolidated, with any clas resolved by the line number (thread number) of the input file.
*   there can also be sibling shares, or perhaps storing value, then array of tables (value, thread id in x,y,z) to capture this if it needs to fo to the parent.
*   it could go to parent, or siblings, and siblings should be able to peek and set their own values. the hooks used to turn input and output to external strams could work there
*   Well, you see, it brings snobol4 into a new realm. A realm where the while statement is possibly mapped, the if statement is taboo.
*   in other words, the assembly language goto solves what openCL, and SYCL (and I think Cuda - but got to learn more) do by having a compiler check everything and build everything during runtime.
*   yeah, spitbol can still do that. 
*   cuda can do it. the parent would make a block, with the threads picking what to do. then an array of gotos would be queued for processing - maybe compressed here
*   with a sort.  Cuda would need blocks and threads to be predefined amounts, probably ^2 ish
*   anyways.
*
*   the program obtains the name of the file to be translated from the
*   command line string in host(0).

*   options relating to the processing of comments can be
*   changed by modifying the source.

*   in addition to the minimal token file, the program requires the
*   name of a "machine definition file" that contains code specific
*   to a particular C variant.  note - for now, the assembly language will be printed first as a comment.
*   the C variant will need two passes. Lets see if the original asm does this

*   you may also specify option flags on the command line to control the
*   code generation.  the following flags are processed:
*       compress        generate tabs rather than spaces in output file
*       comments        retain full-line and end-of-line comments

*   the variable arch is set equal to the uppercase name of the machine
*   being processed.  specific tests upon this variable are discouraged, as
*   all machine-dependent code should be placed in the machine-definition
*   file if possible.

*   in addition to the normal minimal register complement, one scratch
*   work register, w0 is defined.
*   see the register map below for specific allocations.

*   this program is based in part on earlier translators for the
*   it is based in part on earlier translators for the dec vax
*   (vms and un*x) written by steve duff and robert goldberg, and the
*   pc-spitbol translator by david shields.

*  to run under spitbol:
*       spitbol -u "<file>:<machine>[:flag:...:flag]" codlinux.spt

*       reads <file>.lex        containing tokenized source code
*       writes <file>.c         with a c goto script
*       also writes <file>.err  with err and erb error messages
*       parts of m.hdr  are prepended and appended to <file>.s
*       also sets flags         to 1 after converting names to upper case
*       also reads <file>.pub   for debug symbols to be declared public

*   example:

*       spitbol -u min:x86_64:compress cgen.spt


*   revision history:

    version = 'v1.00'
* from 1.12 of asm.sno
    rcode = '_rc_'


-eject

*   keyword initialization

    &anchor = 1;    &stlimit = -1;    &trim   = 1;  &dump = 1

*   useful constants

    letters = 'abcdefghijklmnopqrstuvwxyz'
    ucase   = letters
    lcase   = 'abcdefghijklmnopqrstuvwxyz'
    nos     = '0123456789'
    tab     = char(9)


*   default the parameter string if none present

    fileprefix = "s"

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
*  set target-dependent configuration parameters

*        cfp_b is bytes per word, cfp_c is characters per word
*        these should agree with values used in translator
    cfp_b = 8
    cfp_c = 8
    log_cfp_b = '3'
    log_cfp_c = '3'
    op_w = 'q'
    op_c = 'b'

config.done


*   set z_trace to enable instruction by instruction trace
    z_trace = 1
    z_trace = 0
*   z_limit is maximum number of calls to be generated if non-zero
    z_limit = 000
*   set z_first non-zero to skip first number of instructions that would generate trace
    z_first = 0
*   will set in_executable when in part of program where executable
*   instructions may occur
    z_exec = 0

*   z_suspend is set to temporarily disable the trace.
    z_suspend = 0
*   set in_skip when should not insert trace code, else assembly errors result.
*   start with skip on, turn off when see first start of code.
    z_skip = 1
*   skip_on and skip_off are labels indicating the start and end,
*   respectively, of sections of the code that should not be traced,
*   usually because they contain a loop instruction that won't
*   compile if too much trace code is inserted.
    skip_on = table(50)
    skip_off = table(50)

        define('skip_init(s)on,off')                    :(skip_init.end)

skip_init       s break(':') . on ':' rem . off         :f(return)

    skip_on[on] = 1
    skip_off[off] = 1                                   :(return)

skip_init.end

*   skip_init('start:ini03')
    skip_init('gbcol                                    :gtarr')
*   skip_init('gtn01:gtnvr')
*   skip_init('bpf05:bpf07')
*   skip_init('scv12:scv19')
*   skip_init('exbl1:exbl2')
*   skip_init('exbl5:expan')
*   skip_init('prn17:prn18')
*   skip_init('ini11:ini13')
*   skip_init('oex13:oexp2')
*   skip_init('oex14:oexp6')
*   skip_init('bdfc1:b_efc')
*   skip_init('sar01:sar10')
*   skip_init('srpl5:srpl8')
*   skip_init('pflu1:pflu2')
*   skip_init('prpa4:prpa5')
*   skip_init('prn17:prn18')
*   skip_init('prtvl:prtt1')
*   skip_init('trim4:trim5')
*   skip_init('prnl1:prnl2')
*   skip_init('prti1:prtmi')
*   skip_init('srpl5:srpl8')


	


*   data structures

    data('minarg(i.type,i.text)')
    data('tstmt(t.label,t.opc,t.op1,t.op2,t.op3,t.comment)')

    sectnow = 0

*   ppm_cases gives count of ppm/err statments that must follow call to
*   a procedure

    ppm_cases = table(50,,0)


*   function definitions

   define('upper(s)') 
	        xUP_LO  =  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
		xLO_UP  =  'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ'

*   crack parses stmt into a stmt data plex and returns it.
*   it fails if there is a syntax error.

    define('crack(line)operands,operand,char')

    define('chktrace()')
*        comregs - map minimal register names to target register names
    define('comregs(line)t,pre,word')

*   error is used to report an error for current statement

    define('error(text)')
    define('flush()')
    define('genz()')
    define('genaop(stmt)')
    define('genbop(stmt)')
    define('genlab()')
    define('genop(gopc,gop1,gop2,gop3)')
    define('genopl(gopl,gopc,gop1,gop2,gop3)')
    define('genrep(op)l1,l2)')
    define('getarg(iarg,imem)l1,l2,t1,t2,tmem')
    define('ifreg(iarg)')
    define('memmem()t')
    define('prcent(n)')
    define('prsarg(iarg)l1,l2')
    define('report(num,text)')
    define('tblini(str)pos,cnt,index,val,lastval')
    define('gencode_c(pass,x)a,b,c')
    define('get_c_argument(iarg,imem)a,b,c,l1,l2,t1,t2,tmem')
    define('get_c_label(iarg,imem)a,b,c,l1,l2,t1,t2,tmem')
    define('convert_value_c(x)a,b,c,d)')
    define('do_current_label()')
    

	p.c_symbol = '&&' | '||' | '>=' | '<=' | '->' | '*=' | any('^|!=+-*/%[]{}().&')
	p.c_sbrk = '\\' | '\"' | "\'"
	&anchor = 0
	p.c_stringchar1 = &alphabet
	p.c_stringchar1 '"' = ''
	p.c_stringchar2 = p.c_sbrk | any(p.c_stringchar1)
	p.c_string = '"' arbno(p.c_stringchar2) '"'
	p.c_comment = '/*' arbno(any(&alphabet)) '*/'
	p.c_charchar1 = &alphabet
	p.c_charchar1 "'" = ""
	p.c_charchar2 =  p.c_sbrk | any(p.c_charchar1)
	p.c_char = "'" p.c_charchar2 "'"
	p.c_label = any('abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ') ( span('abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') | '' )
	p.c_s = span(' 	') 
	p.c_n1 = span('0123456789')
	p.c_n2 = span('0123456789') '.' ( span('0123456789') | '' ) ( 'f' | 'l' | 'ul' | 'd' | '' )
	p.c_token = p.c_n2 | p.c_n1 | p.c_string | p.c_comment | p.c_char | p.c_label | p.c_symbol | p.c_s
	&anchor = 1
    

*   outstmt is used to send a target statement to the target code
*   output file outfile

    
    define('outstmt(ostmt)label,opcode,op1,op2,op3,comment,t,stmtout')

    
*   readline is called to return the next non-comment line from
*   the minimal input file (infile <=> lu1).   note that it will
*   not fail on eof, but it will return a minimal end statement

    define('readline()')

     p.comregs = break(letters) . pre span(letters) . word

*   exttab has entry for external procedures

    exttab = table(50)
    external_procedures = exttab

*   labtab records labels in the code section, and their line numbers

    labtab = table(500)
    labels_in_the_code_section = labtab

*   for each statement, code in generated into three
*   arrays of statements:

*   astmts: statements after opcode (()+, etc.)
*   after_opcode_statements
*   bstmts: statements before code (-(), etc)
*   before_code_statements
*   cstmts: generated code proper
*   code_statements

*    astmts = array(20,'')
    after_opcode_statements = array(1000,'')
    astmts = after_opcode_statements
    before_code_statements = array(1000,'')
    bstmts = before_code_stmts
    code_statements = array(1000,'')
    cstmts = code_statements

*   genlabels is count of generated labels (cf. genlab)

    genlabels = 0



*   initialize variables

    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0
    gone_baby_gone = 0
    
    c_definitions = table(1000)
    
    

*   initial patterns

*   p.csparse parses tokenized line
    p.csparse = '{' break('{') . inlabel
.       '{' break('{') . incode
.       '{' break('{') . iarg1
.       '{' break('{') . iarg2
.       '{' break('{') . iarg3
.       '{' break('{') . incomment
    '{' rem . slineno

*   dispatch table
* these are name addresses of labels in getarg.  I bet this does something like :($label) but faster
*

    getargcase = table(27)
    getargcase[1] = .getarg.c.1;   getargcase[2] = .getarg.c.2
    getargcase[3] = .getarg.c.3;   getargcase[4] = .getarg.c.4
    getargcase[5] = .getarg.c.5;   getargcase[6] = .getarg.c.6
    getargcase[7] = .getarg.c.7;   getargcase[8] = .getarg.c.8
    getargcase[9] = .getarg.c.9;   getargcase[10] = .getarg.c.10
    getargcase[11] = .getarg.c.11; getargcase[12] = .getarg.c.12
    getargcase[13] = .getarg.c.13; getargcase[14] = .getarg.c.14
    getargcase[15] = .getarg.c.15; getargcase[16] = .getarg.c.16
    getargcase[17] = .getarg.c.17; getargcase[18] = .getarg.c.18
    getargcase[19] = .getarg.c.19; getargcase[20] = .getarg.c.20
    getargcase[21] = .getarg.c.21; getargcase[22] = .getarg.c.22
    getargcase[23] = .getarg.c.23; getargcase[24] = .getarg.c.24
    getargcase[25] = .getarg.c.25; getargcase[26] = .getarg.c.26
    getargcase[27] = .getarg.c.27

    get_c_argumentcase = table(27)
    get_c_argumentcase[1] = .get_c_argument.c.1;   get_c_argumentcase[2] = .get_c_argument.c.2
    get_c_argumentcase[3] = .get_c_argument.c.3;   get_c_argumentcase[4] = .get_c_argument.c.4
    get_c_argumentcase[5] = .get_c_argument.c.5;   get_c_argumentcase[6] = .get_c_argument.c.6
    get_c_argumentcase[7] = .get_c_argument.c.7;   get_c_argumentcase[8] = .get_c_argument.c.8
    get_c_argumentcase[9] = .get_c_argument.c.9;   get_c_argumentcase[10] = .get_c_argument.c.10
    get_c_argumentcase[11] = .get_c_argument.c.11; get_c_argumentcase[12] = .get_c_argument.c.12
    get_c_argumentcase[13] = .get_c_argument.c.13; get_c_argumentcase[14] = .get_c_argument.c.14
    get_c_argumentcase[15] = .get_c_argument.c.15; get_c_argumentcase[16] = .get_c_argument.c.16
    get_c_argumentcase[17] = .get_c_argument.c.17; get_c_argumentcase[18] = .get_c_argument.c.18
    get_c_argumentcase[19] = .get_c_argument.c.19; get_c_argumentcase[20] = .get_c_argument.c.20
    get_c_argumentcase[21] = .get_c_argument.c.21; get_c_argumentcase[22] = .get_c_argument.c.22
    get_c_argumentcase[23] = .get_c_argument.c.23; get_c_argumentcase[24] = .get_c_argument.c.24
    get_c_argumentcase[25] = .get_c_argument.c.25; get_c_argumentcase[26] = .get_c_argument.c.26
    get_c_argumentcase[27] = .get_c_argument.c.27


*   pifatal maps minimal opcodes for which no a code allowed
*   to nonzero value. such operations include conditional
*   branches with operand of form (x)+

    pifatal = tblini(
.       'aov[1]beq[1]bne[1]bge[1]bgt[1]bhi[1]ble[1]blo[1]'
.       'blt[1]bne[1]bnz[1]ceq[1]cne[1]mfi[1]nzb[1]zrb[1]')

*        trace not working for mvc (x64)

    is_executable = table(100)
    s =
+       'add adi adr anb aov atn '
+       'bct beq bev bge bgt bhi ble blo blt bne bnz bod '
+       'brn bri bsw btw bze ceq chk chp cmb cmc cmp cne csc '
+       'cos ctb ctw cvd cvm dca dcv eti dvi dvr erb esw etx flc '
+       'ica icp icv ieq ige igt ile ilt ine ino iov itr jmp '
+       'jsr lch lct lcp lcw ldi ldr lei lnf lsh lsx mcb mfi mli mlr '
+       'mnz mov mti mvw mwb ngi eti ngr nzb orb plc prc psc '
+       'req rge rgt rle rlt rmi rne rno rov rsh rsx rti rtn sbi sbr '
+       'sch scp sin sqr ssl sss sti str sub tan trc wtb xob zer '
+       'zgb zrb'

*        don't trace mvc as doing so causes just 'end' to fail. sort out later. (ds 01/09/13)

is_exec.1

    s len(3) . opc ' ' =                                :f(is_exec.2)
    is_executable[opc] = 1                              :(is_exec.1)

is_exec.2

-stitl main program
*   here follows the driver code for the "main" program.

*   loop until program exits via g.end

*   opnext is invoked to initiate processing of the next line from
*   readline.
*   after doing this, opnext branches to the generator routine indicated
*   for this opcode if there is one.
*   the generators all have entry points beginning
*   with "g.", and can be considered a logical extension of the
*   opnext routine.  the generators have the choice of branching back
*   to dsgen to cause the thisstmt plex to be sent to outstmt, or
*   or branching to dsout, in which case the generator must output
*   all needed code itself.

*   the generators are listed in a separate section below.


*   get file name


*  get definition file name following token file name, and flags.

*        fileprefix ? break(';:') . fileprefix len(1) (break(';:') | rem) . target
*+              ((len(1) rem . flags) | '')
*        $replace(target,lcase,ucase) = 1

*  parse and display flags, setting each one's name to non-null value (1).

                                                        :(flgs.skip)
flgs

   flags ? ((len(1) break(';                            :')) . flag len(1)) |
+        ((len(1) rem) . flag) =                        :f(flgs2)
    flag = replace(flag,lcase,ucase)
    output = "  flag                                    : " flag
    $flag = 1                                           :(flgs)

flgs.skip

flgs2

*   various constants

    comment.delim = '//'

*   branchtab maps minimal opcodes 'beq', etc to desired
*   target instruction

    branchtab = table(10)
    branchtab['beq'] = 'be'
    branchtab['bne'] = 'jne'
    branchtab['bgt'] = 'ja'
    branchtab['bge'] = 'jae'
    branchtab['ble'] = 'jbe'
    branchtab['blt'] = 'jb'
    branchtab['blo'] = 'jb'
    branchtab['bhi'] = 'ja'

    branchtab_standard_c = table(10)
    branchtab_standard_c['beq'] = '=='
    branchtab_standard_c['bne'] = '!='
    branchtab_standard_c['bgt'] = '>'
    branchtab_standard_c['bge'] = '>='
    branchtab_standard_c['ble'] = '<='
    branchtab_standard_c['blt'] = '<'
    branchtab_standard_c['blo'] = '<'
    branchtab_standard_c['bhi'] = '>'
    
    
    
    
*   optim.tab flags opcodes capable of participating in or optimization
*                in outstmt routine

    optim.tab = table(10)
    optim.tab<"and"> = 1
    optim.tab<"add"> = 1
    optim.tab<"sub"> = 1
    optim.tab<"neg"> = 1
    optim.tab<"or"> = 1
    optim.tab<"xor"> = 1
    optim.tab<"shr"> = 1
    optim.tab<"shl"> = 1
    optim.tab<"inc"> = 1
    optim.tab<"dec"> = 1


*   ismem is table indexed by operand type which is nonzero if
*   operand type implies memory reference.

    ismem = array(30,0)
    ismem<3> = 1; ismem<4> = 1; ismem<5> = 1
    ismem<9> = 1; ismem<10> = 1; ismem<11> = 1
    ismem<12> = 1; ismem<13> = 1; ismem<14> = 1
    ismem<15> = 1

*   regmap maps minimal register name to target machine
*   register/memory-location name.

    regmap = table(30)
    regmap['xl'] = 'xl';  regmap['xt'] = 'xt'
    regmap['xr'] = 'xr';  regmap['xs'] = 'xs'
    regmap['wa'] = 'wa';  regmap['wb'] = 'wb'
    regmap['wc'] = 'wc';  regmap['ia'] = 'ia'
    regmap['cp'] = 'cp'
*        w0 is temp register
    regmap['w0'] = 'w0'
    w0 = regmap['w0']


* C uses better names
    better_register_name = table(30)
    better_register_name['xl'] = 'xl'
    better_register_name['xt'] = 'xt'
    better_register_name['xr'] = 'xr'  
    better_register_name['xs'] = 'xs'
    better_register_name['wa'] = 'wa'  
    better_register_name['wb'] = 'wb'
    better_register_name['wc'] = 'wc'  
    better_register_name['ia'] = 'ia'
    better_register_name['cp'] = 'cp'
*        w0 is temp register
    better_register_name['w0'] = 'w0'
    better_register_name['cp'] = 'cp'
    
    w0 = better_register_name['w0']

*   quick reference:
    reg.wa = regmap['wa']
    reg.cp = regmap['cp']

*   reglow maps register to identify target, so
*   can extract 'l' part.

    reglow = table(4)
    reglow['wa'] = 'wa_l'
    reglow['wb'] = 'wb_l'
    reglow['wc'] = 'wc_l'

*   real_op maps minimal real opcode to machine opcode

    real_op = table(10)
    real_op['adr'] = 'fadd'
    real_op['atn'] = 'fpatan'
    real_op['chp'] = 'frndint'
    real_op['cos'] = 'fcos'
    real_op['dvr'] = 'fdiv'
    real_op['ldr'] = 'fld'
    real_op['mlr'] = 'fmul'
    real_op['ngr'] = 'fchs'
    real_op['sbr'] = 'fsub'
    real_op['sin'] = 'fsin'
    real_op['sqr'] = 'fsqrt'
    real_op['str'] = 'fst'

*   other definitions that are dependent upon things defined in the
*   machine definition file, and cannot be built until after the definition
*   file has been read in.

*   p.outstmt examines output lines for certain types of comment contructions. works for comment only stuff too

    fillc     = (ident(compress) " ",tab)
    p.outstmt = (break(fillc) . label span(fillc)) . leader
+                       comment.delim rem . comment
    p.alltabs = span(tab) rpos(0)

*   strip end of comments if y

    strip_comment = (differ(comments) 'n', 'y')

    filenami = fileprefix '.lex'
    input(.infile,1,filenami)                           :s(inputok)

inputok

    output = '  input lex file                          : ' filenami

*   associate output files.

    filenamo = 'osint/c' fileprefix '.c'
    output(.outfile,2,filenamo)                         :s(outputok)
    output = '  cannot open asm file: ' filenamo        :(end)

outputok

    output = '  output asm file                         : ' filenamo


*  open file for compilation of minimal err and erb messages

    output(.errfile,3, fileprefix ".err")               :s(err_ok)
    output = "  cannot open error message file: " fileprefix ".err":(end)
err_ok


*   then copy contents of x64.hdr (if it exists) to outfile
*   stop at line with just 'end' or end of file

    noutlines = noutlines + 1

* we dont use a header for c
	:(nohdr)    
    input(.hdrfile,4,'x64.hdr')                         :f(nohdr)
    havehdr = 1

*         output = '  input header file:  ' hdr  '.hdr'

hdrcopy

    line = hdrfile                                      :f(hdrend)
    ident(line,'end')                                   :s(nohdr)
    outfile = line
    noutlines = noutlines + 1                           :(hdrcopy)

hdrend

     havehdr =

nohdr

*   will have havehdr non-null if more remains to copy out at end.

*   read in pub file if it exists.  this contains a list of symbols to
*   be declared public when encountered.

    pubtab = table(2)
    input(.pubfile,5, fileprefix ".pub")                :f(nopub)
    pubtab = table(101)

pubcopy

    line = pubfile                                      :f(pubend)
    pubtab[line] = 1                                    :(pubcopy)

pubend

     endfile(5)

nopub

                                                        :(initialize)
initialize							
*    &trace = 20000
*    &ftrace = 1000
*   &profile = 1
    parser_pass = 1
    
    last_labels = array(100,'')
    section_labels = table()
    section_labels[1] = table(1000)
    section_labels[2] = table(1000)
    section_labels[3] = table(1000)
    section_labels[4] = table(1000)
    section_labels[5] = table(1000)
    section_labels[6] = table(1000)
    section_labels[7] = table(1000)
    section_labels[8] = table(1000)
    
    gencode_c(1,'/* generated from ' infile ' into C code */')
    gencode_c(1,'#include "c_64.h"')
    gencode_c(1,'#include "port.h"')
    gencode_c(1,'')
    gencode_c(1,'')
    gencode_c(1,'')
    flush()
    

    last_labels.n = 0
    
dsout

opnext
     thisline = readline()

     genbop(tstmt('//	' thisline,'','','',''))
     thisline '{{end'			:s(opnext.2)
opnext.0     
* did_c_code is a flag so we don't output things if it is not our pass to do so
     did_c_code = 0
     did_c_code = 1
* ^^^ for debugging     
     crack(thisline)                                    :f(dsout)
     op_ = incode '_'
     
     
* handle_labels for c code

    

    ident(inlabel)                                      :s(opnext.asm)
    eq(parser_pass,1)						:f(opnext.pass2)
opnext.pass1
    ident(incode)					:s(opnext.p1.add_ext)
    ident(incode,'ent')						:s(opnext.p1.add_ext)
    ident(incode,'prc')						:s(opnext.p1.add_ext)
    :(opnext.p1.gotcode)
    
    
opnext.p1.add_ext
* here we have labels multiple to the same thing
    last_labels[last_labels.n = last_labels.n + 1] = inlabel    
*    ident(section_labels[sectnow][inlabel],'')	:f(opnext.p1.know_about_it)
    section_labels[sectnow][inlabel] = table()
    section_labels[sectnow][inlabel]['type'] = 'extra'

*opnext.p1.know_about_it
*	terminal = 'know ' inlabel
*	gencode_c(1,'')
*						:(opnext.asm)
        
opnext.p1.gotcode

	eq(sectnow,1)					:s(opnext.asm)
	eq(sectnow,2)					:s(opnext.asm)
	eq(sectnow,3)					:s(opnext.p1_gotsec345code)
	eq(sectnow,4)					:s(opnext.p1_gotsec345code)
	eq(sectnow,5)					:s(opnext.p1_gotsec345code)
	eq(sectnow,6)					:s(opnext.asm)
	:(opnext.asm)
	
opnext.p1_gotsec345code
	t0 = 1
opnext.p1_gotsec345loop	
	ge(t0,last_labels.n)		:s(opnext.p1.ready_for_def)
	genbop(tstmt('#define ' last_labels[t0] '	' inlabel,'','','',''))
	t0 = t0 + 1			:(opnext.p1_gotsec345loop)
	
opnext.p1.ready_for_def
	last_labels.n = 0
* ^^^ make the next label clean
	eq(sectnow,5)				:f(opnext.p1.endgotcode);
	gencode_c(1,'extern void ' inlabel '();' )
* make_better_name
	:(opnext.p1.endgotcode)

opnext.pass2
	ident(incode)					:s(opnext.p2.gotcode)
	ident(incode,'ent')				:s(opnext.p2.gotcode)
	ident(incode,'prc')				:s(opnext.p2.gotcode)
	eq(sectnow,1)					:s(opnext.asm)
	eq(sectnow,2)					:s(opnext.asm)
	eq(sectnow,3)					:s(opnext.asm)
	eq(sectnow,4)					:s(opnext.asm)
	eq(sectnow,5)					:s(opnext.p2_gotsec5code)
	eq(sectnow,6)					:s(opnext.asm)
	eq(sectnow,7)					:s(opnext.asm)
	eq(sectnow,8)					:s(opnext.asm)
	eq(sectnow,9)					:s(opnext.asm)
	:(opnext.asm)
	
	
opnext.p2.gotcode
	eq(sectnow,3)					:s(opnext.p2_gotsec3code)
	eq(sectnow,4)					:s(opnext.p2_gotsec3code)
	eq(sectnow,5)					:s(opnext.p2_gotsec5code)
	:(opnext_asm)
	
		
opnext.p2_gotsec3code			
	:(opnext.p2.endgotcode)

opnext.p2_gotsec5code			
	ident(current_function_name)			:s(opnext.p2_gotsec5code.nofinish)
        eq(gone_baby_gone,1)				:s(opnext.p2.skip_goto)
	gencode_c(2,'C_GOTO(' inlabel ');' )
opnext.p2.skip_goto
	gencode_c(2,'} /* ' current_function_name ' */')
	gencode_c(2,'')
	current_function_name = ''
	gone_baby_gone = 0
opnext.p2_gotsec5code.nofinish		
	gencode_c(2,'void ' inlabel '() {' )
	current_function_name = inlabel
		
	:(opnext.p2.endgotcode)
	
	
	
opnext.p1.endgotcode
opnext.p2.endgotcode
	last_labels.n = 0		:(opnext.asm)
	
	
opnext.asm
*   append ':' after label if in code or data.

*   output label of executable instruction immediately if there is one,
*   as it simplifies later processing, especially for tracing.

    ident(inlabel)                                      :s(opnext.1)
    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)

*   keep the label as is is not in executable code

    lt(sectnow,5)                                       :s(opnext.1)

*   here if in code, so output label now
*   defer label processing for ent to allow emission of alignment ops for x86.

    ident(incode,'ent')                                 :s(opnext.1)
    outfile = '// ' thislabel
    outlines = outlines + 1
    
*   set lastlabel so can check to avoid emitting duplicate label definitions

    lastlabel = thislabel

*   clear out label info once generated

    label = thislabel =

opnext.1

    thislabel = inlabel (differ(inlabel) ge(sectnow,3) ':',)
    i1 = prsarg(iarg1)
    i2 = prsarg(iarg2)
    i3 = prsarg(iarg3)
    tcomment = comregs(incomment) '} ' incode ' ' i.text(i1) ' '
.               i.text(i2) ' ' i.text(i3)
    argerrs = 0
                                                        :($('g.' incode))
*   here if bad opcode


* the file is at eof. We can either do another pass, or complete the current one
opnext.2 
	terminal = 'done pass ' parser_pass
	
	eq(parser_pass,2)					:s(opnext.0)

* we have to close and reopen the file
	endfile(1)
	
        input(.infile,1,filenami)  
* reset some simple counters that work with the file
initialize2
	gone_baby_gone = 0
    labcnt = noutlines = nlines = nstmts = ntarget = nerrors = 0
    lastopc = lastop1 = lastop2 =
    data_lc = 0
    max_exi = 0
	prc.count1 = 0
    sectnow = 0
	
	parser_pass = parser_pass + 1
	terminal = 'start pass ' parser_pass
	:(opnext)





ds01

    error('bad op-code')                                :(dsout)

*   generate tokens.

ds.typerr

    error('operand type zero')                          :(dsout)

-stitl comregs(line)t,pre,word
comregs

    line p.comregs =                                    :f(comregs1)
    word = eq(size(word),2) differ(t = regmap[word]) t
    comregs = comregs pre word                          :(comregs)

comregs1 comregs = comregs line                         :(return)
-stitl crack(line)

*   crack is called to create a stmt plex containing the various parts  of
*  the minimal source statement in line.  for conditional assembly ops,
*  the opcode is the op, and op1 is the symbol.  note that dtc is handled
*   as a special case to assure that the decomposition is correct.

*   crack prints an error and fails if a syntax error occurs.

crack

    nstmts  = nstmts + 1
    op1 = op2 = op3 = typ1 = typ2 = typ3 =
    line    p.csparse                                   :s(return)
*   here on syntax error

    error('source line syntax error')                   :(freturn)
-stitl error(text)
*   this module handles reporting of errors with the offending
*   statement text in thisline.  comments explaining
*   the error are written to the listing (including error chain), and
*   the appropriate counts are updated.

error

    outfile = '* *???* ' thisline
    outfile = '*       ' text
.                 (ident(lasterror),'. last error was line ' lasterror)
    lasterror = noutlines
    noutlines = noutlines + 2
    le(nerrors = nerrors + 1, 10)                       :s(dsout)
    output = 'too many errors, quitting'                :(end)

-stitl genaop(stmt)
genaop

    after_opcode_statements[after_opcode_statements.n = after_opcode_statements.n + 1] = stmt              :(return)

-stitl genbop(stmt)
genbop
    before_code_statements[before_code_statements.n = before_code_statements.n + 1] = stmt              :(return)

-stitl genlab()
*   generate unique labels for use in generated code

genlab

    genlab = '_l' lpad(genlabels = genlabels + 1,4,'0') :(return)

-stitl gencode_c(pass,x)
*   generate code
gencode_c 		
	eq(parser_pass,pass)		:f(return)
	did_c_code = 1
	code_statements[code_statements.n = code_statements.n + 1] = 
.               tstmt('',x,'','','')
	
	:(return)
 
-stitl genopl(gopl,gopc,gop1,gop2,gop3)
*   generate operation with label

genopl

    code_statements[code_statements.n = code_statements.n + 1] =
.               tstmt('//A	' gopl,gopc,gop1,gop2,gop3)         :(return)

-stitl genop(gopc,gop1,gop2,gop3)
*   generate operation with no label

genop

    genopl(,gopc,gop1,gop2,gop3)                        :(return)


-stitl getarg(iarg,imem)

getarg

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l2 = i.type(iarg)
    eq(l2)                                              :f($(getargcase[l2]))
    getarg = l1                                         :(return)

*  int

getarg.c.1

   getarg = l1                                          :(return)

*  dlbl

getarg.c.2

   getarg = l1                                          :(return)

*  wlbl, clbl

getarg.c.3
getarg.c.4

   getarg = tmem '[' l1 ']'                             :(return)

*  elbl, plbl

getarg.c.5
getarg.c.6

   getarg = l1                                          :(return)

*  w,x, map register name

getarg.c.7
getarg.c.8

    getarg = regmap[l1]                                 :(return)


*  (x), register indirect
getarg.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    getarg = tmem '[' l2 ']'                            :(return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

getarg.c.10

    l1 = substr(l1,2,2)
    t1 = regmap[l1]
    getarg = tmem '[' t1 ']'
    (ident(l1,'xs') genaop(tstmt('//ASM	','add',t1,'cfp_b')))   :s(return)
    genaop(tstmt('//ASM	','lea',t1,'[' t1 '+cfp_b]'))           :(return)

*   -(x), register indirect, pre decrement

getarg.c.11

    t1 = regmap[substr(l1,3,2)]
    getarg = tmem '[' t1 ']'
    genbop(tstmt('//ASM	','lea',t1,'[' t1 '-cfp_b]'))           :(return)

*  int(x)
*  dlbl(x)

getarg.c.12
getarg.c.13

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[(cfp_b*' t1 ')+' regmap[t2] ']'     :(return)

*   name(x), where name is in working section

getarg.c.14
getarg.c.15

    l1 break('(') . t1 '(' len(2) . t2
    getarg = tmem '[' t1 '+'  regmap[t2] ']'            :(return)

*  signed integer

getarg.c.16 getarg = l1                                 :(return)

*  signed real

getarg.c.17 getarg = l1                                 :(return)

*   =dlbl

getarg.c.18

    getarg = substr(l1,2)                               :(return)

*   *dlbl

getarg.c.19

    getarg = 'cfp_b*' substr(l1,2)                      :(return)

*   =name (data section)

getarg.c.20
getarg.c.21

    getarg =  substr(l1,2)                              :(return)

*   =name (program section)

getarg.c.22

    getarg =  substr(l1,2)                              :(return)

*   pnam, eqop

getarg.c.23
getarg.c.24

   getarg = l1                                          :(return)

*  ptyp, text, dtext

getarg.c.25
getarg.c.26
getarg.c.27

   getarg = l1                                          :(return)







-stitl get_c_label(iarg,imem)
get_c_label get_c_label = get_c_argument(iarg,imem)	:s(return)f(freturn)





-stitl get_c_argument(iarg,imem)

get_c_argument	
*	t2 = &lastline
*	terminal = 'hi ' t2

    tmem = (differ(imem) '', 'm_word ')
    l1 = i.text(iarg)
    l1 'm_word ' = ''
    l2 = i.type(iarg)
    eq(l2)                                              :f($(get_c_argumentcase[l2]))
    get_c_argument = l1                                         :(get_c_argument_return)

*  int

get_c_argument.c.1

   get_c_argument = l1                                          :(get_c_argument_return)

*  dlbl

get_c_argument.c.2

   get_c_argument =  l1                                          :(get_c_argument_return)

*  wlbl, clbl

get_c_argument.c.3
get_c_argument.c.4

*   get_c_argument = tmem '*((word *)' l1 ')'                             :(get_c_argument_return)
   get_c_argument = tmem  l1                              :(get_c_argument_return)

*  elbl, plbl

get_c_argument.c.5
get_c_argument.c.6

   get_c_argument = l1                                          :(get_c_argument_return)

*  w,x, map register name

get_c_argument.c.7
get_c_argument.c.8

    get_c_argument = regmap[l1]                                 :(get_c_argument_return)


*  (x), register indirect
get_c_argument.c.9

    l1 len(1) len(2) . l2
    l2 = regmap[l2]
    get_c_argument = tmem '*(' l2 '_it.wp)'                            :(get_c_argument_return)

*  (x)+, register indirect, post increment
*  use lea reg,[reg+cfp_b] unless reg is esp, since it takes an extra byte.
*  actually, lea reg,[reg+cfp_b] and add reg,cfp_b are both 2 cycles and 3 bytes
*  for all the other regs, and either could be used.

get_c_argument.c.10

    l1 = substr(l1,2,2)
    t1 = regmap[l1]
    get_c_argument = tmem '*(it_' t1 '.wp++)'
    (ident(l1,'xs') genaop(tstmt('//ASM	','add',t1,'cfp_b')))   :s(get_c_argument_return)
    genaop(tstmt('//ASM	','lea',t1,'[' t1 '+cfp_b]'))           :(get_c_argument_return)

*   -(x), register indirect, pre decrement

get_c_argument.c.11

    t1 = regmap[substr(l1,3,2)]
    get_c_argument = tmem '*(--' t1 '_it.wp)'
    genbop(tstmt('//ASM	','lea',t1,'[' t1 '-cfp_b]'))           :(get_c_argument_return)

*  int(x)
*  dlbl(x)

get_c_argument.c.12
get_c_argument.c.13

    l1 break('(') . t1 '(' len(2) . t2
    get_c_argument = tmem '*(word *)(CFP_B*' t1 ')+' regmap[t2] '))'     :(get_c_argument_return)

*   name(x), where name is in working section

get_c_argument.c.14
get_c_argument.c.15

    l1 break('(') . t1 '(' len(2) . t2
    get_c_argument = tmem '*(word *)(' t1 ')+' regmap[t2] '))'     :(get_c_argument_return)

*  signed integer

get_c_argument.c.16 get_c_argument = l1                                 :(get_c_argument_return)

*  signed real

get_c_argument.c.17 get_c_argument = '(double)' l1                                 :(get_c_argument_return)

*   =dlbl

get_c_argument.c.18

    get_c_argument =  substr(l1,2)                               :(get_c_argument_return)

*   *dlbl

get_c_argument.c.19

    get_c_argument = 'CFP_B*' substr(l1,2)                      :(get_c_argument_return)

*   =name (data section)

get_c_argument.c.20
get_c_argument.c.21
   terminal = '(word)(&' substr(l1,2) ')'
    get_c_argument =  '(word)(&' substr(l1,2) ')'                             :(get_c_argument_return)

*   =name (program section)

get_c_argument.c.22

   terminal = '(word)(' substr(l1,2) ')'
    get_c_argument =   '(word)(' substr(l1,2) ')'                              :(get_c_argument_return)

*   pnam, eqop

get_c_argument.c.23
get_c_argument.c.24

   get_c_argument = l1                                          :(get_c_argument_return)

*  ptyp, text, dtext

get_c_argument.c.25
get_c_argument.c.26
get_c_argument.c.27

   get_c_argument = l1                                          :(get_c_argument_return)
    
get_c_argument_return
* fix the #defines and stuff
	get_c_argument 'm_word ' = ''
	get_c_argument = convert_value_c(get_c_argument)

	:(return)


-stitl memmem()t
memmem

*   memmem is called for those ops for which both operands may be
*   in memory, in which case, we generate code to load second operand
*   to pseudo-register 'w0', and then modify the second argument
*   to reference this register

    eq(ismem[i.type(i1)])                               :s(return)
    eq(ismem[i.type(i2)])                               :s(return)

*   here if memory-memory case, load second argument

    t = getarg(i2)
    i2 = minarg(8,'w0')
    genop('mov','w0',t)                                 :(return)

-stitl prcent(n)
prcent prcent = 'prc_+cfp_b*' ( n - 1)                  :(return)



-stitl outstmt(ostmt)label,opcode,op1,op2,op3,comment)
*   this module writes the components of the statement
*   passed in the argument list to the formatted .s file

outstmt 
    label = t.label(ostmt)

*   clear label if definition already emitted

    label = ident(label, lastlabel)

outstmt1

    comment = t.comment(ostmt)

*  ds suppress comments

    comment = tcomment = comments =
                                                        :(outstmt2)
*   attach source comment to first generated instruction

    differ(comment)                                     :s(outstmt2)
    ident(tcomment)                                     :s(outstmt2)
    comment = tcomment; tcomment =
outstmt2

    opcode = t.opc(ostmt)
    op1 = t.op1(ostmt)
    op2 = t.op2(ostmt)
    op3 = t.op3(ostmt)
    differ(compress)                                    :s(outstmt3)
    stmtout = rpad( rpad(label,7) ' ' rpad(opcode,4) ' '
.                 (ident(op1), op1
.                       (ident(op2), ',' op2
.                               (ident(op3), ',' op3))) ,27)
.       (ident(strip_comment,'y'), ' ' (ident(comment), ';') comment)
.                                                       :(outstmt4)
outstmt3

    stmtout = label tab opcode tab
.                 (ident(op1), op1
.                   (ident(op2), ',' op2
.                     (ident(op3), ',' op3)))
.       (ident(strip_comment,'y'), tab (ident(comment), ';') comment)

**      send text to outfile

**

outstmt4

**
**      send text to output file if not null.

*        stmtout = replace(trim(stmtout),'$','_')

    stmtout = trim(stmtout)
    ident(stmtout)                                      :s(return)
    eq(z_trace)                                         :s(outstmt5)

*        here if trace code desired for executable instructions

    chktrace()

outstmt5

    ident(stmtout)                                      :s(return)
    outfile = stmtout
    ntarget = ntarget + 1
    noutlines = noutlines + 1

*   record code labels in table with delimiter removed.
    (ge(sectnow,5) differ(thislabel))                   :f(return)
    label ? break(':') . label                          :f(return)
    labels_in_the_code_section<label> = noutlines                           :(return)








-stitl  chktrace()
chktrace

*                                                :(return)
*        output = 'chktrace:' inlines ':' label ':' stmtout
*        output = differ (label) 'chktrace label:' label ':'
*        turn off skip mode when begin executable code

    clabel = inlabel
    old_z_skip = z_skip
    old_z_exec = z_exec
    old_is_exec = is_exec
    z_skip = ident(inlabel,'s_aaa') 0

*        incode ? any(lcase)                     :s(return)

    uopcode  = replace(incode, lcase,ucase)

*   do not trace bsw (for now)

    ident(uopcode,'bsw')                                :s(return)
    is_exec = is_executable[uopcode]
    z_exec = ne(z_trace)  ident(inlabel, 's_aaa') 1
    z_exec = gt(nlines,2186) 1

*        need to skip certain blocks since otherwise get branches that are too long
*        skip when in code that won't assemble if try to trace
*        this was discovered on a case-by-case basis.

    z_skip  = differ(inlabel) differ(skip_on[inlabel]) 1
    z_skip  = differ(inlabel) differ(skip_off[inlabel]) 0

    ne(z_skip)                                          :s(return)
    eq(z_exec)                                          :s(return)
    eq(is_exec)                                         :s(return)
*        here to emit trace. need to emit trace after label if there is label
*        ident(inlabel)                          :s(chktrace.1)
*        only trace at labels since get jumps that are too removed otherwise
*        ident(label)                            :s(return)
*        here to emit trace code when there is label
*        first need to emit label, then fall through

*        stmtout ? break_ws  . label spanws  rem . body  :f(outstmt5)
*        stmtout = tab body
*        outfile = label
*        label =
    ne(in_gcol)                                         :s(return)

chktrace.1

    genz()
                                                        :(return)
genz

*        no trace if trace has been suspended
*        output = ne(z_suspend) 'z_suspend ' thisline

    ne(z_suspend)                                       :s(return)

*  only trace at label definition
*        ident(thislabel)                        :s(return)

    z_count = z_count + 1
    gt(z_first) le(z_count,z_first)                     :s(return)
    gt(z_limit)  gt(z_count, z_limit)                   :s(return)

*        always generate trace if at label definition

    z_desc = '"' replace(thisline,'{',' ') '"'
    outfile = tab 'zzz' tab z_count ',' nlines ',' z_desc
    outlines = outlines + 1
                                                        :(return)

-stitl prsarg(iarg)
prsarg

    prsarg = minarg(0)
    iarg break(',') . l1 ',' rem . l2                   :f(return)
    prsarg = minarg(convert(l1,'integer'),l2)           :(return)



-stitl readline()
*   this routine returns the next statement line in the input file
*   to the caller.  it does fail on eof.  if there is no more input,
*   then a minimal end statement is returned.
*   comments are passed through to the output file directly.
*  the failure 


readline
    readline = infile                                   :f(rl02)
    nlines  = nlines + 1
    ident( readline )                                   :s(readline)
    

readline.0

    leq( substr(readline,1,1 ),'*' )                    :s(rl01a)
* added # as a comment for linux reasons    
    leq( substr(readline,1,1 ),'#' )                    :s(rl01a)
* added // as a comment for c,java,javascript reasons    
    leq( substr(readline,1,2 ),'//' )                    :f(rl01)
rl01a    
    z_skip = ident(readline,'*z+') 0                    :s(readline)
    z_skip = ident(readline,'*z-') 1                    :s(readline)

*  force skip of full line comments
                                                        :(readline)
*   only print comment if requested.

    ident(strip_comment,'n')                            :f(readline)
    readline '*' | '#' | '//' = '//'
    outfile = readline
    noutlines = noutlines + 1        

		                      :(readline)

*   here if not a comment line

rl01             
                                       :(return)

*   here on eof

rl02

* we need to check for this in order to handle multiple passes for the C and other parsers
    readline = '		end'
                                                        :(return)
-stitl tblini(str)
*   this routine is called to initialize a table from a string of
*   index/value pairs.

tblini

    pos     = 0

*   count the number of "[" symbols to get an assessment of the table
*   size we need.

tin01

    str     (tab(*pos) '[' break(']') *?(cnt = cnt + 1) @pos)
.                                                       :s(tin01)

*   allocate the table, and then fill it. note that a small memory
*   optimisation is attempted here by trying to re-use the previous
*   value string if it is the same as the present one.

    tblini   = table(cnt)

tin02

    str     (break('[') $ index len(1) break(']') $ val len(1)) =
.                                                       :f(return)
    val     = convert( val,'integer' )
    val     = ident(val,lastval) lastval
    lastval = val
    tblini[index] = val                                 :(tin02)
-stitl generators

ifreg

    ge(i.type(iarg),7) le(i.type(iarg),8)               :f(freturn)s(return)

g.flc

    output = 'flc  not supported ' (end)
    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))
    t2 = genlab()

*   z_suspend = 1

    genop('cmp',t1,"'A'")
    genop('jb', t2 )
    genop('cmp',t1,"'Z'")
    genop('ja', t2)
    genop('add',t1,'32')
    genopl(t2 '                                         :')

*   z_suspend = 0
	gencode_c(2,'/* upper case folding not done */')
                                                        :(opdone)

g.mov

*   perhaps change mov x,(xr)+ to
*        mov ax,x; stows

*   perhaps do  mov (xl)+,wx as
*        lodsw
*        xchg ax,tx
*   and also mov (xl)+,name as
*        lodsw
*        mov name,w0
*   need to process memory-memory case
*   change 'mov (xs)+,a' to 'pop a'
*   change 'mov a,-(xs)' to 'push a'

    i.src = i2; i.dst = i1
    t.src = i.text(i.src); t.dst = i.text(i.dst)
    ident(t.src,'(xl)+')                                :s(mov.xlp)
    ident(t.src,'(xt)+')                                :s(mov.xtp)
    ident(t.src,'(xs)+')                                :s(mov.xsp)
    ident(t.dst,'(xr)+')                                :s(mov.xrp)
    ident(t.dst,'-(xs)')                                :s(mov.2)
    memmem()
    genop('mov',getarg(i1),getarg(i2))
                                                        :(g.mov.c)
mov.xtp
mov.xlp

    ident(t.dst,'(xr)+') genop('movs_w')                :s(g.mov.c)
    genop('lods_w')
    ident(t.dst,'-(xs)') genop('push','w0')             :s(g.mov.c)
    genop('mov',getarg(i.dst),'w0')                    
     		 :(g.mov.c)

mov.xsp
    ident(t.dst,'(xr)+')                                :s(mov.xsprp)
    genop('pop',getarg(i.dst))                          
    :(g.mov.c)

mov.xsprp genop('pop','w0')
    genop('stos_w')                                
	           :(g.mov.c)

mov.xrp genop('mov','w0',getarg(i.src))

    genop('stos_w')                                 
        :(g.mov.c)

mov.2

    genop('push',getarg(i.src))                          
	    :(g.mov.c)
	    
	    
g.mov.c
    ident(t.src,'(xl)+')                                :s(mov.c.xlp)
    ident(t.src,'(xt)+')                                :s(mov.c.xtp)
    ident(t.src,'(xs)+')                                :s(mov.c.xsp)
    ident(t.dst,'(xr)+')                                :s(mov.c.xrp)
g.mov.c2
    ident(t.dst,'-(xs)')                                :s(mov.c.2)
    :(mov.fixed_c)

mov.c.xsp
    gencode_c(2,get_c_argument(i1) '= C_POP();')
     :(opdone)

mov.c.xrp    
    i.text(i2) = '*(xr_it.wp++)'	    	    :(g.mov.c2)

mov.c.xlp
mov.c.xtp
    i.text(i2) = '*(xl_it.wp++)'	    	    :(g.mov.c2)
    
mov.c.2
	gencode_c(2,'C_PUSH(' get_c_argument(i2) ');')
	:(opdone)
	
mov.fixed_c
	gencode_c(2,get_c_argument(i1) '= ' get_c_argument(i2) ';')
	:(opdone)	        
    
    


*  odd/even tests.  if w reg, use low byte of register.

g.bod

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('jne',getarg(i2))                     
    gencode_c(2, 'if ((' better_register_name['w0'] ' = '  get_c_argument(i1) ' & 1))  C_GOTO(' get_c_label(i2) ');' )
    
	            :(opdone)

g.bev

    t1 = getarg(i1)
    t1 = eq(i.type(i1),8) reglow[t1]
    genop('test',t1,'1')
    genop('je',getarg(i2))
    gencode_c(2, 'if (!(' better_register_name['w0'] ' = '  get_c_argument(i1) ') & 1)  C_GOTO(' get_c_label(i2) ');' )
    
                                                        :(opdone)

g.brn

    genop('jmp',getarg(i1))                        
     gencode_c(2, ' C_GOTO(' get_c_label(i1) ');')
     gone_baby_gone = 1
*    and with that, ourr function is fonr
	      :(opdone)

g.bsw

    t1 = getarg(i1)
    t2 = genlab()
    z_suspend = 1
    ident(i.text(i3))                                   :s(g.bsw1)
    genop('cmp',t1,getarg(i2))    
    genop('jge',getarg(i3))
    gencode_c(2, 'if ((' better_register_name['w0'] ' = '  get_c_argument(i1) ' - '  get_c_argument(i2) ') >=0 )  C_GOTO(' get_c_label(i3) ');' )

*  here after default case.

g.bsw1

    genop('jmp', 'm_word [' t2 '+' t1 '*cfp_b]')
    genop('segment .data')
    genopl(t2 '                                         :')
    z_suspend = 0
    gencode_c(2, 'if ( ((m_word *)(cfp_b))[' t2 '+' get_c_argument(i1) ']((' 
+        better_register_name['w0'] ' = '  get_c_argument(i1) ' - ' get_c_argument(i2) ') >=0 )  C_GOTO(' get_c_label(i3) ');' )
    
                                                        :(opdone)

g.iff

    genop('d_word',getarg(i2))                     
    gencode_c(2, 'dword xxxl' linen ' = ' get_c_argument(i2) ';')
	 
	           :(opdone)

g.esw

    genop('segment .text')                             
     gencode_c(2, '// ?fjdk;ldf')
      :(opdone)

g.ent

*   entry points are stored in byte before program entry label
*   last arg is optional, in which case no initial 'db' need be
*   issued. we force odd alignment so can distinguish entry point
*   addresses from block addresses (which are always even).

*   note that this address of odd/even is less restrictive than
*   the minimal definition, which defines an even address as being
*   a multiple of cfp_b (4), and an odd address as one that is not
*   a multiple of cfp_b (ends in 1, 2, or 3).  the definition here
*   is a simple odd/even, least significant bit definition.
*   that is, for us, 1 and 3 are odd, 2 and 4 are even.


    t1 = i.text(i1)
    outfile = tab 'align' tab '2'
    differ(t1)                                          :s(g.ent.1)
    outfile = tab 'nop'
                                                        :(g.ent.2)
g.ent.1

    outfile = tab 'db' tab  t1

g.ent.2

    outlines = outlines + 2
    gencode_c(2,'// this needs to be an entry point - odd or some poo')
    genopl(thislabel)

*   note that want to attach label to last instruction
*        t1 = code_statements[code_statements.n]
*        t.label(t1) = tlabel
*        code_statements[code_statements.n] = t1
*   here to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    (differ(pubtab[thislabel]), differ(debug)) genop('global',thislabel)
    gencode_c(2,thislabel 'enhfefhrk // this needs to be an entry point - odd or some poo')
    thislabel =                                        
    
      :(opdone)

g.bri

    genop('jmp',getarg(i1))                           
     gencode_c(2,'C_GOTO(' get_c_label(i1) ' indirect branching wow);' )
     gone_baby_gone = 1
      
	  :(opdone)

g.lei
    t1 = regmap[i.text(i1)]
    genop('movzx',t1,'byte [' t1 '-1]' )              
    gencode_c(2,'hjlkdfhdflj/* entry point thing wha?*/')
    
        :(opdone)

g.jsr

    jsr_proc = getarg(i1)
    genop('call',jsr_proc)
    gencode_c(2,'C_JSR(' jsr_proc ');')
    

*        get count of following ppm statements


    jsr_count = ppm_cases[jsr_proc]
    eq(jsr_count)                                     g.jsr_zero
    z_suspend = 1
    jsr_calls = jsr_calls +  1
    jsr_label = 'call_' jsr_calls
    jsr_label_norm = jsr_label
    genop('dec','m_word [' rcode ']')
    genop('js',jsr_label_norm)
    gencode_c(2,'ddfhjdfhdf ppm ??? ' rcode) 
    z_suspend = 0

*        generate branch around for ppms that will follow
*        take the branch if normal return (eax==0)
                                                        :(opdone)
g.jsr_zero
	hey_did_a_jsr = jsr_proc
	hey_did_jsr_args = ''
	hey_did_jsr_count = 0
	eq(parser_pass,1)				:s(opdone)
* hey_did_a_jsr is so we can get the next pos
	next_pos = procedures[jsr_proc]['next_position']
	jsr_count = ppm_cases[jsr_proc]
	eq(jsr_count,0)					:f(opdone)

	gencode_c(2,'C_JSR(' jsr_proc ',' next_pos ');')
	:(opdone)


g.err
g.ppm

*   here with return code in rcode. it is zero for normal return
*   and positive for error return. decrement the value.
*   if it is negative then this is normal return. otherwise,
*   proceed decrementing rcode until it goes negative,and then
*   take the appropriate branch.

    t1 = getarg(i1)

*   branch to next case if rcode code still not negative.

    ident(incode,'ppm')                                 :s(g.ppm.loop)
    count.err =  count.err + 1
    hey_did_jsr_count = hey_did_jsr_count + 1
    hey_did_jsr_args = hey_did_jsr_args ',' '(C_ERR(' i.text(i1) '))' 
    errfile =   i.text(i1) ' ' i.text(i2)
    max.err = gt(t1,max.err) t1
                                                        :(g.ppm.loop)

g.ppm.loop.next

    genopl(lab_next '                                   :')
    jsr_count = jsr_count - 1
    hey_did_jsr_count = hey_did_jsr_count + 1
    hey_did_jsr_args = hey_did_jsr_args ',' 'C_GOTO(' t1 ')'
    z_suspend = eq(jsr_count) 0
    eq(jsr_count) genopl(jsr_label_norm ':')  
    gencode_c(2,'C_JSR_' hey_did_jsr_count '(' hey_did_a_jsr hey_did_jsr_args ');' )
    hey_did_a_jsr = ''
    hey_did_jsr_count = 0
    hey_did_jsr_args = ''
        :(opdone)

g.ppm.loop

    lab_next = genlab()
    genop('dec','m_word [' rcode ']')
    genop('jns',lab_next)
    ident(incode,'ppm')                                 :s(g.ppm.loop.ppm)

*   here if error exit via exi. set rcode to exit code and jump
*   to error handler with error code in rcode

g.ppm.loop.err

    genop('mov','m_word [' rcode ']', +t1)
    genop('jmp','err_')
                                                        :(g.ppm.loop.next)
g.ppm.loop.ppm

*        check each ppm case and take branch if appropriate
    ident(i.text(i1))                                   :s(g.ppm.2)
    count.ppm = count.ppm + 1
    genop('jmp',    getarg(i1))
                                                        :(g.ppm.loop.next)

g.ppm.2

*   a ppm with no arguments, which should never be executed, is
*   translated to err 299,internal logic error: unexpected ppm branch

    t1 = 299
    errfile =  t1 ' internal logic error                : unexpected ppm branch'
    hey_did_jsr_args = hey_did_jsr_args ',' '(C_ERR(' t1 '))'
    hey_did_jsr_count = hey_did_jsr_count + 1
                                                        :(g.ppm.loop.err)


g.prc

*   generate public declaration
*        t1 = thislabel
*        t1 ? rtab(1) . t1 ':'
*        genop()
*        genop('global',t1)
*   nop needed to get labels straight

    prc.args = getarg(i2)
    ppm_cases[thislabel] = i.text(i2)
    thislabel =
    max_exi = gt(prc.args,max_exi) prc.args
    prc.type = i.text(i1)                               :($('g.prc.' prc.type))

g.prc.e
g.prc.r           
    eq(parser_pass,1)				:s(g.prc.ccode)
                                      :(opdone)

g.prc.n
*   store return address in reserved location
    prc.count = prc.count + 1
    genop('pop', 'm_word [' prcent(nprc.count) ']')     
    
g.prc.ccode     
       :(opdone)

g.exi

    t1 = getarg(i1); t2 = prc.type; t3 = i.text(i1)

*   if type r or e, and no exit parameters, just return

    differ(t2,'n') eq(prc.args)     genop('ret')     
      :s(g.exi_c) 

    t3 = ident(t3) '0'
    genop('mov','m_word [' rcode ']',+t3)
    ident(t2,'n')                                       :s(g.exi.1)
    genop('ret')                                   
g.exi_c

    t3 = ident(t3) '0'
    gencode_c(2,'C_EXIT(' t3 ');')
    gone_baby_gone = 1
    	           :(opdone)

g.exi.1

    genop('mov','w0', 'm_word ['  prcent(prc.count) ']' )
    genop('jmp','w0')
    :(g.exi_c)

                                                        :(opdone)
							
							
g.enp   genop()                                         :(opdone)

g.erb
    errfile =  i.text(i1) ' ' i.text(i2)
*        set rcode to error code and branch to error handler
    genop('mov', 'm_word [' rcode ']',  +(i.text(i1)))
    genop('jmp','err_')
      gencode_c(2,'C_ERR( get_c_argument(i.text(i1))')
      gone_baby_gone = 1
                                                        :(opdone)


g.icv

    genop('inc',getarg(i1))                            
    gencode_c(2,'(' get_c_argument(i1) ')++;')
      :(opdone)

g.dcv

    genop('dec',getarg(i1))                  
    gencode_c(2,'(' get_c_argument(i1) ')++;')
               :(opdone)

g.zer

    ident(i.text(i1),'(xr)+') genop('mov','w0','0')
+               genop('stos_w')                         :s(opdone)
    ifreg(i1)                                           :s(g.zer1)
    ident(i.text(i1),'-(xs)')                           :s(g.zer.xs)
    genop('mov','w0','0')
    genop('mov',getarg(i1),'w0')                    
    gencode_c(2,'push 0 on stack')
	    :(opdone)

g.zer1

    t1 = getarg(i1)
    genop('xor',t1,t1)                                
    gencode_c(2,get_c_argument(i1) '=0;')
    
        :(opdone)

g.zer.xs

    genop('push','0')                
     gencode_c(2,'push 0 on stack other eway')
		                          :(opdone)

g.mnz

    genop('mov',getarg(i1),'xs')                
    gencode_c(2,'get_c_argument(i1) = ' better_register_name['xs'] ';' )
	            :(opdone)

g.ssl
g.sss
g.rtn

    genop()                                             :(opdone)

g.add   memmem()

    genop('add',getarg(i1),getarg(i2))                  
    gencode_c(2,get_c_argument(i1) ' += ' get_c_argument(i2) ';' )
    :(opdone)

g.sub   memmem()

    genop('sub',getarg(i1),getarg(i2))                 
    gencode_c(2,get_c_argument(i1) ' -= ' get_c_argument(i2) ';' )
    
     
       :(opdone)

g.ica   genop('add',getarg(i1),'cfp_b')                
    gencode_c(2,get_c_argument(i1) ' += ' 'CFP_B' ';')
  
  :(opdone)

g.dca   genop('sub',getarg(i1),'cfp_b')                 
    gencode_c(2,get_c_argument(i1) ' -= ' 'CFP_B' ';')

	:(opdone)

g.beq
g.bne
g.bgt
g.bge
g.blt
g.ble
g.blo
g.bhi

*   these operators all have two operands, memmem may apply
*   issue target opcode by table lookup.

    memmem()
    t1 = branchtab[incode]
    genop('cmp',getarg(i1),getarg(i2))
    genop(branchtab[incode],getarg(i3))
    gencode_c(2, 'if ((' better_register_name['w0'] ' =  (' get_c_argument(i1) 
+ '-'  get_c_argument(i2) ')) ' branchtab_standard_c[incode] ' 0) '
+  'C_GOTO(' get_c_label(i3) ');' )
    :(opdone)
    
* gencode_q is more complex. we are not using global variables (or local links)
* in this case we define the parameters coming into the kernel in pass 1
* and would make an after kernel - which might use items in the before kernel, might not
* so the uncompressed method would be to write a second kernel for the goto here
* but we could compress it using variables (v1, v2, etc) again with two passes to see if the data is input, and not output
* then there is the chain.
* if a chain uses WA as input, and that is run from p1, to p2 to p3 to p4, well, we need to carry that chain WA along.
* the same with known variables.  
* best to give the standard variables at first - registers general purpoise in or out.
* or we could have a define_jump that gives us temporaries that can change, or read onlys, or something.
* lets think about how to reduce the size:
* got an array of 1000 possible links in one direction, and 1000 in another direction
* 
* could have multiple kernels being built - one for kernel_base and one for kernel1 and one for kernel2 if they all go together without  a branch.
* but - too complex.
*
* variabes- kernel_name
* also      last_was_branch
* also 	    kernel has loop
*   eq(pass,1)	:f(g.pass2)
* see if it is kernel, then we can loop through
*g.pass1
*   eq(get_c_argument(i3),kernel_name) :s(g.pass1.go)
*   
*   eq(last_was_branch,1) 	:s(no_need_add_last_branch)
*   build_kernel_next(kernel_name,('kernel_name' '_ln_' nlines )
*  that name will
*   kernel_add_branch(getarg(i3)) :(g.pass1_finalize)
*
*g.pass1.go
*   kernel_add_while = 1
*g.pass1.finalize   
*   last_was_branch = 1
*   :(opdone)
*   
*
*g.pass2   
*   eq(get_c_argument(i3),kernel_name) :s(g.pass2.go)
*   last_was_branch = 1
*   gencode_q = 'if (' better_register_name['w0'] '=(' get_q_argument(i1) branchtab_standard_c[incode] get_q_argument(i2) ')) Q_GOTO(' get_q_label(i3) kernel_args_for(get_q_label(i3)) ');'
* later - first c then cuda/gpu crap - it will work, but the queues will be sparse sometimes and might need unsparsine.
* one way is via random number insertions from other queue , etc.
   

                                                       :(opdone)

g.bnz

    ifreg(i1)                                           :s(g.bnz1)
    genop('cmp', getarg(i1) ,'0')
    genop('jnz',getarg(i2))

                                                        :(g.bnz2)
g.bnz1
	
    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
g.bnz2    
    gencode_c(2, 'if (' better_register_name['w0'] ' = ' get_c_argument(i1) ') C_GOTO(' get_c_label(i2) ');' )
                                                        :(opdone)

g.bze   ifreg(i1)                                       :s(g.bze1)

    genop('cmp', getarg(i1)  ,'0')
    genop('jz',getarg(i2))
                                                        :(g.bze2)
g.bze1

    t1 = getarg(i1)
    genop('or',t1,t1)
    genop('jz',getarg(i2))                             
g.bze2    
    gencode_c(2, 'if ( !(' better_register_name['w0'] ' = ' get_c_argument(i1) ') ) C_GOTO(' get_c_label(i2) ');' )
 					:(opdone)
 
g.lct

*   if operands differ must emit code

    differ(i.text(i1),i.text(i2))                       :s(g.lct.1)

*   here if operands same. emit no code if no label, else emit null

    ident(thislabel)                                    :s(opnext)
    genop()                                        
	     :(opdone)

g.lct.1

    genop('mov',getarg(i1),getarg(i2))                  
    gencode_c(2,get_c_argument(i1) '= ' get_c_argument(i2) ';' )
    							:(opdone)
    

g.bct

*   can issue loop if target register is cx.

    t1 = getarg(i1)
    t2 = getarg(i2)
                                                        :(g.bct2)
    ident(t1,better_register_name['wa'])                                      :s(g.bct1)

g.bct2

    genop('dec',t1)
    genop('jnz',t2)              
    gencode_c(2, 'if ((' better_register_name['w0'] ' = (--' get_c_argument(i1) '))  C_GOTO(' get_c_label(i2) ');' )
    
    							:(opdone)

g.bct1

    genop('loop',t2)                                   
    gencode_c(2, 'loop?? wtf' get_c_label(i2) )
     
       :(opdone)

g.aov

    genop('add',getarg(i2),getarg(i1))
    genop('jc',getarg(i3))
* note - the opcode for this is doing carry, we are checking actual overflow where the carry could be 0 or 1,
* but if the sign bit flips, we went over.
    gencode_c(2,'{word a; word b='  get_c_argument(i2) '; word c= (a= ' get_c_argument(i1) ') += b; if (((a&0x8000000000000000) == (b&0x8000000000000000))' 
+      '  && ((a&0x8000000000000000) != (c&0x8000000000000000)))  C_GOTO(' get_c_label(i2) '); else a=c; ' better_register_name['w0'] ' = c;} /* overflow*/ ') 
                                                        :(opdone)
g.lcp
g.lcw
g.scp

    genop(op_,getarg(i1))                            
    gencode_c(2,'/* g.lcp do nothing I think */' )
    :(opdone)

*   use cp for code pointer.
    genop('mov',reg.cp,getarg(i1))
    gencode_c(2,better_register_name[reg.cp] '=' get_c_argument(i1) ';')
                                                        :(opdone)

    genop('mov',getarg(i1),reg.cp)
    gencode_c(2,get_c_argument(i1) '= ' better_register_name[reg.cp] ';' )
                                                        :(opdone)
*   should be able to get lodsd; xchg eax,getarg(i1)
    genop('mov',getarg(i1),'m_word [' reg.cp ']')
    genop('add',reg.cp,'cfp_b')
    gencode_c(2,get_c_argument(i1) '= (m_word)' better_register_name[reg.cp] ';  '  better_register_name[reg.cp] '+= cfp_b;' ) 

                                                        :(opdone)


g.icp

    genop(op_)                                          
    gencode_c(2,'/* g.icp do nothing I think */')
    
    :(opdone)
    genop('add',reg.cp,'cfp_b')
    
                                                        :(opdone)
g.ldi

    genop('mov','ia',getarg(i1))
    gencode_c(2,get_c_argument(i1) '= (m_word)' better_register_name[reg.cp] ';  '  better_register_name[reg.cp] '+= ' 'cfp_b;')
* yes, this falls in.    

g.sti

    genop('mov',getarg(i1),'ia')                    
    gencode_c(2,get_c_argument(i1) '= ' better_register_name['ia'] ';')
    :(opdone)

g.adi

    genop('add','ia',getarg(i1))                      
    
    gencode_c(2,better_register_name['ia'] '+=' get_c_argument(i1) ';')
      
	  :(opdone)

g.sbi

    genop('sub','ia',getarg(i1))                        :(opdone)
    gencode_c(2,better_register_name['ia'] '-=' get_c_argument(i1) ';')
 
g.mli

    genop('imul','ia',getarg(i1))                       :(opdone)
    gencode_c(2,better_register_name['ia'] '*=' get_c_argument(i1) ';')

g.dvi


    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rax')
    gencode_c(2,better_register_name['ia'] '=' better_register_name['ia'] ' / ' get_c_argument(i1) ';')
    
                                                        :(opdone)

g.rmi
    genop('mov','rax','ia')
    genop('cdq')
    genop('idiv',getarg(i1))
    genop('mov','ia','rdx')
    gencode_c(2,better_register_name['ia'] '=' better_register_name['ia'] ' % ' get_c_argument(i1) ';')
                                                        :(opdone)

g.ngi
    genop('neg','ia')                                   
    gencode_c(2,better_register_name['ia'] '= -' better_register_name['ia'] ';')
                                                        :(opdone)
    
    :(opdone)

g.ino
g.iov

    genop(op_,getarg(i1))                        
    gencode_c(2,'/*g.ino g.iov is a noop*/')

	   
		  
			        :(opdone)


g.ieq   jop = 'je'  
	the_test =     branchtab_standard_c['beq']                                    :(op.cmp)
g.ige   jop = 'jge'                              
	the_test =     branchtab_standard_c['bge']                                    :(op.cmp)
g.igt   jop = 'jg'                               
	the_test =     branchtab_standard_c['bgt']                                    :(op.cmp)
g.ile   jop = 'jle'                              
	the_test =     branchtab_standard_c['ble']                                    :(op.cmp)
g.ilt   jop = 'jl'                               
	the_test =     branchtab_standard_c['blt']                                    :(op.cmp)
g.ine   jop = 'jne'                              
	the_test =     branchtab_standard_c['bne']                                    :(op.cmp)
op.cmp

    genop('sti_',w0)
    genop('or',w0,w0)
    genop(jop,getarg(i1))                              
    gencode_c(2,'if (' better_register_name['w0'] ' ' the_test ' 0)  C_GOTO(' get_c_label(i1) ');' ) 
    
    						:(opdone)

*   real operations

g.itr

    genop('call','itr_')                           
    gencode_c(2,better_register_name['ra'] ' =  (double) (' better_register_name['ia'] ';') 
	 
	           :(opdone)

g.rti

    genop('rti_')
    eq(i.type(i1))                                      :s(opdone)

*   here if label given, branch if real too large

    genop('jc',getarg(i1))                          
    gencode_c(2,better_register_name['ia'] ' =  *( ' better_register_name['ra'] ');' )
    
	    :(opdone)

g.ldr
   tempg = better_register_name['ra'] ' =  *(' better_register_name['rp'] ');' 
	:(continue_real1  )
g.str
    tempg = '*(' better_register_name['rp'] ') = (' better_register_name['ra'] ');' 
	:(continue_real1)  
g.adr
    tempg = better_register_name['ra'] ' += *(' better_register_name['rp'] ');' 
	:(continue_real1  )
   
g.sbr
    tempg = better_register_name['ra'] ' -= *(' better_register_name['rp'] ');' 
	:(continue_real1  )
g.mlr
    tempg = better_register_name['ra'] ' *= *(' better_register_name['rp'] ');' 
	:(continue_real1  )
g.dvr
    tempg = '{if  *(' better_register_name['rp'] ') != 0.0 { ' better_register_name['ra'] ' /= *(' better_register_name['rp'] ');' 
+         better_register_name['fl'] '= 0;} else {'
+						 better_register_name['fl'] '=1;}'    
	:(continue_real1  )
continue_real1
    t1 = getarg(i1,'m_word')
    genop('lea','w0',t1)
    genop('call',op_)
    gencode_c(2,tempg)
                                                        :(opdone)
g.ngr
	tempg = better_register_name['ra'] ' = - ' better_register_name['ra'] ';'
	:(continue_real2)
g.atn
	tempg = better_register_name['ra'] ' = atan(' better_register_name['ra'] ');'
	:(continue_real2)
g.chp
	tempg = better_register_name['ra'] ' = (long)(' better_register_name['ra'] ');'
	:(continue_real2)
g.cos
	tempg = better_register_name['ra'] ' = cos(' better_register_name['ra'] ');'
	:(continue_real2)
g.etx
	tempg = better_register_name['ra'] ' = exp(' better_register_name['ra'] ');'
	:(continue_real2)
g.lnf
	tempg = better_register_name['ra'] ' = log(' better_register_name['ra'] ');'
	:(continue_real2)
g.sin
	tempg = better_register_name['ra'] ' = sin(' better_register_name['ra'] ');'
	:(continue_real2)
g.sqr
	tempg = better_register_name['ra'] ' = sqrt(' better_register_name['ra'] ');'
	:(continue_real2)
g.tan
	tempg = better_register_name['ra']  ' = tan(' better_register_name['ra'] ');'
	:(continue_real2)

continue_real2
    genop('call',op_)
     gencode_c(2,tempg)
     
                                                        :(opdone)

g.rov
g.rno
    genop(op_,getarg(i1))                               :(opdone)


g.req   jop = 'je'                                 
	the_test =     branchtab_standard_c['jeq']      :(g.r1)
g.rne   jop = 'jne'                                     
	the_test =     branchtab_standard_c['bne']                                    :(op.cmp)
	:(g.r1)
g.rge   jop = 'jge'                                     
	the_test =     branchtab_standard_c['bge']                                    :(op.cmp)
	:(g.r1)
g.rgt   jop = 'jg'                                      
	the_test =     branchtab_standard_c['bgt']                                    :(op.cmp)
	:(g.r1)
g.rle   jop = 'jle'                                     
	the_test =     branchtab_standard_c['ble']                                    :(op.cmp)
	:(g.r1)
g.rlt   jop = 'jl'
	the_test =     branchtab_standard_c['blt']                                    :(op.cmp)
g.r1    genop('call','cpr_')

    genop('mov','al','byte [reg_fl]')
    genop('or','al','al')
    genop(jop,getarg(i1))                            
* maybe should be al
    gencode_c(2,'if (' better_register_name['w0'] ' ' the_test ' 0)  C_GOTO(' get_c_label(i1) ');' ) 
    
          :(opdone)

g.plc
g.psc

    ne(cfp_b,cfp_c)                                     :s(g.plc.1)

*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' getarg(i2) ']')):s(plcpsc_done)
    genop('add',t1,'cfp_f')
    eq(i.type(i2))                            
	              :s(plcpsc_done)

*   here if d_offset_(given (in a variable), so add it in.

    genop('add',t1,getarg(i2))                        
                                                     :(plcpsc_done)

g.plc.1

*   here for case where character size if word size
*   last arg is optional.  if present and a register or constant,
*   use lea instead.

    t1 = getarg(i1)
    t2 = i.type(i2)
    ((ifreg(i2), ge(t2,1) le(t2,2))
+       genop('lea',t1,'[cfp_f+' t1 '+' 'cfp_b*' getarg(i2) ']')):s(plcpsc_done)
    genop('add',t1,'cfp_f')
    eq(i.type(i2))                                      :s(plcpsc_done)

*   here if d_offset_(given (in a variable), so add it in, after converting to byte count
    genop('mov','w0', getarg(i2))
    genop('sal','w0', 'log_cfp_b')

    genop('add',t1,'w0')                                :(plcpsc_done)

* now for c
plcpsc_done

    t1 = get_c_argument(i1)
    t2 = i.type(i2)
    ne(cfp_b,cfp_c)                                     :s(g.plc.1c)
*nonop that branch for now    
    
     ((ifreg(i2), ge(t2,1) le(t2,2)) 
+     gencode_c(2,'{char *effective_address = '  
+	get_c_argument(i1) ' + fp_f + ' get_c_argument(i2) ';}' )) :s(opdone)
     gencode_c(2,t1 ' += cfp_f;')
     eq(i.type(i2))			
     gencode_c(2,t1 ' += ' get_c_argument(i2) '<<log_cfp_b);' )
     		:s(opdone)
     
    
    
    
s.pcl.1c gencode_c(2,' hey you got some code to write at s.pcl.1c')        
			:(opdone)





*   lch requires separate cases for each first operand possibility.

g.lch

    t2 = i.text(i2)
    t1 = getarg(i1)

*   see if predecrement needed.
    leq('-',substr(t2,1,1))                             :f(g.lcg.1)
    t2 break('(') len(1) len(2) . t3
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))

g.lcg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0','0')
    eq(cfp_b,cfp_c) genop('mov','al','m_char [' regmap[t3] ']')
    eq(cfp_b,cfp_c) genop('mov',t1,'w0')

    ne(cfp_b,cfp_c) genop('mov',t1,'m_char [' regmap[t3] ']')

*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.lcg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.lcg.2                                                 :(opdone)

g.sch

    t2 = i.text(i2)
    eq(i.type(i1),8)                                    :s(g.scg.w)
    t1 = getarg(i1)
    eq(cfp_b,cfp_w)                                     :f(g.scg.0)
    ident(t2,'(xr)+')                                   :f(g.scg.0)

*   here if can use stos.

    eq(cfp_b,cfp_c) genop('mov','al',getarg(i1))
    ne(cfp_b,cfp_c) genop('mov','eax',getarg(i1))
    genop('stos_b')                                     :(opdone)

g.scg.0

    leq('-',substr(t2,1,1))                             :f(g.scg.1)
    t2 break('(') len(1) len(2) . t3
    genop('dec',regmap[t3])
    (eq(cfp_b,cfp_c) genop('dec',regmap[t3]), genop('sub',regmap[t3],'cfp_b'))
g.scg.1

    t2 break('(') len(1) len(2) . t3
    eq(cfp_b,cfp_c) genop('mov','w0',t1,)
    eq(cfp_b,cfp_c) genop('mov','[' regmap[t3] ']','al')
    ne(cfp_b,cfp_c) genop('mov','m_char [' regmap[t3] ']',t1)
*   see if postincrement needed.
    t2 rtab(1) '+'                                      :f(g.scg.2)
    (eq(cfp_b,cfp_c) genop('inc',regmap[t3]), genop('add',regmap[t3],'cfp_b'))

g.scg.2                                                 :(opdone)
g.scg.w

*   here if moving character from work register, convert t1
*   to name of low part.

    t1 = (eq(cfp_b,cfp_c) reglow[getarg(i1)], getarg(i1))

    ident(t2,'(xl)')                                    :s(g.scg.w.xl)
    ident(t2,'-(xl)')                                   :s(g.scg.w.pxl)
    ident(t2,'(xl)+')                                   :s(g.scg.w.xlp)
    ident(t2,'(xr)')                                    :s(g.scg.w.xr)
    ident(t2,'-(xr)')                                   :s(g.scg.w.pxr)
    ident(t2,'(xr)+')                                   :s(g.scg.w.xrp)

g.scg.w.xl

    genop('mov','m_char [xl]',t1)                       :(opdone)

g.scg.w.pxl

    (eq(cfp_b,cfp_c)  genop('dec', 'xl'), genop('sub','xl', 'cfp_b'))
    genop('mov','m_char [xl]',t1)                       :(opdone)

g.scg.w.xlp

    genop('mov','m_char [xl]',t1)
    (eq(cfp_b,cfp_c)  genop('inc', 'xl'), genop('add','xl', 'cfp_b'))
                                                        :(opdone)
g.scg.w.xr

    genop('mov','m_char [xr]',t1)                       :(opdone)

g.scg.w.pxr

    (eq(cfp_b,cfp_c)  genop('dec', 'xr'), genop('sub','xr', 'cfp_b'))
    genop('mov','m_char [xr]',t1)                       :(opdone)

g.scg.w.xrp

    (eq(cfp_b,cfp_c) genop('mov','al',t1), genop('mov','eax',t1))
    genop('stos_b')                                     :(opdone)

g.csc   ident(thislabel)                                :s(opnext)

    genop()                                             :(opdone)

g.ceq

    memmem()
    genop('cmp',getarg(i1),getarg(i2))
    genop('je',getarg(i3))
                                                        :(opdone)

g.cne   memmem()

    genop('cmp',getarg(i1),getarg(i2))
    genop('jnz',getarg(i3))
                                                        :(opdone)

g.cmc

    genop('repe','cmps_b')
    genop('mov','xl','0')
    genop('mov','xr','xl')
    t1 = getarg(i1)
    t2 = getarg(i2)
    (ident(t1,t2) genop('jnz',t1))                      :s(opdone)
    genop('ja',t2)
    genop('jb',t1)                                      :(opdone)

g.trc

    genop('xchg','xl','xr')
    eq(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','movzx','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genopl((t1 = genlab()) '            :','mov','w0','m_char [xr]')
    ne(cfp_b,cfp_c) genop('sal', 'w0', 'log_cfp_b');* convert char value to byte offset
    eq(cfp_b,cfp_c) genop('mov','al','[xl+w0]')
    ne(cfp_b,cfp_c) genop('mov','eax','[xl+w0]')
    genop('stos' op_c)
*        genop('loop',t1)
    genop('dec','wa')
    genop('jnz',t1)
    genop('xor','xl','xl')
    genop('xor','xr','xr')
                                                        :(opdone)

g.anb   genop('and',getarg(i1),getarg(i2))              :(opdone)

g.orb   genop('or',getarg(i1),getarg(i2))               :(opdone)

g.xob   genop('xor',getarg(i1),getarg(i2))              :(opdone)

g.cmb   genop('not',getarg(i1))                         :(opdone)


g.rsh

    genop('shr',getarg(i1),getarg(i2))                  :(opdone)

g.lsh

    genop('shl',getarg(i1),getarg(i2))                  :(opdone)

g.rsx

    error('rsx not supported')

g.lsx

    error('lsx not supported')

g.nzb   ifreg(i1)                                       :s(g.nzb1)

    genop('cmp',getarg(i1),'0')
    genop('jnz',getarg(i2))
                                                        :(opdone)
g.nzb1

    genop('or',getarg(i1),getarg(i1))
    genop('jnz',getarg(i2))
                                                        :(opdone)

g.zrb   ifreg(i1)                                       :s(g.zrb1)

    genop('cmp',getarg(i1),'0')
    genop('jz',getarg(i2))
                                                        :(opdone)
g.zrb1

    genop('or',getarg(i1),getarg(i1))
    genop('jz',getarg(i2))
                                                        :(opdone)

g.zgb

    genop('nop')                                        :(opdone)

g.zzz

    genop('zzz',getarg(i1))                             :(opdone)

g.wtb   genop('sal',getarg(i1),'log_cfp_b')             :(opdone)

g.btw   genop('shr',getarg(i1),'log_cfp_b')             :(opdone)


g.mti   ident(i.text(i1),'(xs)+')                       :f(g.mti.1)

    genop('pop','w0')
    genop('ldi_','w0')                                  :(opdone)

g.mti.1

    genop('ldi_',getarg(i1))                            :(opdone)

g.mfi

*   last arg is optional
*   compare with cfp$m, branching if result negative

    eq(i.type(i2))                                      :s(g.mfi.1)

*   here if label given, branch if wc not in range (ie, negative)

    genop('sti_','w0')
    genop('or','w0','w0')
    genop('js',getarg(i2))

g.mfi.1

    ident(i.text(i1),'-(xs)')                           :s(g.mfi.2)
    genop('sti_',getarg(i1))                            :(opdone)

g.mfi.2

    genop('sti_','w0')
    genop('push','w0')                                  :(opdone)

g.ctw

*   assume cfp_c chars per word

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctw.1)

*   here if one word per character, so just add character count

    genop('add',t1,i.text(i2))
                                                        :(opdone)
g.ctw.1

    genop('add',t1,'(cfp_c-1)+cfp_c*' i.text(i2))
    genop('shr',t1,'log_cfp_c')
                                                        :(opdone)
g.ctb

    t1 = getarg(i1)
    eq(cfp_b,cfp_c)                                     :s(g.ctb.1)

*   here if one word per character, so just add character count, then convert to byte count

    genop('add',t1,i.text(i2))
    genop('sal',getarg(i1),'log_cfp_b')                 :(opdone)

g.ctb.1

    genop('add',t1,'(cfp_b-1)+cfp_b*' i.text(i2))
    genop('and',t1,'-cfp_b')
                                                        :(opdone)
g.cvm   t1 = getarg(i1)

    genop('sti_',w0)
    genop('imul',w0,'10')
    genop('jo',t1)
    genop('sub',regmap['wb'],'ch_d0')
    genop('sub',w0,regmap['wb'])
    genop('ldi_',w0)
    genop('jo',t1)
                                                        :(opdone)
g.cvd

    genop('cvd_')                                       :(opdone)

g.mvc

*        use word move if character size is word size
*        if charsize is word size, convert character count to byte count for word move

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
    ne(cfp_b,cfp_c)                                     :s(g.mvw)
    t1 = genlab()
    z_suspend = 1
    genop('rep')
    genop('movs_b')
    z_suspend = 0
                                                        :(opdone)

g.mvw

    z_suspend = 1
    genop('shr','wa','log_cfp_b')
    genop('rep','movs_w')
    z_suspend = 0
                                                        :(opdone)

g.mwb

    genop('shr','wa','log_cfp_b')
    genop('std')
    genop('lea','xl','[xl-cfp_b]')
    genop('lea','xr','[xr-cfp_b]')
    genrep('movs_w')
    genop('cld')                                        :(opdone)

    genop('std')
    genop('shr','wa','log_cfp_b')
    genop('rep')
    genop('movs_w')
    genop('ctd')
                                                        :(opdone)

g.mcb

*        use word move if character size is word size

    ne(cfp_b,cfp_c) genop('shl', 'wa', 'log_cfp_b')
    ne(cfp_b,cfp_c)                                     :s(g.mwb)
    genop('std')
    genop('dec','xl')
    genop('dec','xr')
    genrep('movs_b')
    genop('cld')
                                                        :(opdone)
    genop('std')
    genop('rep')
    genop('movs_b')
    genop('cld')
                                                        :(opdone)
genrep

*        generate equivalent of rep op loop
    l1 = genlab()
    l2 = genlab()
    genopl(l1 '                                         :')
    genop('or','wa','wa')
    genop('jz',l2)
    genop(op)
    genop('dec','wa')
    genop('jmp',l1)
    genopl(l2 '                                         :')
                                                        :(return)

g.chk

    genop('cmp','xs','lowspmin')
    genop('jb','sec06')
                                                        :(opdone)

decend

*   here at end of dic or dac to see if want label made public

    thislabel ? rtab(1) . thislabel '                   :'
    differ(pubtab[thislabel]) genop('global',thislabel)
                                                        :(opdone)

g.dac

    t1 = i.type(i1)
    t2 = "" ;*(le(t1,2) "", le(t1,4) "d_offset_(", le(t1,6) "d_offset_(", "")
    genopl(thislabel,'d_word',t2 i.text(i1))
    
    eq(sectnow,3)			:s(g.dac_const)
    eq(sectnow,4)			:s(g.dac_no_const)
    	:(decend) 
g.dac_const
    current_label = do_current_label()
    eq(current_label_is_base,1)   :f(g.dac.noext1)
    gencode_c(1,'extern const d_word ' current_label ';' )
g.dac.noext1
    gencode_c(2,'const d_word ' current_label ' 		= ' convert_value_c(i.text(i1)) ';' )
g.dac.cdone1    
                                                        :(decend)
g.dac_no_const
    eq(current_label_is_base,1)   :f(g.dac.noext2)
    gencode_c(1,'extern d_word ' current_label ';' )
g.dac.noext2
    current_label = do_current_label()
    gencode_c(2,'d_word ' current_label ' 		= ' convert_value_c(i.text(i1)) ';' )
                                                        :(decend)
							
							
							
g.dic

    genopl(thislabel,'d_word',i.text(i1))
                                                        :(decend)

g.drc

    genop('align',8)
    t1 = i.text(i1)
    t1 ? fence "+" = ""
    genop('d_real',t1)

*   note that want to attach label to last instruction

    t.label(code_statements[code_statements.n]) = thislabel
    thislabel =                                         
    current_label = do_current_label()
    
    eq(sectnow,3)			:s(g.drc_const)
    eq(sectnow,4)			:s(g.drc_noconst)
    thislabel =                                         
    :(opdone)
g.drc_const
    eq(current_label_is_base,1)   :f(g.drc.noext1)
    gencode_c(1,'extern const double ' current_label ';' )
g.drc.noext1
    gencode_c(2,'const double ' current_label ' 		= ' convert_value_c(i.text(i1)) ';' )
    thislabel =                                         
        
    :(opdone)
g.drc_noconst
    eq(current_label_is_base,1)   :f(g.drc.noext2)
    gencode_c(1,'extern double ' current_label ';' )
g.drc.noext2
    gencode_c(2,'double ' current_label ' 		= ' convert_value_c(i.text(i1)) ';' )
    thislabel =                                         
        
    :(opdone)

g.dtc

*   change first and last chars to " (assume / used in source)

    t1 = i.text(i1)
    t1 tab(1) rtab(1) . t2
    t3 = remdr(size(t2),cfp_c)

*         t2 = "'" t2 "'"
*   append nulls to complete last word so constant length is multiple
*   of word word

    dtc_i = 1
    t4 =

g.dtc.1

    t4 = gt(dtc_i, 1) t4 ","
    t4 = t4 "'" substr(t2,dtc_i,1) "'"
    le(dtc_i = dtc_i + 1, size(t2))                     :s(g.dtc.1)

    t4 = ne(t3) t4 dupl(',0',cfp_c - t3)
    genopl(thislabel,'d_char',t4)
                                                        :(g.dtc.ccode)
    
g.dtc.ccode
    dtc_i = 1
    t1 = i.text(i1)
    t1 tab(1) rtab(1) . t2
    t3 = remdr(size(t2),cfp_c)
    t4 = ''
    t8 = 'const '
    eq(sectnow,3)			:s(g.dtc.ccode.1)
    eq(sectnow,4)			:f(opdone)
    t8 = ''
    
g.dtc.ccode.1
	t5 = "'" substr(t2,dtc_i,1) "'"
        current_label = do_current_label()
	eq(current_label_is_base,1)   :f(g.dtc.noext)
	gencode_c(1,"extern " t8 " char " current_label ';' )
g.dtc.noext	
	gencode_c(2,t8 "char " current_label " = " t5 ";" )
        le(dtc_i = dtc_i + 1, size(t2))                     :s(g.dtc.ccode.1)
	t6 = 0
g.dtc.ccode.2
	lt(t6,cfp_c - t3)				:f(opdone)
        current_label = do_current_label()
	gencode_c(2,t8 "char " current_label " = 0;" )
	t6 = t6 + 1	
	:(g.dtc.ccode.2)	
							
g.dbc

    genopl(thislabel,'d_word',getarg(i1))
    		:s(g.dbc_const)
    	:(opdone) 
g.dbc_const	   
    t8 = 'const '
    eq(sectnow,3)                       :s(g.dbc.ccode)
	    eq(sectnow,4)                       :f(opdone)
    t8 = ''	    
	    
g.dbc.ccode	    
    current_label = do_current_label()
    eq(current_label_is_base,1)   :f(g.dbc.noext)
    gencode_c(1,'extern ' t8 'd_word ' current_label ';' )
g.dbc.noext    
    gencode_c(2,t8 'd_word ' current_label ' 		= ' convert_value_c(i.text(i1)) ';' )
                                                        :(opdone)
g.equ

    genopl(thislabel,'equ',i.text(i1))
    eq(parser_pass,1) :f(opdone)
* make the definitions    
    c_definitions[thislabel] = table()
    c_definitions[thislabel]['upper_name'] = upper(thislabel)
    c_definitions[thislabel]['value'] = convert_value_c(i.text(i1))
    gencode_c(1,'#define ' c_definitions[thislabel]['upper_name'] '	' c_definitions[thislabel]['value'])
                                                        :(opdone)
g.exp

    ppm_cases[thislabel] = i.text(i1)
    genop('extern',thislabel)
    thislabel =                                         :(opdone)

g.inp

    ppm_cases[thislabel] = i.text(i2)
    prc.count1 = ident(i.text(i1),'n') prc.count1 + 1
+                                                       :(opnext)

g.ejc
g.inr                                                   :(opnext)
g.ttl

    genop('')
                                                        :(opdone)


g.sec

    genop('')
    sectnow = sectnow + 1                               :($("g.sec." sectnow))

*  procedure declaration section

g.sec.1

    genop('segment .text')
    genop('global','sec01')
    genopl('sec01' ':')         
    gencode_c(2,'/*-------------------------------------------------------------------- sec01 --------*/')
    gencode_c(2,'// procedure declarations ')
    				 :(opdone)

*   definitions section

g.sec.2

    genop('segment .data')
    genop('global','sec02')
    genopl('sec02' ':')                          
    gencode_c(2,'/*-------------------------------------------------------------------- sec02 --------*/')
    gencode_c(2,'// definitions ')
    
	   
		         :(opdone)

*  constants section

g.sec.3

    genop('segment .data')
    genop('global','sec03')
    genopl('sec03' ':')                             
    gencode_c(2,'/*-------------------------------------------------------------------- sec03 --------*/')
    gencode_c(2,'// constants ')
    
	    :(opdone)

*  working variables section

g.sec.4

    genop('global','esec03')
    genopl('esec03' '                                   :')
    gencode_c(2,'/*-------------------------------------------------------------------- esec03 --------*/')
    gencode_c(2,'// constants ')
    
    genop('segment .data')
    genop('global','sec04')
    genopl('sec04' ':')                           
    gencode_c(2,'/*-------------------------------------------------------------------- sec04 --------*/')
    gencode_c(2,'// working variables ')		      
			          :(opdone)

*   here at start of program section.  if any n type procedures,
*   put out entry-word block declaration at end of working storage

g.sec.5

*   emit code to indicate in code section
*   get direction set to up.

    genop('global','esec04')
    genopl('esec04' '                                   :')

*         (gt(prc.count1) genopl('prc$' ':','times', prc.count1 ' dd 0'))

    genop('prc_                                         : times ' prc.count1 ' dd 0')
    genop('global','lowspmin')
    genopl('lowspmin' '                                 :','d_word','0')
    genop('global','end_min_data')
    genopl('end_min_data' '                             :')
    genop('segment .text')
    genop('global','sec05')
    genopl('sec05' ':')                              
    gencode_c(2,'/*-------------------------------------------------------------------- esec04 --------*/')
    gencode_c(2,'word prc_;' )
    gencode_c(2,'word prc_1;' )
    gencode_c(2,'word prc_2;' )
    gencode_c(2,'word prc_3;' )
    gencode_c(2,'word prc_4;' )
    gencode_c(2,'word prc_5;' )
    gencode_c(2,'word prc_6;' )
    gencode_c(2,'word prc_7;' )
    gencode_c(2,'word prc_8;' )
    gencode_c(2,'word prc_9;' )
    gencode_c(2,'word prc_10;' )
    gencode_c(2,'word prc_11;' )
    gencode_c(2,'word prc_12;' )
    gencode_c(2,'word prc_13;' )
    gencode_c(2,'word prc_14;' )
    gencode_c(2,'word prc_15;' )
    gencode_c(2,'word prc_16;' )
    gencode_c(2,'word prc_17;' )
    gencode_c(2,'word prc_18;' )
    gencode_c(2,'word prc_19;' )
    gencode_c(2,'word prc_20;' )
    
    
    gencode_c(2,'/*-------------------------------------------------------------------- sec05 --------*/')
    gencode_c(2,'// working variables ')		      
    
       
	     :(opdone)

*   stack overflow section.  output exi__n tail code

g.sec.6

    genop('global','sec06')
    genopl('sec06'  '                                   :', 'nop')
    gencode_c(2,'/*-------------------------------------------------------------------- sec06 --------*/')
    gencode_c(2,'// stack overflow ')		      
    
                                                        :(opdone)

*   error section.  produce code to receive erb's

g.sec.7

    genop('global','sec07')
    gencode_c(2,'/*-------------------------------------------------------------------- sec07 --------*/')
    gencode_c(2,'// errors ')		      
    genopl('sec07' '                                    :')
    flush()
    
*   error section.  produce code to receive erb's

*        allow for some extra cases in case of max.err bad estimate
    n1 = max.err + 8
    output = '  max.err ' max.err
    genopl('err_                                        :','xchg',reg.wa,'m_word [' rcode ']')
                                                        :(opdone)


opdone

    flush()                                             :(opnext)

*   here to emit before_code_statements, code_statements, after_opcode_statements. attach input label and
*   comment to first instruction generated.

flush
* dont flush anything if C didnt do anything
    eq(did_c_code,1)							:f(opdone.6)
* flush it    
    eq(after_opcode_statements.n) eq(before_code_statements.n) eq(code_statements.n)              :f(opdone1)

*   here if some statements to emit, so output single 'null' statement to get label
*   and comment field right.

    label = thislabel =
    outstmt(tstmt())                                    :(opdone.6)

opdone1

    eq(before_code_statements.n)                                        :s(opdone.2)
    i = 1

opdone.1

    outstmt(before_code_statements[i])
    le(i = i + 1, before_code_statements.n)                             :s(opdone.1)

opdone.2

    eq(code_statements.n)                                        :s(opdone.4)
    i = 1

opdone.3

    outstmt(code_statements[i])
    le(i = i + 1, code_statements.n)                             :s(opdone.3)

opdone.4        eq(after_opcode_statements.n)                            :s(opdone.6)

    i = 1
    ident(pifatal[incode])                              :s(opdone.5)
*   here if post incrementing code not allowed
    error('post increment not allowed for op ' incode)

opdone.5

    outstmt(after_opcode_statements[i])
    le(i = i + 1, after_opcode_statements.n)                             :s(opdone.5)

opdone.6

    after_opcode_statements.n = before_code_statements.n = code_statements.n =                    :(return)

flush_end

report

    output = lpad(num,10) '  ' text                
    gencode_c(2,'/* done withflush*/')
         :(return)


g.end

    &dump = 0
    ident(havehdr)                                      :s(g.end.2)

*   here to copy remaining part from hdr file

g.end.1

    line = hdrfile                                      :f(g.end.2)
    ntarget = ntarget + 1
    noutlines = noutlines + 1
    outfile = line                                      :(g.end.1)

g.end.2

*   here at end of code generation.

    endfile(1)
    endfile(2)
    endfile(3)
    report(nlines,          'lines read')
    report(nstmts,          'statements processed')
    report(ntarget,         'target code lines produced')
    report(&stcount,        'spitbol statements executed')
    report(max.err,         'maximum err/erb number')
    report(prc.count1,      'prc count')
    output  = '  ' gt(prc.count,prc.count1)
.         '  differing counts for n-procedures          :'
.         ' inp ' prc.count1 ' prc ' prc.count
    differ(nerrors) report(nerrors,'errors detected')

    errfile = '* ' max.err ' maximum err/erb number'
    errfile  = '* ' prc.count ' prc count'
.               differ(lasterror) '  the last error was in line ' lasterror

    &code   = ne(nerrors) 2001
    report(collect(), 'free words')
                                                   :(end)


convert_value_c
	a = &anchor
	&anchor = 1
	b = x
	c = ''
	d = ''
cvl1 
	ident(b,'')		:s(cvd1)
	b p.c_token . c = '' 	:f(cvnon)
	c p.c_label 		:f(cvad)
	ident(c_definitions[c],'') :s(cvad)
	c = c_definitions[c]['upper_name'] :f(cvad)
	:(cvad)
cvnon   terminal = 'huh [' b '] '
	b any(1) . c = ''

cvad	d = d c
	:(cvl1)
cvd1	&anchor = a
	convert_value_c = d
	:(return)
							
							
upper   upper   =  replace(s, xUP_LO, xLO_UP)      :(return)
							

do_current_label														do_current_label    
    ident(thislabel,position_label)		:s(do_current_label.use_what_we_got)
    ident(thislabel,'')				:s(do_current_label.use_what_we_got)
    current_label_is_base = 1
    position_label = thislabel
    position_sequence = 0
    do_current_label = position_label
    do_current_label arbno(any(&alphabet)) . frrrff ':'  = frrrff
    	:(return)
do_current_label.use_what_we_got
	current_label_is_base = 0
	position_sequence = position_sequence + 1
	do_current_label = position_label '__pos__' position_sequence
    do_current_label arbno(any(&alphabet)) . frrrff ':'  = frrrff
	:(return)    
														

end
