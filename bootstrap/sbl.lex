||ttl|27,l i c e n s e -- software license for this program||||1
||ttl|27,s p i t b o l -- notes to implementors||||21
||ttl|27,s p i t b o l - revision history||||53
||ejc|||||54
||ejc|||||630
||ejc|||||686
||ejc|||||693
||ejc|||||747
||ejc|||||777
||ejc|||||807
||ejc|||||848
||ejc|||||900
||ejc|||||950
||ejc|||||1007
||ejc|||||1014
||ejc|||||1065
||ejc|||||1100
||ejc|||||1157
||ttl|27,minimal -- machine independent macro assembly lang.||||1184
||ejc|||||1185
||ttl|27,s p i t b o l  -- basic information||||1186
||ejc|||||1187
||ejc|||||1242
||ejc|||||1289
||ejc|||||1328
||ejc|||||1381
||ejc|||||1415
||ejc|||||1478
||ejc|||||1519
||ttl|27,s p i t b o l -- procedures section||||1690
||sec||||start of procedures section|1728
||ejc|||||1730
|sysax|exp|1,0|||define external entry point|1734
||ejc|||||1746
|sysbs|exp|1,3|||define external entry point|1751
||ejc|||||1771
|sysbx|exp|1,0|||define external entry point|1776
||ejc|||||1785
|sysdc|exp|1,0|||define external entry point|1879
||ejc|||||1886
|sysdm|exp|1,0|||define external entry point|1890
||ejc|||||1900
|sysdt|exp|1,0|||define external entry point|1904
||ejc|||||1920
|sysea|exp|1,1|||define external entry point|1924
||ejc|||||1946
|sysef|exp|1,3|||define external entry point|1950
||ejc|||||1963
|sysej|exp|1,0|||define external entry point|1967
||ejc|||||1987
|sysem|exp|1,0|||define external entry point|1991
||ejc|||||2008
|sysen|exp|1,3|||define external entry point|2012
||ejc|||||2034
|sysep|exp|1,0|||define external entry point|2038
||ejc|||||2044
|sysex|exp|1,3|||define external entry point|2048
||ejc|||||2093
|sysfc|exp|1,2|||define external entry point|2097
||ejc|||||2143
||ejc|||||2198
|sysgc|exp|1,0|||define external entry point|2202
||ejc|||||2226
|syshs|exp|1,8|||define external entry point|2230
||ejc|||||2269
|sysid|exp|1,0|||define external entry point|2273
||ejc|||||2298
|sysif|exp|1,1|||define external entry point|2303
||ejc|||||2336
|sysil|exp|1,0|||define external entry point|2341
||ejc|||||2360
|sysin|exp|1,3|||define external entry point|2364
||ejc|||||2383
|sysio|exp|1,2|||define external entry point|2387
||ejc|||||2422
|sysld|exp|1,3|||define external entry point|2426
||ejc|||||2445
|sysmm|exp|1,0|||define external entry point|2449
||ejc|||||2461
|sysmx|exp|1,0|||define external entry point|2465
||ejc|||||2491
|sysou|exp|1,2|||define external entry point|2495
||ejc|||||2517
|syspi|exp|1,1|||define external entry point|2521
||ejc|||||2537
|syspl|exp|1,3|||define external entry point|2541
||ejc|||||2564
|syspp|exp|1,0|||define external entry point|2568
||ejc|||||2630
|syspr|exp|1,1|||define external entry point|2634
||ejc|||||2660
|sysrd|exp|1,1|||define external entry point|2664
||ejc|||||2696
|sysri|exp|1,1|||define external entry point|2700
||ejc|||||2719
|sysrw|exp|1,3|||define external entry point|2723
||ejc|||||2736
|systm|exp|1,0|||define external entry point|2763
||ejc|||||2777
|systt|exp|1,0|||define external entry point|2781
||ejc|||||2788
|sysul|exp|1,0|||define external entry point|2792
||ejc|||||2808
|sysxi|exp|1,2|||define external entry point|2812
||ejc|||||2868
||ejc|||||2908
|acess|inp|25,r|1,1|||2912
|acomp|inp|25,n|1,5|||2913
|alloc|inp|25,e|1,0|||2914
|alocs|inp|25,e|1,0|||2919
|alost|inp|25,e|1,0|||2920
|arith|inp|25,n|1,3|||2928
|asign|inp|25,r|1,1|||2930
|asinp|inp|25,r|1,1|||2931
|blkln|inp|25,e|1,0|||2932
|cdgcg|inp|25,e|1,0|||2933
|cdgex|inp|25,r|1,0|||2934
|cdgnm|inp|25,r|1,0|||2935
|cdgvl|inp|25,r|1,0|||2936
|cdwrd|inp|25,e|1,0|||2937
|cmgen|inp|25,r|1,0|||2938
|cmpil|inp|25,e|1,0|||2939
|cncrd|inp|25,e|1,0|||2940
|copyb|inp|25,n|1,1|||2941
|dffnc|inp|25,e|1,0|||2942
|dtach|inp|25,e|1,0|||2943
|dtype|inp|25,e|1,0|||2944
|dumpr|inp|25,e|1,0|||2945
|ermsg|inp|25,e|1,0|||2950
|ertex|inp|25,e|1,0|||2951
|evali|inp|25,r|1,4|||2952
|evalp|inp|25,r|1,1|||2953
|evals|inp|25,r|1,3|||2954
|evalx|inp|25,r|1,1|||2955
|exbld|inp|25,e|1,0|||2956
|expan|inp|25,e|1,0|||2957
|expap|inp|25,e|1,1|||2958
|expdm|inp|25,n|1,0|||2959
|expop|inp|25,n|1,0|||2960
|filnm|inp|25,e|1,0|||2962
|gbcol|inp|25,e|1,0|||2967
|gbcpf|inp|25,e|1,0|||2968
|gtarr|inp|25,e|1,2|||2969
||ejc|||||2970
|gtcod|inp|25,e|1,1|||2971
|gtexp|inp|25,e|1,1|||2972
|gtint|inp|25,e|1,1|||2973
|gtnum|inp|25,e|1,1|||2974
|gtnvr|inp|25,e|1,1|||2975
|gtpat|inp|25,e|1,1|||2976
|gtrea|inp|25,e|1,1|||2979
|gtsmi|inp|25,n|1,2|||2981
|gtstg|inp|25,n|1,1|||2986
|gtvar|inp|25,e|1,1|||2987
|hashs|inp|25,e|1,0|||2988
|icbld|inp|25,e|1,0|||2989
|ident|inp|25,e|1,1|||2990
|inout|inp|25,e|1,0|||2991
|insta|inp|25,e|1,0|||2996
|iofcb|inp|25,n|1,3|||2997
|ioppf|inp|25,n|1,0|||2998
|ioput|inp|25,n|1,7|||2999
|ktrex|inp|25,r|1,0|||3000
|kwnam|inp|25,n|1,0|||3001
|lcomp|inp|25,n|1,5|||3002
|listr|inp|25,e|1,0|||3003
|listt|inp|25,e|1,0|||3004
|newfn|inp|25,e|1,0|||3006
|nexts|inp|25,e|1,0|||3008
|patin|inp|25,n|1,2|||3009
|patst|inp|25,n|1,1|||3010
|pbild|inp|25,e|1,0|||3011
|pconc|inp|25,e|1,0|||3012
|pcopy|inp|25,n|1,0|||3013
|prflr|inp|25,e|1,0|||3016
|prflu|inp|25,e|1,0|||3017
|prpar|inp|25,e|1,0|||3019
|prtch|inp|25,e|1,0|||3020
|prtic|inp|25,e|1,0|||3021
|prtis|inp|25,e|1,0|||3022
|prtin|inp|25,e|1,0|||3023
|prtmi|inp|25,e|1,0|||3024
|prtmm|inp|25,e|1,0|||3025
|prtmx|inp|25,e|1,0|||3026
|prtnl|inp|25,r|1,0|||3027
|prtnm|inp|25,r|1,0|||3028
|prtnv|inp|25,e|1,0|||3029
|prtpg|inp|25,e|1,0|||3030
|prtps|inp|25,e|1,0|||3031
|prtsn|inp|25,e|1,0|||3032
|prtst|inp|25,r|1,0|||3033
||ejc|||||3034
|prttr|inp|25,e|1,0|||3035
|prtvl|inp|25,r|1,0|||3036
|prtvn|inp|25,e|1,0|||3037
|rcbld|inp|25,e|1,0|||3040
|readr|inp|25,e|1,0|||3042
|relaj|inp|25,e|1,0|||3044
|relcr|inp|25,e|1,0|||3045
|reldn|inp|25,e|1,0|||3046
|reloc|inp|25,e|1,0|||3047
|relst|inp|25,e|1,0|||3048
|relws|inp|25,e|1,0|||3049
|rstrt|inp|25,e|1,0|||3051
|sbstr|inp|25,e|1,0|||3055
|scane|inp|25,e|1,0|||3056
|scngf|inp|25,e|1,0|||3057
|setvr|inp|25,e|1,0|||3058
|sorta|inp|25,n|1,1|||3061
|sortc|inp|25,e|1,1|||3062
|sortf|inp|25,e|1,0|||3063
|sorth|inp|25,n|1,0|||3064
|start|inp|25,e|1,0|||3066
|stgcc|inp|25,e|1,0|||3067
|tfind|inp|25,e|1,1|||3068
|tmake|inp|25,e|1,0|||3069
|trace|inp|25,n|1,2|||3070
|trbld|inp|25,e|1,0|||3071
|trimr|inp|25,e|1,0|||3072
|trxeq|inp|25,r|1,0|||3073
|vmake|inp|25,e|1,1|||3074
|xscan|inp|25,e|1,0|||3075
|xscni|inp|25,n|1,2|||3076
|arref|inr|||||3080
|cfunc|inr|||||3081
|exfal|inr|||||3082
|exint|inr|||||3083
|exits|inr|||||3084
|exixr|inr|||||3085
|exnam|inr|||||3086
|exnul|inr|||||3087
|exrea|inr|||||3090
|exsid|inr|||||3092
|exvnm|inr|||||3093
|failp|inr|||||3094
|flpop|inr|||||3095
|indir|inr|||||3096
|match|inr|||||3097
|retrn|inr|||||3098
|stcov|inr|||||3099
|stmgo|inr|||||3100
|stopr|inr|||||3101
|succp|inr|||||3102
|sysab|inr|||||3103
|systu|inr|||||3104
||ttl|27,s p i t b o l -- definitions and data structures||||3105
||sec||||start of definitions section|3109
|cfp_a|equ|24,256|||number of characters in alphabet|3122
|cfp_b|equ|24,8|||bytes/word addressing factor|3124
|cfp_c|equ|24,8|||number of characters per word|3126
|cfp_f|equ|24,16|||offset in bytes to chars in|3128
|cfp_i|equ|24,1|||number of words in integer constant|3131
|cfp_m|equ|24,9223372036854775807|||max positive integer in one word|3133
|cfp_n|equ|24,64|||number of bits in one word|3135
|cfp_r|equ|24,1|||number of words in real constant|3145
|cfp_s|equ|24,9|||number of sig digs for real output|3147
|cfp_x|equ|24,3|||max digits in real exponent|3149
|mxdgs|equ|24,cfp_s+cfp_x|||max digits in real number|3160
|nstmx|equ|24,mxdgs+5|||max space for real|3165
|cfp_u|equ|24,128|||realistic upper bound on alphabet|3175
||ejc|||||3177
|e_srs|equ|24,100|||30 words|3194
|e_sts|equ|24,1000|||500 words|3201
|e_cbs|equ|24,500|||500 words|3209
|e_hnb|equ|24,257|||127 bucket headers|3216
|e_hnw|equ|24,3|||6 words|3223
|e_fsp|equ|24,15|||15 percent|3233
|e_sed|equ|24,25|||25 percent|3241
||ejc|||||3243
|ch_la|equ|24,97|||letter a|3247
|ch_lb|equ|24,98|||letter b|3248
|ch_lc|equ|24,99|||letter c|3249
|ch_ld|equ|24,100|||letter d|3250
|ch_le|equ|24,101|||letter e|3251
|ch_lf|equ|24,102|||letter f|3252
|ch_lg|equ|24,103|||letter g|3253
|ch_lh|equ|24,104|||letter h|3254
|ch_li|equ|24,105|||letter i|3255
|ch_lj|equ|24,106|||letter j|3256
|ch_lk|equ|24,107|||letter k|3257
|ch_ll|equ|24,108|||letter l|3258
|ch_lm|equ|24,109|||letter m|3259
|ch_ln|equ|24,110|||letter n|3260
|ch_lo|equ|24,111|||letter o|3261
|ch_lp|equ|24,112|||letter p|3262
|ch_lq|equ|24,113|||letter q|3263
|ch_lr|equ|24,114|||letter r|3264
|ch_ls|equ|24,115|||letter s|3265
|ch_lt|equ|24,116|||letter t|3266
|ch_lu|equ|24,117|||letter u|3267
|ch_lv|equ|24,118|||letter v|3268
|ch_lw|equ|24,119|||letter w|3269
|ch_lx|equ|24,120|||letter x|3270
|ch_ly|equ|24,121|||letter y|3271
|ch_l_|equ|24,122|||letter z|3272
|ch_d0|equ|24,48|||digit 0|3276
|ch_d1|equ|24,49|||digit 1|3277
|ch_d2|equ|24,50|||digit 2|3278
|ch_d3|equ|24,51|||digit 3|3279
|ch_d4|equ|24,52|||digit 4|3280
|ch_d5|equ|24,53|||digit 5|3281
|ch_d6|equ|24,54|||digit 6|3282
|ch_d7|equ|24,55|||digit 7|3283
|ch_d8|equ|24,56|||digit 8|3284
|ch_d9|equ|24,57|||digit 9|3285
||ejc|||||3286
|ch_am|equ|24,38|||keyword operator (ampersand)|3294
|ch_as|equ|24,42|||multiplication symbol (asterisk)|3295
|ch_at|equ|24,64|||cursor position operator (at)|3296
|ch_bb|equ|24,60|||left array bracket (less than)|3297
|ch_bl|equ|24,32|||blank|3298
|ch_br|equ|24,124|||alternation operator (vertical bar)|3299
|ch_cl|equ|24,58|||goto symbol (colon)|3300
|ch_cm|equ|24,44|||comma|3301
|ch_dl|equ|24,36|||indirection operator (dollar)|3302
|ch_dt|equ|24,46|||name operator (dot)|3303
|ch_dq|equ|24,34|||double quote|3304
|ch_eq|equ|24,61|||equal sign|3305
|ch_ex|equ|24,33|||exponentiation operator (exclm)|3306
|ch_mn|equ|24,45|||minus sign / hyphen|3307
|ch_nm|equ|24,35|||number sign|3308
|ch_nt|equ|24,126|||negation operator (not)|3309
|ch_pc|equ|24,94|||percent|3310
|ch_pl|equ|24,43|||plus sign|3311
|ch_pp|equ|24,40|||left parenthesis|3312
|ch_rb|equ|24,62|||right array bracket (grtr than)|3313
|ch_rp|equ|24,41|||right parenthesis|3314
|ch_qu|equ|24,63|||interrogation operator (question)|3315
|ch_sl|equ|24,47|||slash|3316
|ch_sm|equ|24,59|||semicolon|3317
|ch_sq|equ|24,39|||single quote|3318
|ch_u_|equ|24,95|||special identifier char (underline)|3319
|ch_ob|equ|24,91|||opening bracket|3320
|ch_cb|equ|24,93|||closing bracket|3321
||ejc|||||3322
|ch_ht|equ|24,9|||horizontal tab|3329
|ch_ua|equ|24,65|||shifted a|3344
|ch_ub|equ|24,66|||shifted b|3345
|ch_uc|equ|24,67|||shifted c|3346
|ch_ud|equ|24,68|||shifted d|3347
|ch_ue|equ|24,69|||shifted e|3348
|ch_uf|equ|24,70|||shifted f|3349
|ch_ug|equ|24,71|||shifted g|3350
|ch_uh|equ|24,72|||shifted h|3351
|ch_ui|equ|24,73|||shifted i|3352
|ch_uj|equ|24,74|||shifted j|3353
|ch_uk|equ|24,75|||shifted k|3354
|ch_ul|equ|24,76|||shifted l|3355
|ch_um|equ|24,77|||shifted m|3356
|ch_un|equ|24,78|||shifted n|3357
|ch_uo|equ|24,79|||shifted o|3358
|ch_up|equ|24,80|||shifted p|3359
|ch_uq|equ|24,81|||shifted q|3360
|ch_ur|equ|24,82|||shifted r|3361
|ch_us|equ|24,83|||shifted s|3362
|ch_ut|equ|24,84|||shifted t|3363
|ch_uu|equ|24,85|||shifted u|3364
|ch_uv|equ|24,86|||shifted v|3365
|ch_uw|equ|24,87|||shifted w|3366
|ch_ux|equ|24,88|||shifted x|3367
|ch_uy|equ|24,89|||shifted y|3368
|ch_uz|equ|24,90|||shifted z|3369
|iodel|equ|24,32||||3376
||ejc|||||3380
||ejc|||||3411
|offs1|equ|24,1||||3439
|offs2|equ|24,2||||3440
|offs3|equ|24,3||||3441
||ejc|||||3447
|bl_ar|equ|24,0|||arblk     array|3468
|bl_cd|equ|24,bl_ar+1|||cdblk     code|3469
|bl_ex|equ|24,bl_cd+1|||exblk     expression|3470
|bl_ic|equ|24,bl_ex+1|||icblk     integer|3471
|bl_nm|equ|24,bl_ic+1|||nmblk     name|3472
|bl_p0|equ|24,bl_nm+1|||p0blk     pattern|3473
|bl_p1|equ|24,bl_p0+1|||p1blk     pattern|3474
|bl_p2|equ|24,bl_p1+1|||p2blk     pattern|3475
|bl_rc|equ|24,bl_p2+1|||rcblk     real|3476
|bl_sc|equ|24,bl_rc+1|||scblk     string|3477
|bl_se|equ|24,bl_sc+1|||seblk     expression|3478
|bl_tb|equ|24,bl_se+1|||tbblk     table|3479
|bl_vc|equ|24,bl_tb+1|||vcblk     array|3480
|bl_xn|equ|24,bl_vc+1|||xnblk     external|3481
|bl_xr|equ|24,bl_xn+1|||xrblk     external|3482
|bl_bc|equ|24,bl_xr+1|||bcblk     buffer|3483
|bl_pd|equ|24,bl_bc+1|||pdblk     program defined datatype|3484
|bl__d|equ|24,bl_pd+1|||number of block codes for data|3486
|bl_tr|equ|24,bl_pd+1|||trblk|3490
|bl_bf|equ|24,bl_tr+1|||bfblk|3491
|bl_cc|equ|24,bl_bf+1|||ccblk|3492
|bl_cm|equ|24,bl_cc+1|||cmblk|3493
|bl_ct|equ|24,bl_cm+1|||ctblk|3494
|bl_df|equ|24,bl_ct+1|||dfblk|3495
|bl_ef|equ|24,bl_df+1|||efblk|3496
|bl_ev|equ|24,bl_ef+1|||evblk|3497
|bl_ff|equ|24,bl_ev+1|||ffblk|3498
|bl_kv|equ|24,bl_ff+1|||kvblk|3499
|bl_pf|equ|24,bl_kv+1|||pfblk|3500
|bl_te|equ|24,bl_pf+1|||teblk|3501
|bl__i|equ|24,0|||default identification code|3503
|bl__t|equ|24,bl_tr+1|||code for data or trace block|3504
|bl___|equ|24,bl_te+1|||number of block codes|3505
||ejc|||||3506
||ejc|||||3544
|fcode|equ|24,0|||pointer to code for function|3561
|fargs|equ|24,1|||number of arguments|3562
||ejc|||||3580
|idval|equ|24,1|||id value field|3592
||ejc|||||3607
||ejc|||||3641
|artyp|equ|24,0|||pointer to dummy routine b_art|3645
|arlen|equ|24,idval+1|||length of arblk in bytes|3646
|arofs|equ|24,arlen+1|||offset in arblk to arpro field|3647
|arndm|equ|24,arofs+1|||number of dimensions|3648
|arlbd|equ|24,arndm+1|||low bound (first subscript)|3649
|ardim|equ|24,arlbd+cfp_i|||dimension (first subscript)|3650
|arlb2|equ|24,ardim+cfp_i|||low bound (second subscript)|3651
|ardm2|equ|24,arlb2+cfp_i|||dimension (second subscript)|3652
|arpro|equ|24,ardim+cfp_i|||array prototype (one dimension)|3653
|arvls|equ|24,arpro+1|||start of values (one dimension)|3654
|arpr2|equ|24,ardm2+cfp_i|||array prototype (two dimensions)|3655
|arvl2|equ|24,arpr2+1|||start of values (two dimensions)|3656
|arsi_|equ|24,arlbd|||number of standard fields in block|3657
|ardms|equ|24,arlb2-arlbd|||size of info for one set of bounds|3658
||ejc|||||3744
|cctyp|equ|24,0|||pointer to dummy routine b_cct|3767
|cclen|equ|24,cctyp+1|||length of ccblk in bytes|3768
|ccsln|equ|24,cclen+1|||source line number|3770
|ccuse|equ|24,ccsln+1|||offset past last used word (bytes)|3771
|cccod|equ|24,ccuse+1|||start of generated code in block|3775
||ejc|||||3780
|cdjmp|equ|24,0|||ptr to routine to execute statement|3805
|cdstm|equ|24,cdjmp+1|||statement number|3806
|cdsln|equ|24,cdstm+1|||source line number|3808
|cdlen|equ|24,cdsln+1|||length of cdblk in bytes|3809
|cdfal|equ|24,cdlen+1|||failure exit (see below)|3810
|cdcod|equ|24,cdfal+1|||executable pseudo-code|3815
|cdsi_|equ|24,cdcod|||number of standard fields in cdblk|3816
||ejc|||||3841
||ejc|||||3895
||ejc|||||3942
||ejc|||||3989
||ejc|||||4028
||ejc|||||4076
||ejc|||||4127
|cmidn|equ|24,0|||pointer to dummy routine b_cmt|4149
|cmlen|equ|24,cmidn+1|||length of cmblk in bytes|4150
|cmtyp|equ|24,cmlen+1|||type (c_xxx, see list below)|4151
|cmopn|equ|24,cmtyp+1|||operand pointer (see below)|4152
|cmvls|equ|24,cmopn+1|||operand value pointers (see below)|4153
|cmrop|equ|24,cmvls|||right (only) operator operand|4154
|cmlop|equ|24,cmvls+1|||left operator operand|4155
|cmsi_|equ|24,cmvls|||number of standard fields in cmblk|4156
|cmus_|equ|24,cmsi_+1|||size of unary operator cmblk|4157
|cmbs_|equ|24,cmsi_+2|||size of binary operator cmblk|4158
|cmar1|equ|24,cmvls+1|||array subscript pointers|4159
||ejc|||||4178
|c_arr|equ|24,0|||array reference|4183
|c_fnc|equ|24,c_arr+1|||function call|4184
|c_def|equ|24,c_fnc+1|||deferred expression (unary *)|4185
|c_ind|equ|24,c_def+1|||indirection (unary _)|4186
|c_key|equ|24,c_ind+1|||keyword reference (unary ampersand)|4187
|c_ubo|equ|24,c_key+1|||undefined binary operator|4188
|c_uuo|equ|24,c_ubo+1|||undefined unary operator|4189
|c_uo_|equ|24,c_uuo+1|||test value (=c_uuo+1=c_ubo+2)|4190
|c__nm|equ|24,c_uuo+1|||number of codes for name operands|4191
|c_bvl|equ|24,c_uuo+1|||binary op with value operands|4196
|c_uvl|equ|24,c_bvl+1|||unary operator with value operand|4197
|c_alt|equ|24,c_uvl+1|||alternation (binary bar)|4198
|c_cnc|equ|24,c_alt+1|||concatenation|4199
|c_cnp|equ|24,c_cnc+1|||concatenation, not pattern match|4200
|c_unm|equ|24,c_cnp+1|||unary op with name operand|4201
|c_bvn|equ|24,c_unm+1|||binary op (operands by value, name)|4202
|c_ass|equ|24,c_bvn+1|||assignment|4203
|c_int|equ|24,c_ass+1|||interrogation|4204
|c_neg|equ|24,c_int+1|||negation (unary not)|4205
|c_sel|equ|24,c_neg+1|||selection|4206
|c_pmt|equ|24,c_sel+1|||pattern match|4207
|c_pr_|equ|24,c_bvn|||last preevaluable code|4209
|c__nv|equ|24,c_pmt+1|||number of different cmblk types|4210
||ejc|||||4211
|cttyp|equ|24,0|||pointer to dummy routine b_ctt|4232
|ctchs|equ|24,cttyp+1|||start of character table words|4233
|ctsi_|equ|24,ctchs+cfp_a|||number of words in ctblk|4234
||ejc|||||4242
|dflen|equ|24,fargs+1|||length of dfblk in bytes|4274
|dfpdl|equ|24,dflen+1|||length of corresponding pdblk|4275
|dfnam|equ|24,dfpdl+1|||pointer to scblk for datatype name|4276
|dffld|equ|24,dfnam+1|||start of vrblk ptrs for field names|4277
|dfflb|equ|24,dffld-1|||offset behind dffld for field func|4278
|dfsi_|equ|24,dffld|||number of standard fields in dfblk|4279
||ejc|||||4284
|dvopn|equ|24,0|||entry address (ptr to o_xxx)|4301
|dvtyp|equ|24,dvopn+1|||type code (c_xxx, see cmblk)|4302
|dvlpr|equ|24,dvtyp+1|||left precedence (llxxx, see below)|4303
|dvrpr|equ|24,dvlpr+1|||right precedence (rrxxx, see below)|4304
|dvus_|equ|24,dvlpr+1|||size of unary operator dv|4305
|dvbs_|equ|24,dvrpr+1|||size of binary operator dv|4306
|dvubs|equ|24,dvus_+dvbs_|||size of unop + binop (see scane)|4307
||ejc|||||4337
|rrass|equ|24,10|||right     equal|4341
|llass|equ|24,00|||left      equal|4342
|rrpmt|equ|24,20|||right     question mark|4343
|llpmt|equ|24,30|||left      question mark|4344
|rramp|equ|24,40|||right     ampersand|4345
|llamp|equ|24,50|||left      ampersand|4346
|rralt|equ|24,70|||right     vertical bar|4347
|llalt|equ|24,60|||left      vertical bar|4348
|rrcnc|equ|24,90|||right     blank|4349
|llcnc|equ|24,80|||left      blank|4350
|rrats|equ|24,110|||right     at|4351
|llats|equ|24,100|||left      at|4352
|rrplm|equ|24,120|||right     plus, minus|4353
|llplm|equ|24,130|||left      plus, minus|4354
|rrnum|equ|24,140|||right     number|4355
|llnum|equ|24,150|||left      number|4356
|rrdvd|equ|24,160|||right     slash|4357
|lldvd|equ|24,170|||left      slash|4358
|rrmlt|equ|24,180|||right     asterisk|4359
|llmlt|equ|24,190|||left      asterisk|4360
|rrpct|equ|24,200|||right     percent|4361
|llpct|equ|24,210|||left      percent|4362
|rrexp|equ|24,230|||right     exclamation|4363
|llexp|equ|24,220|||left      exclamation|4364
|rrdld|equ|24,240|||right     dollar, dot|4365
|lldld|equ|24,250|||left      dollar, dot|4366
|rrnot|equ|24,270|||right     not|4367
|llnot|equ|24,260|||left      not|4368
|lluno|equ|24,999|||left      all unary operators|4369
||ejc|||||4385
|eflen|equ|24,fargs+1|||length of efblk in bytes|4412
|efuse|equ|24,eflen+1|||use count (for opsyn)|4413
|efcod|equ|24,efuse+1|||ptr to code (from sysld)|4414
|efvar|equ|24,efcod+1|||ptr to associated vrblk|4415
|efrsl|equ|24,efvar+1|||result type (see below)|4416
|eftar|equ|24,efrsl+1|||argument types (see below)|4417
|efsi_|equ|24,eftar|||number of standard fields in efblk|4418
||ejc|||||4441
|evtyp|equ|24,0|||pointer to dummy routine b_evt|4460
|evexp|equ|24,evtyp+1|||pointer to exblk for expression|4461
|evvar|equ|24,evexp+1|||pointer to trbev dummy trblk|4462
|evsi_|equ|24,evvar+1|||size of evblk|4463
||ejc|||||4472
|extyp|equ|24,0|||ptr to routine b_exl to load expr|4498
|exstm|equ|24,cdstm|||stores stmnt no. during evaluation|4499
|exsln|equ|24,exstm+1|||stores line no. during evaluation|4501
|exlen|equ|24,exsln+1|||length of exblk in bytes|4502
|exflc|equ|24,exlen+1|||failure code (=o_fex)|4506
|excod|equ|24,exflc+1|||pseudo-code for expression|4507
|exsi_|equ|24,excod|||number of standard fields in exblk|4508
||ejc|||||4523
|ffdfp|equ|24,fargs+1|||pointer to associated dfblk|4543
|ffnxt|equ|24,ffdfp+1|||ptr to next ffblk on chain or zero|4544
|ffofs|equ|24,ffnxt+1|||offset (bytes) to field in pdblk|4545
|ffsi_|equ|24,ffofs+1|||size of ffblk in words|4546
||ejc|||||4562
|icget|equ|24,0|||ptr to routine b_icl to load int|4577
|icval|equ|24,icget+1|||integer value|4578
|icsi_|equ|24,icval+cfp_i|||size of icblk|4579
||ejc|||||4582
|kvtyp|equ|24,0|||pointer to dummy routine b_kvt|4597
|kvvar|equ|24,kvtyp+1|||pointer to dummy block trbkv|4598
|kvnum|equ|24,kvvar+1|||keyword number|4599
|kvsi_|equ|24,kvnum+1|||size of kvblk|4600
||ejc|||||4605
|nmtyp|equ|24,0|||ptr to routine b_nml to load name|4620
|nmbas|equ|24,nmtyp+1|||base pointer for variable|4621
|nmofs|equ|24,nmbas+1|||offset for variable|4622
|nmsi_|equ|24,nmofs+1|||size of nmblk|4623
||ejc|||||4635
|pcode|equ|24,0|||ptr to match routine (p_xxx)|4648
|pthen|equ|24,pcode+1|||pointer to subsequent node|4649
|pasi_|equ|24,pthen+1|||size of p0blk|4650
||ejc|||||4657
|parm1|equ|24,pthen+1|||first parameter value|4672
|pbsi_|equ|24,parm1+1|||size of p1blk in words|4673
||ejc|||||4683
|parm2|equ|24,parm1+1|||second parameter value|4700
|pcsi_|equ|24,parm2+1|||size of p2blk in words|4701
||ejc|||||4711
|pdtyp|equ|24,0|||ptr to dummy routine b_pdt|4730
|pddfp|equ|24,idval+1|||ptr to associated dfblk|4731
|pdfld|equ|24,pddfp+1|||start of field value pointers|4732
|pdfof|equ|24,dffld-pdfld|||difference in offset to field ptrs|4733
|pdsi_|equ|24,pdfld|||size of standard fields in pdblk|4734
|pddfs|equ|24,dfsi_-pdsi_|||difference in dfblk, pdblk sizes|4735
||ejc|||||4744
|pflen|equ|24,fargs+1|||length of pfblk in bytes|4773
|pfvbl|equ|24,pflen+1|||pointer to vrblk for function name|4774
|pfnlo|equ|24,pfvbl+1|||number of locals|4775
|pfcod|equ|24,pfnlo+1|||ptr to vrblk for entry label|4776
|pfctr|equ|24,pfcod+1|||trblk ptr if call traced else 0|4777
|pfrtr|equ|24,pfctr+1|||trblk ptr if return traced else 0|4778
|pfarg|equ|24,pfrtr+1|||vrblk ptrs for arguments and locals|4779
|pfagb|equ|24,pfarg-1|||offset behind pfarg for arg, local|4780
|pfsi_|equ|24,pfarg|||number of standard fields in pfblk|4781
||ejc|||||4791
|rcget|equ|24,0|||ptr to routine b_rcl to load real|4804
|rcval|equ|24,rcget+1|||real value|4805
|rcsi_|equ|24,rcval+cfp_r|||size of rcblk|4806
||ejc|||||4810
|scget|equ|24,0|||ptr to routine b_scl to load string|4827
|sclen|equ|24,scget+1|||length of string in characters|4828
|schar|equ|24,sclen+1|||characters of string|4829
|scsi_|equ|24,schar|||size of standard fields in scblk|4830
||ejc|||||4845
|setyp|equ|24,0|||ptr to routine b_sel to load expr|4858
|sevar|equ|24,setyp+1|||ptr to vrblk for variable|4859
|sesi_|equ|24,sevar+1|||length of seblk in words|4860
||ejc|||||4861
||ejc|||||4894
|svbit|equ|24,0|||bit string indicating attributes|4898
|svlen|equ|24,1|||(=sclen) length of name in chars|4899
|svchs|equ|24,2|||(=schar) characters of name|4900
|svsi_|equ|24,2|||number of standard fields in svblk|4901
|svpre|equ|24,1|||set if preevaluation permitted|4902
|svffc|equ|24,svpre+svpre|||set on if fast call permitted|4903
|svckw|equ|24,svffc+svffc|||set on if keyword value constant|4904
|svprd|equ|24,svckw+svckw|||set on if predicate function|4905
|svnbt|equ|24,4|||number of bits to right of svknm|4906
|svknm|equ|24,svprd+svprd|||set on if keyword association|4907
|svfnc|equ|24,svknm+svknm|||set on if system function|4908
|svnar|equ|24,svfnc+svfnc|||set on if system function|4909
|svlbl|equ|24,svnar+svnar|||set on if system label|4910
|svval|equ|24,svlbl+svlbl|||set on if predefined value|4911
|svfnf|equ|24,svfnc+svnar|||function with no fast call|4918
|svfnn|equ|24,svfnf+svffc|||function with fast call, no preeval|4919
|svfnp|equ|24,svfnn+svpre|||function allowing preevaluation|4920
|svfpr|equ|24,svfnn+svprd|||predicate function|4921
|svfnk|equ|24,svfnn+svknm|||no preeval func + keyword|4922
|svkwv|equ|24,svknm+svval|||keyword + value|4923
|svkwc|equ|24,svckw+svknm|||keyword with constant value|4924
|svkvc|equ|24,svkwv+svckw|||constant keyword + value|4925
|svkvl|equ|24,svkvc+svlbl|||constant keyword + value + label|4926
|svfpk|equ|24,svfnp+svkvc|||preeval fcn + const keywd + val|4927
||ejc|||||4944
||ejc|||||4992
|k_abe|equ|24,0|||abend|5005
|k_anc|equ|24,k_abe+cfp_b|||anchor|5006
|k_cod|equ|24,k_anc+cfp_b|||code|5011
|k_com|equ|24,k_cod+cfp_b|||compare|5014
|k_dmp|equ|24,k_com+cfp_b|||dump|5015
|k_erl|equ|24,k_dmp+cfp_b|||errlimit|5019
|k_ert|equ|24,k_erl+cfp_b|||errtype|5020
|k_ftr|equ|24,k_ert+cfp_b|||ftrace|5021
|k_fls|equ|24,k_ftr+cfp_b|||fullscan|5022
|k_inp|equ|24,k_fls+cfp_b|||input|5023
|k_mxl|equ|24,k_inp+cfp_b|||maxlength|5024
|k_oup|equ|24,k_mxl+cfp_b|||output|5025
|k_pfl|equ|24,k_oup+cfp_b|||profile|5029
|k_tra|equ|24,k_pfl+cfp_b|||trace|5030
|k_trm|equ|24,k_tra+cfp_b|||trim|5032
|k_fnc|equ|24,k_trm+cfp_b|||fnclevel|5036
|k_lst|equ|24,k_fnc+cfp_b|||lastno|5037
|k_lln|equ|24,k_lst+cfp_b|||lastline|5039
|k_lin|equ|24,k_lln+cfp_b|||line|5040
|k_stn|equ|24,k_lin+cfp_b|||stno|5041
|k_abo|equ|24,k_stn+cfp_b|||abort|5048
|k_arb|equ|24,k_abo+pasi_|||arb|5049
|k_bal|equ|24,k_arb+pasi_|||bal|5050
|k_fal|equ|24,k_bal+pasi_|||fail|5051
|k_fen|equ|24,k_fal+pasi_|||fence|5052
|k_rem|equ|24,k_fen+pasi_|||rem|5053
|k_suc|equ|24,k_rem+pasi_|||succeed|5054
||ejc|||||5055
|k_alp|equ|24,k_suc+1|||alphabet|5061
|k_rtn|equ|24,k_alp+1|||rtntype|5062
|k_stc|equ|24,k_rtn+1|||stcount|5063
|k_etx|equ|24,k_stc+1|||errtext|5064
|k_fil|equ|24,k_etx+1|||file|5066
|k_lfl|equ|24,k_fil+1|||lastfile|5067
|k_stl|equ|24,k_lfl+1|||stlimit|5068
|k_lcs|equ|24,k_stl+1|||lcase|5073
|k_ucs|equ|24,k_lcs+1|||ucase|5074
|k__al|equ|24,k_alp-k_alp|||alphabet|5079
|k__rt|equ|24,k_rtn-k_alp|||rtntype|5080
|k__sc|equ|24,k_stc-k_alp|||stcount|5081
|k__et|equ|24,k_etx-k_alp|||errtext|5082
|k__fl|equ|24,k_fil-k_alp|||file|5084
|k__lf|equ|24,k_lfl-k_alp|||lastfile|5085
|k__sl|equ|24,k_stl-k_alp|||stlimit|5087
|k__lc|equ|24,k_lcs-k_alp|||lcase|5089
|k__uc|equ|24,k_ucs-k_alp|||ucase|5090
|k__n_|equ|24,k__uc+1|||number of special cases|5091
|k_p__|equ|24,k_fnc|||first protected keyword|5098
|k_v__|equ|24,k_abo|||first keyword with constant value|5099
|k_s__|equ|24,k_alp|||first keyword with special acess|5100
||ejc|||||5101
|tbtyp|equ|24,0|||pointer to dummy routine b_tbt|5122
|tblen|equ|24,offs2|||length of tbblk in bytes|5123
|tbinv|equ|24,offs3|||default initial lookup value|5124
|tbbuk|equ|24,tbinv+1|||start of hash bucket pointers|5125
|tbsi_|equ|24,tbbuk|||size of standard fields in tbblk|5126
|tbnbk|equ|24,11|||default no. of buckets|5127
||ejc|||||5136
|tetyp|equ|24,0|||pointer to dummy routine b_tet|5153
|tesub|equ|24,tetyp+1|||subscript value|5154
|teval|equ|24,tesub+1|||(=vrval) table element value|5155
|tenxt|equ|24,teval+1|||link to next teblk|5156
|tesi_|equ|24,tenxt+1|||size of teblk in words|5158
||ejc|||||5167
|tridn|equ|24,0|||pointer to dummy routine b_trt|5187
|trtyp|equ|24,tridn+1|||trap type code|5188
|trval|equ|24,trtyp+1|||value of trapped variable (=vrval)|5189
|trnxt|equ|24,trval|||ptr to next trblk on trblk chain|5190
|trlbl|equ|24,trval|||ptr to actual label (traced label)|5191
|trkvr|equ|24,trval|||vrblk pointer for keyword trace|5192
|trtag|equ|24,trval+1|||trace tag|5193
|trter|equ|24,trtag|||ptr to terminal vrblk or null|5194
|trtrf|equ|24,trtag|||ptr to trblk holding fcblk ptr|5195
|trfnc|equ|24,trtag+1|||trace function vrblk (zero if none)|5196
|trfpt|equ|24,trfnc|||fcblk ptr for sysio|5197
|trsi_|equ|24,trfnc+1|||number of words in trblk|5198
|trtin|equ|24,0|||trace type for input association|5200
|trtac|equ|24,trtin+1|||trace type for access trace|5201
|trtvl|equ|24,trtac+1|||trace type for value trace|5202
|trtou|equ|24,trtvl+1|||trace type for output association|5203
|trtfc|equ|24,trtou+1|||trace type for fcblk identification|5204
||ejc|||||5205
||ejc|||||5247
||ejc|||||5295
||ejc|||||5345
|vctyp|equ|24,0|||pointer to dummy routine b_vct|5364
|vclen|equ|24,offs2|||length of vcblk in bytes|5365
|vcvls|equ|24,offs3|||start of vector values|5366
|vcsi_|equ|24,vcvls|||size of standard fields in vcblk|5367
|vcvlb|equ|24,vcvls-1|||offset one word behind vcvls|5368
|vctbd|equ|24,tbsi_-vcsi_|||difference in sizes - see prtvl|5369
||ejc|||||5374
||ejc|||||5417
|vrget|equ|24,0|||pointer to routine to load value|5421
|vrsto|equ|24,vrget+1|||pointer to routine to store value|5422
|vrval|equ|24,vrsto+1|||variable value|5423
|vrvlo|equ|24,vrval-vrsto|||offset to value from store field|5424
|vrtra|equ|24,vrval+1|||pointer to routine to jump to label|5425
|vrlbl|equ|24,vrtra+1|||pointer to code for label|5426
|vrlbo|equ|24,vrlbl-vrtra|||offset to label from transfer field|5427
|vrfnc|equ|24,vrlbl+1|||pointer to function block|5428
|vrnxt|equ|24,vrfnc+1|||pointer to next vrblk on hash chain|5429
|vrlen|equ|24,vrnxt+1|||length of name (or zero)|5430
|vrchs|equ|24,vrlen+1|||characters of name (vrlen gt 0)|5431
|vrsvp|equ|24,vrlen+1|||ptr to svblk (vrlen eq 0)|5432
|vrsi_|equ|24,vrchs+1|||number of standard fields in vrblk|5433
|vrsof|equ|24,vrlen-sclen|||offset to dummy scblk for name|5434
|vrsvo|equ|24,vrsvp-vrsof|||pseudo-offset to vrsvp field|5435
||ejc|||||5471
|xntyp|equ|24,0|||pointer to dummy routine b_xnt|5493
|xnlen|equ|24,xntyp+1|||length of xnblk in bytes|5494
|xndta|equ|24,xnlen+1|||data words|5495
|xnsi_|equ|24,xndta|||size of standard fields in xnblk|5496
||ejc|||||5501
|xrtyp|equ|24,0|||pointer to dummy routine b_xrt|5523
|xrlen|equ|24,xrtyp+1|||length of xrblk in bytes|5524
|xrptr|equ|24,xrlen+1|||start of address pointers|5525
|xrsi_|equ|24,xrptr|||size of standard fields in xrblk|5526
||ejc|||||5527
|cnvst|equ|24,8|||max standard type code for convert|5533
|cnvrt|equ|24,cnvst+1|||convert code for reals|5537
|cnvbt|equ|24,cnvrt|||no buffers - same as real code|5540
|cnvtt|equ|24,cnvbt+1|||bsw code for convert|5544
|iniln|equ|24,1024|||default image length for compiler|5548
|inils|equ|24,1024|||image length if -sequ in effect|5549
|ionmb|equ|24,2|||name base used for iochn in sysio|5551
|ionmo|equ|24,4|||name offset used for iochn in sysio|5552
|mnlen|equ|24,1024|||min value allowed keyword maxlngth|5557
|mxern|equ|24,329|||err num inadequate startup memory|5558
|num01|equ|24,1||||5564
|num02|equ|24,2||||5565
|num03|equ|24,3||||5566
|num04|equ|24,4||||5567
|num05|equ|24,5||||5568
|num06|equ|24,6||||5569
|num07|equ|24,7||||5570
|num08|equ|24,8||||5571
|num09|equ|24,9||||5572
|num10|equ|24,10||||5573
|num25|equ|24,25||||5574
|nm320|equ|24,320||||5575
|nm321|equ|24,321||||5576
|nini8|equ|24,998||||5577
|nini9|equ|24,999||||5578
|thsnd|equ|24,1000||||5579
||ejc|||||5580
|opbun|equ|24,5|||no. of binary undefined ops|5584
|opuun|equ|24,6|||no of unary undefined ops|5585
|prsnf|equ|24,13|||offset used in prtsn|5589
|prtmf|equ|24,21|||offset to col 21 (prtmi)|5590
|rilen|equ|24,1024|||buffer length for sysri|5591
|stgic|equ|24,0|||initial compile|5595
|stgxc|equ|24,stgic+1|||execution compile (code)|5596
|stgev|equ|24,stgxc+1|||expression eval during execution|5597
|stgxt|equ|24,stgev+1|||execution time|5598
|stgce|equ|24,stgxt+1|||initial compile after end line|5599
|stgxe|equ|24,stgce+1|||exec. compile after end line|5600
|stgnd|equ|24,stgce-stgic|||difference in stage after end|5601
|stgee|equ|24,stgxe+1|||eval evaluating expression|5602
|stgno|equ|24,stgee+1|||number of codes|5603
||ejc|||||5604
|stnpd|equ|24,8|||statement no. pad count|5609
|t_uop|equ|24,0|||unary operator|5617
|t_lpr|equ|24,t_uop+3|||left paren|5618
|t_lbr|equ|24,t_lpr+3|||left bracket|5619
|t_cma|equ|24,t_lbr+3|||comma|5620
|t_fnc|equ|24,t_cma+3|||function call|5621
|t_var|equ|24,t_fnc+3|||variable|5622
|t_con|equ|24,t_var+3|||constant|5623
|t_bop|equ|24,t_con+3|||binary operator|5624
|t_rpr|equ|24,t_bop+3|||right paren|5625
|t_rbr|equ|24,t_rpr+3|||right bracket|5626
|t_col|equ|24,t_rbr+3|||colon|5627
|t_smc|equ|24,t_col+3|||semi-colon|5628
|t_fgo|equ|24,t_smc+1|||failure goto|5632
|t_sgo|equ|24,t_fgo+1|||success goto|5633
|t_uok|equ|24,t_fnc|||last code ok before unary operator|5639
||ejc|||||5640
|t_uo0|equ|24,t_uop+0|||unary operator, state zero|5644
|t_uo1|equ|24,t_uop+1|||unary operator, state one|5645
|t_uo2|equ|24,t_uop+2|||unary operator, state two|5646
|t_lp0|equ|24,t_lpr+0|||left paren, state zero|5647
|t_lp1|equ|24,t_lpr+1|||left paren, state one|5648
|t_lp2|equ|24,t_lpr+2|||left paren, state two|5649
|t_lb0|equ|24,t_lbr+0|||left bracket, state zero|5650
|t_lb1|equ|24,t_lbr+1|||left bracket, state one|5651
|t_lb2|equ|24,t_lbr+2|||left bracket, state two|5652
|t_cm0|equ|24,t_cma+0|||comma, state zero|5653
|t_cm1|equ|24,t_cma+1|||comma, state one|5654
|t_cm2|equ|24,t_cma+2|||comma, state two|5655
|t_fn0|equ|24,t_fnc+0|||function call, state zero|5656
|t_fn1|equ|24,t_fnc+1|||function call, state one|5657
|t_fn2|equ|24,t_fnc+2|||function call, state two|5658
|t_va0|equ|24,t_var+0|||variable, state zero|5659
|t_va1|equ|24,t_var+1|||variable, state one|5660
|t_va2|equ|24,t_var+2|||variable, state two|5661
|t_co0|equ|24,t_con+0|||constant, state zero|5662
|t_co1|equ|24,t_con+1|||constant, state one|5663
|t_co2|equ|24,t_con+2|||constant, state two|5664
|t_bo0|equ|24,t_bop+0|||binary operator, state zero|5665
|t_bo1|equ|24,t_bop+1|||binary operator, state one|5666
|t_bo2|equ|24,t_bop+2|||binary operator, state two|5667
|t_rp0|equ|24,t_rpr+0|||right paren, state zero|5668
|t_rp1|equ|24,t_rpr+1|||right paren, state one|5669
|t_rp2|equ|24,t_rpr+2|||right paren, state two|5670
|t_rb0|equ|24,t_rbr+0|||right bracket, state zero|5671
|t_rb1|equ|24,t_rbr+1|||right bracket, state one|5672
|t_rb2|equ|24,t_rbr+2|||right bracket, state two|5673
|t_cl0|equ|24,t_col+0|||colon, state zero|5674
|t_cl1|equ|24,t_col+1|||colon, state one|5675
|t_cl2|equ|24,t_col+2|||colon, state two|5676
|t_sm0|equ|24,t_smc+0|||semicolon, state zero|5677
|t_sm1|equ|24,t_smc+1|||semicolon, state one|5678
|t_sm2|equ|24,t_smc+2|||semicolon, state two|5679
|t_nes|equ|24,t_sm2+1|||number of entries in branch table|5681
||ejc|||||5682
|cc_do|equ|24,0|||-double|5690
|cc_co|equ|24,cc_do+1|||-compare|5693
|cc_du|equ|24,cc_co+1|||-dump|5694
|cc_cp|equ|24,cc_du+1|||-copy|5699
|cc_ej|equ|24,cc_cp+1|||-eject|5700
|cc_er|equ|24,cc_ej+1|||-errors|5704
|cc_ex|equ|24,cc_er+1|||-execute|5705
|cc_fa|equ|24,cc_ex+1|||-fail|5706
|cc_in|equ|24,cc_fa+1|||-include|5708
|cc_ln|equ|24,cc_in+1|||-line|5710
|cc_li|equ|24,cc_ln+1|||-list|5711
|cc_nr|equ|24,cc_li+1|||-noerrors|5723
|cc_nx|equ|24,cc_nr+1|||-noexecute|5724
|cc_nf|equ|24,cc_nx+1|||-nofail|5725
|cc_nl|equ|24,cc_nf+1|||-nolist|5726
|cc_no|equ|24,cc_nl+1|||-noopt|5727
|cc_np|equ|24,cc_no+1|||-noprint|5728
|cc_op|equ|24,cc_np+1|||-optimise|5729
|cc_pr|equ|24,cc_op+1|||-print|5730
|cc_si|equ|24,cc_pr+1|||-single|5731
|cc_sp|equ|24,cc_si+1|||-space|5732
|cc_st|equ|24,cc_sp+1|||-stitl|5733
|cc_ti|equ|24,cc_st+1|||-title|5734
|cc_tr|equ|24,cc_ti+1|||-trace|5735
|cc_nc|equ|24,cc_tr+1|||number of control cards|5736
|ccnoc|equ|24,4|||no. of chars included in match|5737
|ccofs|equ|24,7|||offset to start of title/subtitle|5738
|ccinm|equ|24,9|||max depth of include file nesting|5740
||ejc|||||5742
|cmstm|equ|24,0|||tree for statement body|5749
|cmsgo|equ|24,cmstm+1|||tree for success goto|5750
|cmfgo|equ|24,cmsgo+1|||tree for fail goto|5751
|cmcgo|equ|24,cmfgo+1|||conditional goto flag|5752
|cmpcd|equ|24,cmcgo+1|||previous cdblk pointer|5753
|cmffp|equ|24,cmpcd+1|||failure fill in flag for previous|5754
|cmffc|equ|24,cmffp+1|||failure fill in flag for current|5755
|cmsop|equ|24,cmffc+1|||success fill in offset for previous|5756
|cmsoc|equ|24,cmsop+1|||success fill in offset for current|5757
|cmlbl|equ|24,cmsoc+1|||ptr to vrblk for current label|5758
|cmtra|equ|24,cmlbl+1|||ptr to entry cdblk|5759
|cmnen|equ|24,cmtra+1|||count of stack entries for cmpil|5761
|pfpd1|equ|24,8|||pad positions ...|5766
|pfpd2|equ|24,20|||... for profile ...|5767
|pfpd3|equ|24,32|||... printout|5768
|pf_i2|equ|24,cfp_i+cfp_i|||size of table entry (2 ints)|5769
||ejc|||||5772
|rlend|equ|24,0|||end|5812
|rladj|equ|24,rlend+1|||adjustment|5813
|rlstr|equ|24,rladj+1|||start|5814
|rssi_|equ|24,rlstr+1|||size of section|5815
|rnsi_|equ|24,5|||number of structures|5816
|rldye|equ|24,0|||dynamic region end|5820
|rldya|equ|24,rldye+1|||dynamic region adjustment|5821
|rldys|equ|24,rldya+1|||dynamic region start|5822
|rlste|equ|24,rldys+1|||static region end|5823
|rlsta|equ|24,rlste+1|||static region adjustment|5824
|rlsts|equ|24,rlsta+1|||static region start|5825
|rlwke|equ|24,rlsts+1|||working section globals end|5826
|rlwka|equ|24,rlwke+1|||working section globals adjustment|5827
|rlwks|equ|24,rlwka+1|||working section globals start|5828
|rlcne|equ|24,rlwks+1|||constants section end|5829
|rlcna|equ|24,rlcne+1|||constants section adjustment|5830
|rlcns|equ|24,rlcna+1|||constants section start|5831
|rlcde|equ|24,rlcns+1|||code section end|5832
|rlcda|equ|24,rlcde+1|||code section adjustment|5833
|rlcds|equ|24,rlcda+1|||code section start|5834
|rlsi_|equ|24,rlcds+1|||number of fields in structure|5835
||ttl|27,s p i t b o l -- constant section||||5838
||sec||||start of constant section|5851
|c_aaa|dac|1,0|||first location of constant section|5855
|alfsp|dac|2,e_fsp|||free store percentage|5859
|bits0|dbc|1,0|||all zero bits|5863
|bits1|dbc|1,1|||one bit in low order position|5864
|bits2|dbc|1,2|||bit in position 2|5865
|bits3|dbc|1,4|||bit in position 3|5866
|bits4|dbc|1,8|||bit in position 4|5867
|bits5|dbc|1,16|||bit in position 5|5868
|bits6|dbc|1,32|||bit in position 6|5869
|bits7|dbc|1,64|||bit in position 7|5870
|bits8|dbc|1,128|||bit in position 8|5871
|bits9|dbc|1,256|||bit in position 9|5872
|bit10|dbc|1,512|||bit in position 10|5873
|bit11|dbc|1,1024|||bit in position 11|5874
|bit12|dbc|1,2048|||bit in position 12|5875
|bitsm|dbc|1,0|||mask for max integer (value filled in at runtime)|5877
|btfnc|dbc|2,svfnc|||bit to test for function|5881
|btknm|dbc|2,svknm|||bit to test for keyword number|5882
|btlbl|dbc|2,svlbl|||bit to test for label|5883
|btffc|dbc|2,svffc|||bit to test for fast call|5884
|btckw|dbc|2,svckw|||bit to test for constant keyword|5885
|btkwv|dbc|2,svkwv|||bits to test for keword with value|5886
|btprd|dbc|2,svprd|||bit to test for predicate function|5887
|btpre|dbc|2,svpre|||bit to test for preevaluation|5888
|btval|dbc|2,svval|||bit to test for value|5889
||ejc|||||5890
|ccnms|dtc|27,/doub/||||5898
||dtc|27,/comp/||||5901
||dtc|27,/dump/||||5903
||dtc|27,/copy/||||5905
||dtc|27,/ejec/||||5907
||dtc|27,/erro/||||5908
||dtc|27,/exec/||||5909
||dtc|27,/fail/||||5910
||dtc|27,/incl/||||5912
||dtc|27,/line/||||5915
||dtc|27,/list/||||5917
||dtc|27,/noer/||||5918
||dtc|27,/noex/||||5919
||dtc|27,/nofa/||||5920
||dtc|27,/noli/||||5921
||dtc|27,/noop/||||5922
||dtc|27,/nopr/||||5923
||dtc|27,/opti/||||5924
||dtc|27,/prin/||||5925
||dtc|27,/sing/||||5926
||dtc|27,/spac/||||5927
||dtc|27,/stit/||||5928
||dtc|27,/titl/||||5929
||dtc|27,/trac/||||5930
|dmhdk|dac|6,b_scl|||dump of keyword values|5934
||dac|1,22||||5935
||dtc|27,/dump of keyword values/||||5936
|dmhdv|dac|6,b_scl|||dump of natural variables|5938
||dac|1,25||||5939
||dtc|27,/dump of natural variables/||||5940
||ejc|||||5941
|encm1|dac|6,b_scl||||5945
||dac|1,19||||5947
||dtc|27,/memory used (bytes)/||||5948
|encm2|dac|6,b_scl||||5950
||dac|1,19||||5951
||dtc|27,/memory left (bytes)/||||5952
|encm3|dac|6,b_scl||||5962
||dac|1,11||||5963
||dtc|27,/comp errors/||||5964
|encm4|dac|6,b_scl||||5966
||dac|1,20||||5971
||dtc|27,/comp time (microsec)/||||5972
|encm5|dac|6,b_scl|||execution suppressed|5975
||dac|1,20||||5976
||dtc|27,/execution suppressed/||||5977
|endab|dac|6,b_scl||||5981
||dac|1,12||||5982
||dtc|27,/abnormal end/||||5983
||ejc|||||5984
|endmo|dac|6,b_scl||||5988
|endml|dac|1,15||||5989
||dtc|27,/memory overflow/||||5990
|endms|dac|6,b_scl||||5994
||dac|1,10||||5995
||dtc|27,/normal end/||||5996
|endso|dac|6,b_scl|||stack overflow in garbage collector|6000
||dac|1,36||||6001
||dtc|27,/stack overflow in garbage collection/||||6002
|endtu|dac|6,b_scl||||6006
||dac|1,15||||6007
||dtc|27,/error - time up/||||6008
||ejc|||||6009
|ermms|dac|6,b_scl|||error|6013
||dac|1,5||||6014
||dtc|27,/error/||||6015
|ermns|dac|6,b_scl|||string / -- /|6017
||dac|1,4||||6018
||dtc|27,/ -- /||||6019
|lstms|dac|6,b_scl|||page|6023
||dac|1,5||||6024
||dtc|27,/page /||||6025
|headr|dac|6,b_scl||||6029
||dac|1,25||||6030
||dtc|27,/macro spitbol version 4.0/||||6031
|headv|dac|6,b_scl|||for exit() version no. check|6033
||dac|1,5||||6034
||dtc|27,/15.01/||||6035
|gbsdp|dac|2,e_sed|||sediment percentage|6039
|int_r|dac|6,b_icl||||6045
|intv0|dic|16,+0|||0|6046
|inton|dac|6,b_icl||||6047
|intv1|dic|16,+1|||1|6048
|inttw|dac|6,b_icl||||6049
|intv2|dic|16,+2|||2|6050
|intvt|dic|16,+10|||10|6051
|intvh|dic|16,+100|||100|6052
|intth|dic|16,+1000|||1000|6053
|intab|dac|4,int_r|||pointer to 0|6057
||dac|4,inton|||pointer to 1|6058
||dac|4,inttw|||pointer to 2|6059
||ejc|||||6060
|ndabb|dac|6,p_abb|||arbno|6066
|ndabd|dac|6,p_abd|||arbno|6067
|ndarc|dac|6,p_arc|||arb|6068
|ndexb|dac|6,p_exb|||expression|6069
|ndfnb|dac|6,p_fnb|||fence()|6070
|ndfnd|dac|6,p_fnd|||fence()|6071
|ndexc|dac|6,p_exc|||expression|6072
|ndimb|dac|6,p_imb|||immediate assignment|6073
|ndimd|dac|6,p_imd|||immediate assignment|6074
|ndnth|dac|6,p_nth|||pattern end (null pattern)|6075
|ndpab|dac|6,p_pab|||pattern assignment|6076
|ndpad|dac|6,p_pad|||pattern assignment|6077
|nduna|dac|6,p_una|||anchor point movement|6078
|ndabo|dac|6,p_abo|||abort|6086
||dac|4,ndnth||||6087
|ndarb|dac|6,p_arb|||arb|6088
||dac|4,ndnth||||6089
|ndbal|dac|6,p_bal|||bal|6090
||dac|4,ndnth||||6091
|ndfal|dac|6,p_fal|||fail|6092
||dac|4,ndnth||||6093
|ndfen|dac|6,p_fen|||fence|6094
||dac|4,ndnth||||6095
|ndrem|dac|6,p_rem|||rem|6096
||dac|4,ndnth||||6097
|ndsuc|dac|6,p_suc|||succeed|6098
||dac|4,ndnth||||6099
|nulls|dac|6,b_scl|||null string value|6107
||dac|1,0|||sclen = 0|6108
|nullw|dtc|27,/          /||||6109
|lcase|dac|6,b_scl||||6115
||dac|1,26||||6116
||dtc|27,/abcdefghijklmnopqrstuvwxyz/||||6117
|ucase|dac|6,b_scl||||6119
||dac|1,26||||6120
||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/||||6121
||ejc|||||6123
|opdvc|dac|6,o_cnc|||concatenation|6127
||dac|2,c_cnc||||6128
||dac|2,llcnc||||6129
||dac|2,rrcnc||||6130
|opdvp|dac|6,o_cnc|||concatenation - not pattern match|6136
||dac|2,c_cnp||||6137
||dac|2,llcnc||||6138
||dac|2,rrcnc||||6139
|opdvs|dac|6,o_ass|||assignment|6144
||dac|2,c_ass||||6145
||dac|2,llass||||6146
||dac|2,rrass||||6147
||dac|1,6|||unary equal|6149
||dac|2,c_uuo||||6150
||dac|2,lluno||||6151
||dac|6,o_pmv|||pattern match|6153
||dac|2,c_pmt||||6154
||dac|2,llpmt||||6155
||dac|2,rrpmt||||6156
||dac|6,o_int|||interrogation|6158
||dac|2,c_uvl||||6159
||dac|2,lluno||||6160
||dac|1,1|||binary ampersand|6162
||dac|2,c_ubo||||6163
||dac|2,llamp||||6164
||dac|2,rramp||||6165
||dac|6,o_kwv|||keyword reference|6167
||dac|2,c_key||||6168
||dac|2,lluno||||6169
||dac|6,o_alt|||alternation|6171
||dac|2,c_alt||||6172
||dac|2,llalt||||6173
||dac|2,rralt||||6174
||ejc|||||6175
||dac|1,5|||unary vertical bar|6179
||dac|2,c_uuo||||6180
||dac|2,lluno||||6181
||dac|1,0|||binary at|6183
||dac|2,c_ubo||||6184
||dac|2,llats||||6185
||dac|2,rrats||||6186
||dac|6,o_cas|||cursor assignment|6188
||dac|2,c_unm||||6189
||dac|2,lluno||||6190
||dac|1,2|||binary number sign|6192
||dac|2,c_ubo||||6193
||dac|2,llnum||||6194
||dac|2,rrnum||||6195
||dac|1,7|||unary number sign|6197
||dac|2,c_uuo||||6198
||dac|2,lluno||||6199
||dac|6,o_dvd|||division|6201
||dac|2,c_bvl||||6202
||dac|2,lldvd||||6203
||dac|2,rrdvd||||6204
||dac|1,9|||unary slash|6206
||dac|2,c_uuo||||6207
||dac|2,lluno||||6208
||dac|6,o_mlt|||multiplication|6210
||dac|2,c_bvl||||6211
||dac|2,llmlt||||6212
||dac|2,rrmlt||||6213
||ejc|||||6214
||dac|1,0|||deferred expression|6218
||dac|2,c_def||||6219
||dac|2,lluno||||6220
||dac|1,3|||binary percent|6222
||dac|2,c_ubo||||6223
||dac|2,llpct||||6224
||dac|2,rrpct||||6225
||dac|1,8|||unary percent|6227
||dac|2,c_uuo||||6228
||dac|2,lluno||||6229
||dac|6,o_exp|||exponentiation|6231
||dac|2,c_bvl||||6232
||dac|2,llexp||||6233
||dac|2,rrexp||||6234
||dac|1,10|||unary exclamation|6236
||dac|2,c_uuo||||6237
||dac|2,lluno||||6238
||dac|6,o_ima|||immediate assignment|6240
||dac|2,c_bvn||||6241
||dac|2,lldld||||6242
||dac|2,rrdld||||6243
||dac|6,o_inv|||indirection|6245
||dac|2,c_ind||||6246
||dac|2,lluno||||6247
||dac|1,4|||binary not|6249
||dac|2,c_ubo||||6250
||dac|2,llnot||||6251
||dac|2,rrnot||||6252
||dac|1,0|||negation|6254
||dac|2,c_neg||||6255
||dac|2,lluno||||6256
||ejc|||||6257
||dac|6,o_sub|||subtraction|6261
||dac|2,c_bvl||||6262
||dac|2,llplm||||6263
||dac|2,rrplm||||6264
||dac|6,o_com|||complementation|6266
||dac|2,c_uvl||||6267
||dac|2,lluno||||6268
||dac|6,o_add|||addition|6270
||dac|2,c_bvl||||6271
||dac|2,llplm||||6272
||dac|2,rrplm||||6273
||dac|6,o_aff|||affirmation|6275
||dac|2,c_uvl||||6276
||dac|2,lluno||||6277
||dac|6,o_pas|||pattern assignment|6279
||dac|2,c_bvn||||6280
||dac|2,lldld||||6281
||dac|2,rrdld||||6282
||dac|6,o_nam|||name reference|6284
||dac|2,c_unm||||6285
||dac|2,lluno||||6286
|opdvd|dac|6,o_god|||direct goto|6290
||dac|2,c_uvl||||6291
||dac|2,lluno||||6292
|opdvn|dac|6,o_goc|||complex normal goto|6294
||dac|2,c_unm||||6295
||dac|2,lluno||||6296
||ejc|||||6297
|oamn_|dac|6,o_amn|||array ref (multi-subs by value)|6301
|oamv_|dac|6,o_amv|||array ref (multi-subs by value)|6302
|oaon_|dac|6,o_aon|||array ref (one sub by name)|6303
|oaov_|dac|6,o_aov|||array ref (one sub by value)|6304
|ocer_|dac|6,o_cer|||compilation error|6305
|ofex_|dac|6,o_fex|||failure in expression evaluation|6306
|ofif_|dac|6,o_fif|||failure during goto evaluation|6307
|ofnc_|dac|6,o_fnc|||function call (more than one arg)|6308
|ofne_|dac|6,o_fne|||function name error|6309
|ofns_|dac|6,o_fns|||function call (single argument)|6310
|ogof_|dac|6,o_gof|||set goto failure trap|6311
|oinn_|dac|6,o_inn|||indirection by name|6312
|okwn_|dac|6,o_kwn|||keyword reference by name|6313
|olex_|dac|6,o_lex|||load expression by name|6314
|olpt_|dac|6,o_lpt|||load pattern|6315
|olvn_|dac|6,o_lvn|||load variable name|6316
|onta_|dac|6,o_nta|||negation, first entry|6317
|ontb_|dac|6,o_ntb|||negation, second entry|6318
|ontc_|dac|6,o_ntc|||negation, third entry|6319
|opmn_|dac|6,o_pmn|||pattern match by name|6320
|opms_|dac|6,o_pms|||pattern match (statement)|6321
|opop_|dac|6,o_pop|||pop top stack item|6322
|ornm_|dac|6,o_rnm|||return name from expression|6323
|orpl_|dac|6,o_rpl|||pattern replacement|6324
|orvl_|dac|6,o_rvl|||return value from expression|6325
|osla_|dac|6,o_sla|||selection, first entry|6326
|oslb_|dac|6,o_slb|||selection, second entry|6327
|oslc_|dac|6,o_slc|||selection, third entry|6328
|osld_|dac|6,o_sld|||selection, fourth entry|6329
|ostp_|dac|6,o_stp|||stop execution|6330
|ounf_|dac|6,o_unf|||unexpected failure|6331
||ejc|||||6332
|opsnb|dac|2,ch_at|||at|6336
||dac|2,ch_am|||ampersand|6337
||dac|2,ch_nm|||number|6338
||dac|2,ch_pc|||percent|6339
||dac|2,ch_nt|||not|6340
|opnsu|dac|2,ch_br|||vertical bar|6344
||dac|2,ch_eq|||equal|6345
||dac|2,ch_nm|||number|6346
||dac|2,ch_pc|||percent|6347
||dac|2,ch_sl|||slash|6348
||dac|2,ch_ex|||exclamation|6349
|pfi2a|dac|2,pf_i2||||6355
|pfms1|dac|6,b_scl||||6359
||dac|1,15||||6360
||dtc|27,/program profile/||||6361
|pfms2|dac|6,b_scl||||6362
||dac|1,42||||6363
||dtc|27,/stmt    number of     -- execution time --/||||6364
|pfms3|dac|6,b_scl||||6365
||dac|1,47||||6366
||dtc|27,/number  executions  total(msec) per excn(mcsec)/||||6367
|reav0|drc|17,+0.0|||0.0|6377
|reap1|drc|17,+0.1|||0.1|6380
|reap5|drc|17,+0.5|||0.5|6381
|reav1|drc|17,+1.0|||10**0|6383
|reavt|drc|17,+1.0e+1|||10**1|6384
||drc|17,+1.0e+2|||10**2|6385
||drc|17,+1.0e+3|||10**3|6386
||drc|17,+1.0e+4|||10**4|6387
||drc|17,+1.0e+5|||10**5|6388
||drc|17,+1.0e+6|||10**6|6389
||drc|17,+1.0e+7|||10**7|6390
||drc|17,+1.0e+8|||10**8|6391
||drc|17,+1.0e+9|||10**9|6392
|reatt|drc|17,+1.0e+10|||10**10|6393
||ejc|||||6395
|scarr|dac|6,b_scl|||array|6399
||dac|1,5||||6400
||dtc|27,/array/||||6401
|sccod|dac|6,b_scl|||code|6410
||dac|1,4||||6411
||dtc|27,/code/||||6412
|scexp|dac|6,b_scl|||expression|6414
||dac|1,10||||6415
||dtc|27,/expression/||||6416
|scext|dac|6,b_scl|||external|6418
||dac|1,8||||6419
||dtc|27,/external/||||6420
|scint|dac|6,b_scl|||integer|6422
||dac|1,7||||6423
||dtc|27,/integer/||||6424
|scnam|dac|6,b_scl|||name|6426
||dac|1,4||||6427
||dtc|27,/name/||||6428
|scnum|dac|6,b_scl|||numeric|6430
||dac|1,7||||6431
||dtc|27,/numeric/||||6432
|scpat|dac|6,b_scl|||pattern|6434
||dac|1,7||||6435
||dtc|27,/pattern/||||6436
|screa|dac|6,b_scl|||real|6440
||dac|1,4||||6441
||dtc|27,/real/||||6442
|scstr|dac|6,b_scl|||string|6445
||dac|1,6||||6446
||dtc|27,/string/||||6447
|sctab|dac|6,b_scl|||table|6449
||dac|1,5||||6450
||dtc|27,/table/||||6451
|scfil|dac|6,b_scl|||file (for extended load arguments)|6453
||dac|1,4||||6454
||dtc|27,/file/||||6455
||ejc|||||6457
|scfrt|dac|6,b_scl|||freturn|6461
||dac|1,7||||6462
||dtc|27,/freturn/||||6463
|scnrt|dac|6,b_scl|||nreturn|6465
||dac|1,7||||6466
||dtc|27,/nreturn/||||6467
|scrtn|dac|6,b_scl|||return|6469
||dac|1,6||||6470
||dtc|27,/return/||||6471
|scnmt|dac|4,scarr|||arblk     array|6481
||dac|4,sccod|||cdblk     code|6482
||dac|4,scexp|||exblk     expression|6483
||dac|4,scint|||icblk     integer|6484
||dac|4,scnam|||nmblk     name|6485
||dac|4,scpat|||p0blk     pattern|6486
||dac|4,scpat|||p1blk     pattern|6487
||dac|4,scpat|||p2blk     pattern|6488
||dac|4,screa|||rcblk     real|6493
||dac|4,scstr|||scblk     string|6495
||dac|4,scexp|||seblk     expression|6496
||dac|4,sctab|||tbblk     table|6497
||dac|4,scarr|||vcblk     array|6498
||dac|4,scext|||xnblk     external|6499
||dac|4,scext|||xrblk     external|6500
||dac|4,nulls|||bfblk     no buffer in this version|6502
|scre0|dac|6,b_scl||||6511
||dac|1,2||||6512
||dtc|27,/0./||||6513
||ejc|||||6515
|stlim|dic|16,+2147483647|||default statement limit|6523
|stndf|dac|6,o_fun|||ptr to undefined function err call|6531
||dac|1,0|||dummy fargs count for call circuit|6532
|stndl|dac|6,l_und|||code ptr points to undefined lbl|6536
|stndo|dac|6,o_oun|||ptr to undefined operator err call|6540
||dac|1,0|||dummy fargs count for call circuit|6541
|stnvr|dac|6,b_vrl|||vrget|6547
||dac|6,b_vrs|||vrsto|6548
||dac|4,nulls|||vrval|6549
||dac|6,b_vrg|||vrtra|6550
||dac|4,stndl|||vrlbl|6551
||dac|4,stndf|||vrfnc|6552
||dac|1,0|||vrnxt|6553
||ejc|||||6554
|stpm1|dac|6,b_scl|||in statement|6558
||dac|1,12||||6559
||dtc|27,/in statement/||||6560
|stpm2|dac|6,b_scl||||6562
||dac|1,14||||6563
||dtc|27,/stmts executed/||||6564
|stpm3|dac|6,b_scl||||6566
||dac|1,20||||6567
||dtc|27,/execution time msec /||||6568
|stpm4|dac|6,b_scl|||in line|6571
||dac|1,7||||6572
||dtc|27,/in line/||||6573
|stpm5|dac|6,b_scl||||6576
||dac|1,13||||6577
||dtc|27,/regenerations/||||6578
|stpm6|dac|6,b_scl|||in file|6581
||dac|1,7||||6582
||dtc|27,/in file/||||6583
|stpm7|dac|6,b_scl||||6586
||dac|1,15||||6587
||dtc|27,_stmt / microsec_||||6588
|stpm8|dac|6,b_scl||||6590
||dac|1,15||||6591
||dtc|27,_stmt / millisec_||||6592
|stpm9|dac|6,b_scl||||6594
||dac|1,13||||6595
||dtc|27,_stmt / second_||||6596
|strtu|dtc|27,/tu/||||6600
|svctb|dac|4,scstr|||string|6606
||dac|4,scint|||integer|6607
||dac|4,scnam|||name|6608
||dac|4,scpat|||pattern|6609
||dac|4,scarr|||array|6610
||dac|4,sctab|||table|6611
||dac|4,scexp|||expression|6612
||dac|4,sccod|||code|6613
||dac|4,scnum|||numeric|6614
||dac|4,screa|||real|6617
||dac|1,0|||zero marks end of list|6623
||ejc|||||6624
|tmasb|dac|6,b_scl|||asterisks for trace statement no|6629
||dac|1,13||||6630
||dtc|27,/************ /||||6631
|tmbeb|dac|6,b_scl|||blank-equal-blank|6634
||dac|1,3||||6635
||dtc|27,/ = /||||6636
|trbev|dac|6,b_trt|||dummy trblk|6640
|trbkv|dac|6,b_trt|||dummy trblk|6644
|trxdr|dac|6,o_txr|||block points to return routine|6648
|trxdc|dac|4,trxdr|||pointer to block|6649
||ejc|||||6650
|v_eqf|dbc|2,svfpr|||eq|6658
||dac|1,2||||6659
||dtc|27,/eq/||||6660
||dac|6,s_eqf||||6661
||dac|1,2||||6662
|v_gef|dbc|2,svfpr|||ge|6664
||dac|1,2||||6665
||dtc|27,/ge/||||6666
||dac|6,s_gef||||6667
||dac|1,2||||6668
|v_gtf|dbc|2,svfpr|||gt|6670
||dac|1,2||||6671
||dtc|27,/gt/||||6672
||dac|6,s_gtf||||6673
||dac|1,2||||6674
|v_lef|dbc|2,svfpr|||le|6676
||dac|1,2||||6677
||dtc|27,/le/||||6678
||dac|6,s_lef||||6679
||dac|1,2||||6680
|v_lnf|dbc|2,svfnp|||ln|6683
||dac|1,2||||6684
||dtc|27,/ln/||||6685
||dac|6,s_lnf||||6686
||dac|1,1||||6687
|v_ltf|dbc|2,svfpr|||lt|6690
||dac|1,2||||6691
||dtc|27,/lt/||||6692
||dac|6,s_ltf||||6693
||dac|1,2||||6694
|v_nef|dbc|2,svfpr|||ne|6696
||dac|1,2||||6697
||dtc|27,/ne/||||6698
||dac|6,s_nef||||6699
||dac|1,2||||6700
|v_any|dbc|2,svfnp|||any|6726
||dac|1,3||||6727
||dtc|27,/any/||||6728
||dac|6,s_any||||6729
||dac|1,1||||6730
|v_arb|dbc|2,svkvc|||arb|6732
||dac|1,3||||6733
||dtc|27,/arb/||||6734
||dac|2,k_arb||||6735
||dac|4,ndarb||||6736
||ejc|||||6737
|v_arg|dbc|2,svfnn|||arg|6741
||dac|1,3||||6742
||dtc|27,/arg/||||6743
||dac|6,s_arg||||6744
||dac|1,2||||6745
|v_bal|dbc|2,svkvc|||bal|6747
||dac|1,3||||6748
||dtc|27,/bal/||||6749
||dac|2,k_bal||||6750
||dac|4,ndbal||||6751
|v_cos|dbc|2,svfnp|||cos|6754
||dac|1,3||||6755
||dtc|27,/cos/||||6756
||dac|6,s_cos||||6757
||dac|1,1||||6758
|v_end|dbc|2,svlbl|||end|6761
||dac|1,3||||6762
||dtc|27,/end/||||6763
||dac|6,l_end||||6764
|v_exp|dbc|2,svfnp|||exp|6767
||dac|1,3||||6768
||dtc|27,/exp/||||6769
||dac|6,s_exp||||6770
||dac|1,1||||6771
|v_len|dbc|2,svfnp|||len|6774
||dac|1,3||||6775
||dtc|27,/len/||||6776
||dac|6,s_len||||6777
||dac|1,1||||6778
|v_leq|dbc|2,svfpr|||leq|6780
||dac|1,3||||6781
||dtc|27,/leq/||||6782
||dac|6,s_leq||||6783
||dac|1,2||||6784
|v_lge|dbc|2,svfpr|||lge|6786
||dac|1,3||||6787
||dtc|27,/lge/||||6788
||dac|6,s_lge||||6789
||dac|1,2||||6790
|v_lgt|dbc|2,svfpr|||lgt|6792
||dac|1,3||||6793
||dtc|27,/lgt/||||6794
||dac|6,s_lgt||||6795
||dac|1,2||||6796
|v_lle|dbc|2,svfpr|||lle|6798
||dac|1,3||||6799
||dtc|27,/lle/||||6800
||dac|6,s_lle||||6801
||dac|1,2||||6802
||ejc|||||6803
|v_llt|dbc|2,svfpr|||llt|6807
||dac|1,3||||6808
||dtc|27,/llt/||||6809
||dac|6,s_llt||||6810
||dac|1,2||||6811
|v_lne|dbc|2,svfpr|||lne|6813
||dac|1,3||||6814
||dtc|27,/lne/||||6815
||dac|6,s_lne||||6816
||dac|1,2||||6817
|v_pos|dbc|2,svfnp|||pos|6819
||dac|1,3||||6820
||dtc|27,/pos/||||6821
||dac|6,s_pos||||6822
||dac|1,1||||6823
|v_rem|dbc|2,svkvc|||rem|6825
||dac|1,3||||6826
||dtc|27,/rem/||||6827
||dac|2,k_rem||||6828
||dac|4,ndrem||||6829
|v_sin|dbc|2,svfnp|||sin|6840
||dac|1,3||||6841
||dtc|27,/sin/||||6842
||dac|6,s_sin||||6843
||dac|1,1||||6844
|v_tab|dbc|2,svfnp|||tab|6847
||dac|1,3||||6848
||dtc|27,/tab/||||6849
||dac|6,s_tab||||6850
||dac|1,1||||6851
|v_tan|dbc|2,svfnp|||tan|6854
||dac|1,3||||6855
||dtc|27,/tan/||||6856
||dac|6,s_tan||||6857
||dac|1,1||||6858
|v_atn|dbc|2,svfnp|||atan|6870
||dac|1,4||||6871
||dtc|27,/atan/||||6872
||dac|6,s_atn||||6873
||dac|1,1||||6874
|v_chr|dbc|2,svfnp|||char|6884
||dac|1,4||||6885
||dtc|27,/char/||||6886
||dac|6,s_chr||||6887
||dac|1,1||||6888
|v_chp|dbc|2,svfnp|||chop|6892
||dac|1,4||||6893
||dtc|27,/chop/||||6894
||dac|6,s_chp||||6895
||dac|1,1||||6896
|v_cod|dbc|2,svfnk|||code|6898
||dac|1,4||||6899
||dtc|27,/code/||||6900
||dac|2,k_cod||||6901
||dac|6,s_cod||||6902
||dac|1,1||||6903
|v_cop|dbc|2,svfnn|||copy|6905
||dac|1,4||||6906
||dtc|27,/copy/||||6907
||dac|6,s_cop||||6908
||dac|1,1||||6909
||ejc|||||6910
|v_dat|dbc|2,svfnn|||data|6914
||dac|1,4||||6915
||dtc|27,/data/||||6916
||dac|6,s_dat||||6917
||dac|1,1||||6918
|v_dte|dbc|2,svfnn|||date|6920
||dac|1,4||||6921
||dtc|27,/date/||||6922
||dac|6,s_dte||||6923
||dac|1,1||||6924
|v_dmp|dbc|2,svfnk|||dump|6926
||dac|1,4||||6927
||dtc|27,/dump/||||6928
||dac|2,k_dmp||||6929
||dac|6,s_dmp||||6930
||dac|1,1||||6931
|v_dup|dbc|2,svfnn|||dupl|6933
||dac|1,4||||6934
||dtc|27,/dupl/||||6935
||dac|6,s_dup||||6936
||dac|1,2||||6937
|v_evl|dbc|2,svfnn|||eval|6939
||dac|1,4||||6940
||dtc|27,/eval/||||6941
||dac|6,s_evl||||6942
||dac|1,1||||6943
|v_ext|dbc|2,svfnn|||exit|6947
||dac|1,4||||6948
||dtc|27,/exit/||||6949
||dac|6,s_ext||||6950
||dac|1,2||||6951
|v_fal|dbc|2,svkvc|||fail|6954
||dac|1,4||||6955
||dtc|27,/fail/||||6956
||dac|2,k_fal||||6957
||dac|4,ndfal||||6958
|v_fil|dbc|2,svknm|||file|6961
||dac|1,4||||6962
||dtc|27,/file/||||6963
||dac|2,k_fil||||6964
|v_hst|dbc|2,svfnn|||host|6967
||dac|1,4||||6968
||dtc|27,/host/||||6969
||dac|6,s_hst||||6970
||dac|1,5||||6971
||ejc|||||6972
|v_itm|dbc|2,svfnf|||item|6976
||dac|1,4||||6977
||dtc|27,/item/||||6978
||dac|6,s_itm||||6979
||dac|1,999||||6980
|v_lin|dbc|2,svknm|||line|6983
||dac|1,4||||6984
||dtc|27,/line/||||6985
||dac|2,k_lin||||6986
|v_lod|dbc|2,svfnn|||load|6991
||dac|1,4||||6992
||dtc|27,/load/||||6993
||dac|6,s_lod||||6994
||dac|1,2||||6995
|v_lpd|dbc|2,svfnp|||lpad|6998
||dac|1,4||||6999
||dtc|27,/lpad/||||7000
||dac|6,s_lpd||||7001
||dac|1,3||||7002
|v_rpd|dbc|2,svfnp|||rpad|7004
||dac|1,4||||7005
||dtc|27,/rpad/||||7006
||dac|6,s_rpd||||7007
||dac|1,3||||7008
|v_rps|dbc|2,svfnp|||rpos|7010
||dac|1,4||||7011
||dtc|27,/rpos/||||7012
||dac|6,s_rps||||7013
||dac|1,1||||7014
|v_rtb|dbc|2,svfnp|||rtab|7016
||dac|1,4||||7017
||dtc|27,/rtab/||||7018
||dac|6,s_rtb||||7019
||dac|1,1||||7020
|v_si_|dbc|2,svfnp|||size|7022
||dac|1,4||||7023
||dtc|27,/size/||||7024
||dac|6,s_si_||||7025
||dac|1,1||||7026
|v_srt|dbc|2,svfnn|||sort|7031
||dac|1,4||||7032
||dtc|27,/sort/||||7033
||dac|6,s_srt||||7034
||dac|1,2||||7035
|v_spn|dbc|2,svfnp|||span|7037
||dac|1,4||||7038
||dtc|27,/span/||||7039
||dac|6,s_spn||||7040
||dac|1,1||||7041
||ejc|||||7042
|v_sqr|dbc|2,svfnp|||sqrt|7048
||dac|1,4||||7049
||dtc|27,/sqrt/||||7050
||dac|6,s_sqr||||7051
||dac|1,1||||7052
|v_stn|dbc|2,svknm|||stno|7054
||dac|1,4||||7055
||dtc|27,/stno/||||7056
||dac|2,k_stn||||7057
|v_tim|dbc|2,svfnn|||time|7059
||dac|1,4||||7060
||dtc|27,/time/||||7061
||dac|6,s_tim||||7062
||dac|1,0||||7063
|v_trm|dbc|2,svfnk|||trim|7065
||dac|1,4||||7066
||dtc|27,/trim/||||7067
||dac|2,k_trm||||7068
||dac|6,s_trm||||7069
||dac|1,1||||7070
|v_abe|dbc|2,svknm|||abend|7072
||dac|1,5||||7073
||dtc|27,/abend/||||7074
||dac|2,k_abe||||7075
|v_abo|dbc|2,svkvl|||abort|7077
||dac|1,5||||7078
||dtc|27,/abort/||||7079
||dac|2,k_abo||||7080
||dac|6,l_abo||||7081
||dac|4,ndabo||||7082
|v_app|dbc|2,svfnf|||apply|7084
||dac|1,5||||7085
||dtc|27,/apply/||||7086
||dac|6,s_app||||7087
||dac|1,999||||7088
|v_abn|dbc|2,svfnp|||arbno|7090
||dac|1,5||||7091
||dtc|27,/arbno/||||7092
||dac|6,s_abn||||7093
||dac|1,1||||7094
|v_arr|dbc|2,svfnn|||array|7096
||dac|1,5||||7097
||dtc|27,/array/||||7098
||dac|6,s_arr||||7099
||dac|1,2||||7100
||ejc|||||7101
|v_brk|dbc|2,svfnp|||break|7105
||dac|1,5||||7106
||dtc|27,/break/||||7107
||dac|6,s_brk||||7108
||dac|1,1||||7109
|v_clr|dbc|2,svfnn|||clear|7111
||dac|1,5||||7112
||dtc|27,/clear/||||7113
||dac|6,s_clr||||7114
||dac|1,1||||7115
|v_ejc|dbc|2,svfnn|||eject|7125
||dac|1,5||||7126
||dtc|27,/eject/||||7127
||dac|6,s_ejc||||7128
||dac|1,1||||7129
|v_fen|dbc|2,svfpk|||fence|7131
||dac|1,5||||7132
||dtc|27,/fence/||||7133
||dac|2,k_fen||||7134
||dac|6,s_fnc||||7135
||dac|1,1||||7136
||dac|4,ndfen||||7137
|v_fld|dbc|2,svfnn|||field|7139
||dac|1,5||||7140
||dtc|27,/field/||||7141
||dac|6,s_fld||||7142
||dac|1,2||||7143
|v_idn|dbc|2,svfpr|||ident|7145
||dac|1,5||||7146
||dtc|27,/ident/||||7147
||dac|6,s_idn||||7148
||dac|1,2||||7149
|v_inp|dbc|2,svfnk|||input|7151
||dac|1,5||||7152
||dtc|27,/input/||||7153
||dac|2,k_inp||||7154
||dac|6,s_inp||||7155
||dac|1,3||||7156
|v_lcs|dbc|2,svkwc|||lcase|7159
||dac|1,5||||7160
||dtc|27,/lcase/||||7161
||dac|2,k_lcs||||7162
|v_loc|dbc|2,svfnn|||local|7165
||dac|1,5||||7166
||dtc|27,/local/||||7167
||dac|6,s_loc||||7168
||dac|1,2||||7169
||ejc|||||7170
|v_ops|dbc|2,svfnn|||opsyn|7174
||dac|1,5||||7175
||dtc|27,/opsyn/||||7176
||dac|6,s_ops||||7177
||dac|1,3||||7178
|v_rmd|dbc|2,svfnp|||remdr|7180
||dac|1,5||||7181
||dtc|27,/remdr/||||7182
||dac|6,s_rmd||||7183
||dac|1,2||||7184
|v_rsr|dbc|2,svfnn|||rsort|7188
||dac|1,5||||7189
||dtc|27,/rsort/||||7190
||dac|6,s_rsr||||7191
||dac|1,2||||7192
|v_tbl|dbc|2,svfnn|||table|7195
||dac|1,5||||7196
||dtc|27,/table/||||7197
||dac|6,s_tbl||||7198
||dac|1,3||||7199
|v_tra|dbc|2,svfnk|||trace|7201
||dac|1,5||||7202
||dtc|27,/trace/||||7203
||dac|2,k_tra||||7204
||dac|6,s_tra||||7205
||dac|1,4||||7206
|v_ucs|dbc|2,svkwc|||ucase|7209
||dac|1,5||||7210
||dtc|27,/ucase/||||7211
||dac|2,k_ucs||||7212
|v_anc|dbc|2,svknm|||anchor|7215
||dac|1,6||||7216
||dtc|27,/anchor/||||7217
||dac|2,k_anc||||7218
|v_bkx|dbc|2,svfnp|||breakx|7229
||dac|1,6||||7230
||dtc|27,/breakx/||||7231
||dac|6,s_bkx||||7232
||dac|1,1||||7233
|v_def|dbc|2,svfnn|||define|7244
||dac|1,6||||7245
||dtc|27,/define/||||7246
||dac|6,s_def||||7247
||dac|1,2||||7248
|v_det|dbc|2,svfnn|||detach|7250
||dac|1,6||||7251
||dtc|27,/detach/||||7252
||dac|6,s_det||||7253
||dac|1,1||||7254
||ejc|||||7255
|v_dif|dbc|2,svfpr|||differ|7259
||dac|1,6||||7260
||dtc|27,/differ/||||7261
||dac|6,s_dif||||7262
||dac|1,2||||7263
|v_ftr|dbc|2,svknm|||ftrace|7265
||dac|1,6||||7266
||dtc|27,/ftrace/||||7267
||dac|2,k_ftr||||7268
|v_lst|dbc|2,svknm|||lastno|7279
||dac|1,6||||7280
||dtc|27,/lastno/||||7281
||dac|2,k_lst||||7282
|v_nay|dbc|2,svfnp|||notany|7284
||dac|1,6||||7285
||dtc|27,/notany/||||7286
||dac|6,s_nay||||7287
||dac|1,1||||7288
|v_oup|dbc|2,svfnk|||output|7290
||dac|1,6||||7291
||dtc|27,/output/||||7292
||dac|2,k_oup||||7293
||dac|6,s_oup||||7294
||dac|1,3||||7295
|v_ret|dbc|2,svlbl|||return|7297
||dac|1,6||||7298
||dtc|27,/return/||||7299
||dac|6,l_rtn||||7300
|v_rew|dbc|2,svfnn|||rewind|7302
||dac|1,6||||7303
||dtc|27,/rewind/||||7304
||dac|6,s_rew||||7305
||dac|1,1||||7306
|v_stt|dbc|2,svfnn|||stoptr|7308
||dac|1,6||||7309
||dtc|27,/stoptr/||||7310
||dac|6,s_stt||||7311
||dac|1,2||||7312
||ejc|||||7313
|v_sub|dbc|2,svfnn|||substr|7317
||dac|1,6||||7318
||dtc|27,/substr/||||7319
||dac|6,s_sub||||7320
||dac|1,3||||7321
|v_unl|dbc|2,svfnn|||unload|7323
||dac|1,6||||7324
||dtc|27,/unload/||||7325
||dac|6,s_unl||||7326
||dac|1,1||||7327
|v_col|dbc|2,svfnn|||collect|7329
||dac|1,7||||7330
||dtc|27,/collect/||||7331
||dac|6,s_col||||7332
||dac|1,1||||7333
|v_com|dbc|2,svknm|||compare|7336
||dac|1,7||||7337
||dtc|27,/compare/||||7338
||dac|2,k_com||||7339
|v_cnv|dbc|2,svfnn|||convert|7342
||dac|1,7||||7343
||dtc|27,/convert/||||7344
||dac|6,s_cnv||||7345
||dac|1,2||||7346
|v_enf|dbc|2,svfnn|||endfile|7348
||dac|1,7||||7349
||dtc|27,/endfile/||||7350
||dac|6,s_enf||||7351
||dac|1,1||||7352
|v_etx|dbc|2,svknm|||errtext|7354
||dac|1,7||||7355
||dtc|27,/errtext/||||7356
||dac|2,k_etx||||7357
|v_ert|dbc|2,svknm|||errtype|7359
||dac|1,7||||7360
||dtc|27,/errtype/||||7361
||dac|2,k_ert||||7362
|v_frt|dbc|2,svlbl|||freturn|7364
||dac|1,7||||7365
||dtc|27,/freturn/||||7366
||dac|6,l_frt||||7367
|v_int|dbc|2,svfpr|||integer|7369
||dac|1,7||||7370
||dtc|27,/integer/||||7371
||dac|6,s_int||||7372
||dac|1,1||||7373
|v_nrt|dbc|2,svlbl|||nreturn|7375
||dac|1,7||||7376
||dtc|27,/nreturn/||||7377
||dac|6,l_nrt||||7378
||ejc|||||7379
|v_pfl|dbc|2,svknm|||profile|7386
||dac|1,7||||7387
||dtc|27,/profile/||||7388
||dac|2,k_pfl||||7389
|v_rpl|dbc|2,svfnp|||replace|7392
||dac|1,7||||7393
||dtc|27,/replace/||||7394
||dac|6,s_rpl||||7395
||dac|1,3||||7396
|v_rvs|dbc|2,svfnp|||reverse|7398
||dac|1,7||||7399
||dtc|27,/reverse/||||7400
||dac|6,s_rvs||||7401
||dac|1,1||||7402
|v_rtn|dbc|2,svknm|||rtntype|7404
||dac|1,7||||7405
||dtc|27,/rtntype/||||7406
||dac|2,k_rtn||||7407
|v_stx|dbc|2,svfnn|||setexit|7409
||dac|1,7||||7410
||dtc|27,/setexit/||||7411
||dac|6,s_stx||||7412
||dac|1,1||||7413
|v_stc|dbc|2,svknm|||stcount|7415
||dac|1,7||||7416
||dtc|27,/stcount/||||7417
||dac|2,k_stc||||7418
|v_stl|dbc|2,svknm|||stlimit|7420
||dac|1,7||||7421
||dtc|27,/stlimit/||||7422
||dac|2,k_stl||||7423
|v_suc|dbc|2,svkvc|||succeed|7425
||dac|1,7||||7426
||dtc|27,/succeed/||||7427
||dac|2,k_suc||||7428
||dac|4,ndsuc||||7429
|v_alp|dbc|2,svkwc|||alphabet|7431
||dac|1,8||||7432
||dtc|27,/alphabet/||||7433
||dac|2,k_alp||||7434
|v_cnt|dbc|2,svlbl|||continue|7436
||dac|1,8||||7437
||dtc|27,/continue/||||7438
||dac|6,l_cnt||||7439
||ejc|||||7440
|v_dtp|dbc|2,svfnp|||datatype|7444
||dac|1,8||||7445
||dtc|27,/datatype/||||7446
||dac|6,s_dtp||||7447
||dac|1,1||||7448
|v_erl|dbc|2,svknm|||errlimit|7450
||dac|1,8||||7451
||dtc|27,/errlimit/||||7452
||dac|2,k_erl||||7453
|v_fnc|dbc|2,svknm|||fnclevel|7455
||dac|1,8||||7456
||dtc|27,/fnclevel/||||7457
||dac|2,k_fnc||||7458
|v_fls|dbc|2,svknm|||fullscan|7460
||dac|1,8||||7461
||dtc|27,/fullscan/||||7462
||dac|2,k_fls||||7463
|v_lfl|dbc|2,svknm|||lastfile|7466
||dac|1,8||||7467
||dtc|27,/lastfile/||||7468
||dac|2,k_lfl||||7469
|v_lln|dbc|2,svknm|||lastline|7473
||dac|1,8||||7474
||dtc|27,/lastline/||||7475
||dac|2,k_lln||||7476
|v_mxl|dbc|2,svknm|||maxlngth|7479
||dac|1,8||||7480
||dtc|27,/maxlngth/||||7481
||dac|2,k_mxl||||7482
|v_ter|dbc|1,0|||terminal|7484
||dac|1,8||||7485
||dtc|27,/terminal/||||7486
||dac|1,0||||7487
|v_bsp|dbc|2,svfnn|||backspace|7490
||dac|1,9||||7491
||dtc|27,/backspace/||||7492
||dac|6,s_bsp||||7493
||dac|1,1||||7494
|v_pro|dbc|2,svfnn|||prototype|7497
||dac|1,9||||7498
||dtc|27,/prototype/||||7499
||dac|6,s_pro||||7500
||dac|1,1||||7501
|v_scn|dbc|2,svlbl|||scontinue|7503
||dac|1,9||||7504
||dtc|27,/scontinue/||||7505
||dac|6,l_scn||||7506
||dbc|1,0|||dummy entry to end list|7508
||dac|1,10|||length gt 9 (scontinue)|7509
||ejc|||||7510
|vdmkw|dac|4,v_anc|||anchor|7515
||dac|4,v_cod|||code|7519
||dac|1,1|||compare not printed|7524
||dac|4,v_dmp|||dump|7527
||dac|4,v_erl|||errlimit|7528
||dac|4,v_etx|||errtext|7529
||dac|4,v_ert|||errtype|7530
||dac|4,v_fil|||file|7532
||dac|4,v_fnc|||fnclevel|7534
||dac|4,v_ftr|||ftrace|7535
||dac|4,v_fls|||fullscan|7536
||dac|4,v_inp|||input|7537
||dac|4,v_lfl|||lastfile|7539
||dac|4,v_lln|||lastline|7542
||dac|4,v_lst|||lastno|7544
||dac|4,v_lin|||line|7546
||dac|4,v_mxl|||maxlength|7548
||dac|4,v_oup|||output|7549
||dac|4,v_pfl|||profile|7552
||dac|4,v_rtn|||rtntype|7554
||dac|4,v_stc|||stcount|7555
||dac|4,v_stl|||stlimit|7556
||dac|4,v_stn|||stno|7557
||dac|4,v_tra|||trace|7558
||dac|4,v_trm|||trim|7559
||dac|1,0|||end of list|7560
|vsrch|dac|1,0|||dummy entry to get proper indexing|7564
||dac|4,v_eqf|||start of 1 char variables (none)|7565
||dac|4,v_eqf|||start of 2 char variables|7566
||dac|4,v_any|||start of 3 char variables|7567
||dac|4,v_atn|||start of 4 char variables|7569
||dac|4,v_abe|||start of 5 char variables|7577
||dac|4,v_anc|||start of 6 char variables|7578
||dac|4,v_col|||start of 7 char variables|7579
||dac|4,v_alp|||start of 8 char variables|7580
||dac|4,v_bsp|||start of 9 char variables|7582
|c_yyy|dac|1,0|||last location in constant section|7589
||ttl|27,s p i t b o l -- working storage section||||7590
||sec||||start of working storage section|7636
||ejc|||||7637
|cmlab|dac|6,b_scl|||string used to check label legality|7641
||dac|1,2||||7642
||dtc|27,/  /||||7643
|w_aaa|dac|1,0||||7647
|actrm|dac|1,0|||trim indicator|7651
|aldyn|dac|1,0|||amount of dynamic store|7655
|allia|dic|16,+0|||dump ia|7656
|allsv|dac|1,0|||save wb in alloc|7657
|alsta|dac|1,0|||save wa in alost|7661
|arcdm|dac|1,0|||count dimensions|7665
|arnel|dic|16,+0|||count elements|7666
|arptr|dac|1,0|||offset ptr into arblk|7667
|arsvl|dic|16,+0|||save integer low bound|7668
||ejc|||||7669
|arfsi|dic|16,+0|||save current evolving subscript|7673
|arfxs|dac|1,0|||save base stack pointer|7674
|befof|dac|1,0|||save offset ptr into efblk|7678
|bpfpf|dac|1,0|||save pfblk pointer|7682
|bpfsv|dac|1,0|||save old function value|7683
|bpfxt|dac|1,0|||pointer to stacked arguments|7684
|clsvi|dic|16,+0|||save integer argument|7688
|cnscc|dac|1,0|||pointer to control card string|7692
|cnswc|dac|1,0|||word count|7693
|cnr_t|dac|1,0|||pointer to r_ttl or r_stl|7694
|cnvtp|dac|1,0|||save ptr into scvtb|7698
|datdv|dac|1,0|||save vrblk ptr for datatype name|7702
|datxs|dac|1,0|||save initial stack pointer|7703
|deflb|dac|1,0|||save vrblk ptr for label|7707
|defna|dac|1,0|||count function arguments|7708
|defvr|dac|1,0|||save vrblk ptr for function name|7709
|defxs|dac|1,0|||save initial stack pointer|7710
|dmarg|dac|1,0|||dump argument|7714
|dmpsa|dac|1,0|||preserve wa over prtvl call|7715
|dmpsb|dac|1,0|||preserve wb over syscm call|7717
|dmpsv|dac|1,0|||general scratch save|7719
|dmvch|dac|1,0|||chain pointer for variable blocks|7720
|dmpch|dac|1,0|||save sorted vrblk chain pointer|7721
|dmpkb|dac|1,0|||dummy kvblk for use in dumpr|7722
|dmpkt|dac|1,0|||kvvar trblk ptr (must follow dmpkb)|7723
|dmpkn|dac|1,0|||keyword number (must follow dmpkt)|7724
|dtcnb|dac|1,0|||name base|7728
|dtcnm|dac|1,0|||name ptr|7729
|dupsi|dic|16,+0|||store integer string length|7733
|enfch|dac|1,0|||for iochn chain head|7737
||ejc|||||7738
|ertwa|dac|1,0|||save wa|7742
|ertwb|dac|1,0|||save wb|7743
|evlin|dac|1,0|||dummy pattern block pcode|7747
|evlis|dac|1,0|||then node (must follow evlin)|7748
|evliv|dac|1,0|||value of parm1 (must follow evlis)|7749
|evlio|dac|1,0|||ptr to original node|7750
|evlif|dac|1,0|||flag for simple/complex argument|7751
|expsv|dac|1,0|||save op dope vector pointer|7755
|gbcfl|dac|1,0|||garbage collector active flag|7759
|gbclm|dac|1,0|||pointer to last move block (pass 3)|7760
|gbcnm|dac|1,0|||dummy first move block|7761
|gbcns|dac|1,0|||rest of dummy block (follows gbcnm)|7762
|gbcia|dic|16,+0|||dump ia|7768
|gbcsd|dac|1,0|||first address beyond sediment|7769
|gbcsf|dac|1,0|||free space within sediment|7770
|gbsva|dac|1,0|||save wa|7772
|gbsvb|dac|1,0|||save wb|7773
|gbsvc|dac|1,0|||save wc|7774
|gnvhe|dac|1,0|||ptr to end of hash chain|7778
|gnvnw|dac|1,0|||number of words in string name|7779
|gnvsa|dac|1,0|||save wa|7780
|gnvsb|dac|1,0|||save wb|7781
|gnvsp|dac|1,0|||pointer into vsrch table|7782
|gnvst|dac|1,0|||pointer to chars of string|7783
|gtawa|dac|1,0|||save wa|7787
|gtina|dac|1,0|||save wa|7791
|gtinb|dac|1,0|||save wb|7792
||ejc|||||7793
|gtnnf|dac|1,0|||zero/nonzero for result +/-|7797
|gtnsi|dic|16,+0|||general integer save|7798
|gtndf|dac|1,0|||0/1 for dec point so far no/yes|7801
|gtnes|dac|1,0|||zero/nonzero exponent +/-|7802
|gtnex|dic|16,+0|||real exponent|7803
|gtnsc|dac|1,0|||scale (places after point)|7804
|gtnsr|drc|17,+0.0|||general real save|7805
|gtnrd|dac|1,0|||flag for ok real number|7806
|gtpsb|dac|1,0|||save wb|7811
|gtssf|dac|1,0|||0/1 for result +/-|7815
|gtsvc|dac|1,0|||save wc|7816
|gtsvb|dac|1,0|||save wb|7817
|gtses|dac|1,0|||char + or - for exponent +/-|7822
|gtsrs|drc|17,+0.0|||general real save|7823
|gtvrc|dac|1,0|||save wc|7829
|ioptt|dac|1,0|||type of association|7844
|lodfn|dac|1,0|||pointer to vrblk for func name|7850
|lodna|dac|1,0|||count number of arguments|7851
|mxint|dac|1,0||||7857
|pfsvw|dac|1,0|||to save a w-reg|7863
|prnsi|dic|16,+0|||scratch integer loc|7868
|prsna|dac|1,0|||save wa|7872
|prsva|dac|1,0|||save wa|7876
|prsvb|dac|1,0|||save wb|7877
|prsvc|dac|1,0|||save char counter|7878
|prtsa|dac|1,0|||save wa|7882
|prtsb|dac|1,0|||save wb|7883
|prvsi|dac|1,0|||save idval|7887
|psave|dac|1,0|||temporary save for current node ptr|7891
|psavc|dac|1,0|||save cursor in p_spn, p_str|7892
|rlals|dac|1,0|||ptr to list of bounds and adjusts|7897
|rldcd|dac|1,0|||save code adjustment|7901
|rldst|dac|1,0|||save static adjustment|7902
|rldls|dac|1,0|||save list pointer|7903
|rtnbp|dac|1,0|||to save a block pointer|7908
|rtnfv|dac|1,0|||new function value (result)|7909
|rtnsv|dac|1,0|||old function value (saved value)|7910
|sbssv|dac|1,0|||save third argument|7914
|scnsa|dac|1,0|||save wa|7918
|scnsb|dac|1,0|||save wb|7919
|scnsc|dac|1,0|||save wc|7920
|scnof|dac|1,0|||save offset|7921
||ejc|||||7924
|srtdf|dac|1,0|||datatype field name|7928
|srtfd|dac|1,0|||found dfblk address|7929
|srtff|dac|1,0|||found field name|7930
|srtfo|dac|1,0|||offset to field name|7931
|srtnr|dac|1,0|||number of rows|7932
|srtof|dac|1,0|||offset within row to sort key|7933
|srtrt|dac|1,0|||root offset|7934
|srts1|dac|1,0|||save offset 1|7935
|srts2|dac|1,0|||save offset 2|7936
|srtsc|dac|1,0|||save wc|7937
|srtsf|dac|1,0|||sort array first row offset|7938
|srtsn|dac|1,0|||save n|7939
|srtso|dac|1,0|||offset to a(0)|7940
|srtsr|dac|1,0|||0, non-zero for sort, rsort|7941
|srtst|dac|1,0|||stride from one row to next|7942
|srtwc|dac|1,0|||dump wc|7943
|stpsi|dic|16,+0|||save value of stcount|7948
|stpti|dic|16,+0|||save time elapsed|7949
|tfnsi|dic|16,+0|||number of headers|7953
|xscrt|dac|1,0|||save return code|7957
|xscwb|dac|1,0|||save register wb|7958
|g_aaa|dac|1,0||||7962
|alfsf|dic|16,+0|||factor in free store pcntage check|7966
|cmerc|dac|1,0|||count of initial compile errors|7970
|cmpln|dac|1,0|||line number of first line of stmt|7971
|cmpxs|dac|1,0|||save stack ptr in case of errors|7972
|cmpsn|dac|1,1|||number of next statement to compile|7973
|cnsil|dac|1,0|||save scnil during include process.|7978
|cnind|dac|1,0|||current include file nest level|7979
|cnspt|dac|1,0|||save scnpt during include process.|7980
|cnttl|dac|1,0|||flag for -title, -stitl|7982
|cpsts|dac|1,0|||suppress comp. stats if non zero|7986
|cswdb|dac|1,0|||0/1 for -single/-double|7990
|cswer|dac|1,0|||0/1 for -errors/-noerrors|7991
|cswex|dac|1,0|||0/1 for -execute/-noexecute|7992
|cswfl|dac|1,1|||0/1 for -nofail/-fail|7993
|cswin|dac|2,iniln|||xxx for -inxxx|7994
|cswls|dac|1,1|||0/1 for -nolist/-list|7995
|cswno|dac|1,0|||0/1 for -optimise/-noopt|7996
|cswpr|dac|1,0|||0/1 for -noprint/-print|7997
|ctmsk|dbc|1,0|||last bit position used in r_ctp|8001
|curid|dac|1,0|||current id value|8002
||ejc|||||8003
|cwcof|dac|1,0|||next word offset in current ccblk|8007
|dnams|dac|1,0|||size of sediment in baus|8012
|erich|dac|1,0|||copy error reports to int.chan if 1|8017
|erlst|dac|1,0|||for listr when errors go to int.ch.|8018
|errft|dac|1,0|||fatal error flag|8019
|errsp|dac|1,0|||error suppression flag|8020
|exsts|dac|1,0|||suppress exec stats if set|8024
|flprt|dac|1,0|||location of fail offset for return|8028
|flptr|dac|1,0|||location of failure offset on stack|8029
|gbsed|dic|16,+0|||factor in sediment pcntage check|8034
|gbcnt|dac|1,0|||count of garbage collections|8036
|gtcef|dac|1,0|||save fail ptr in case of error|8040
|gtsrn|drc|17,+0.0|||rounding factor 0.5*10**-cfp_s|8048
|gtssc|drc|17,+0.0|||scaling value 10**cfp_s|8049
|gtswk|dac|1,0|||ptr to work area for gtstg|8052
|headp|dac|1,0|||header printed flag|8056
|hshnb|dic|16,+0|||number of hash buckets|8060
|initr|dac|1,0|||save terminal flag|8064
||ejc|||||8065
|kvabe|dac|1,0|||abend|8071
|kvanc|dac|1,1|||anchor|8072
|kvcod|dac|1,0|||code|8076
|kvcom|dac|1,0|||compare|8078
|kvdmp|dac|1,0|||dump|8080
|kverl|dac|1,0|||errlimit|8081
|kvert|dac|1,0|||errtype|8082
|kvftr|dac|1,0|||ftrace|8083
|kvfls|dac|1,1|||fullscan|8084
|kvinp|dac|1,1|||input|8085
|kvmxl|dac|1,5000|||maxlength|8086
|kvoup|dac|1,1|||output|8087
|kvpfl|dac|1,0|||profile|8090
|kvtra|dac|1,0|||trace|8092
|kvtrm|dac|1,1|||trim|8093
|kvfnc|dac|1,0|||fnclevel|8094
|kvlst|dac|1,0|||lastno|8095
|kvlln|dac|1,0|||lastline|8097
|kvlin|dac|1,0|||line|8098
|kvstn|dac|1,0|||stno|8100
|kvalp|dac|1,0|||alphabet|8104
|kvrtn|dac|4,nulls|||rtntype (scblk pointer)|8105
|kvstl|dic|16,+2147483647|||stlimit|8111
|kvstc|dic|16,+2147483647|||stcount (counts down from stlimit)|8112
|lstid|dac|1,0|||include depth of current image|8122
|lstlc|dac|1,0|||count lines on source list page|8124
|lstnp|dac|1,0|||max number of lines on page|8125
|lstpf|dac|1,1|||set nonzero if current image listed|8126
|lstpg|dac|1,0|||current source list page number|8127
|lstpo|dac|1,0|||offset to   page nnn   message|8128
|lstsn|dac|1,0|||remember last stmnum listed|8129
|mxlen|dac|1,0|||initialised by sysmx call|8133
|noxeq|dac|1,0|||set non-zero to inhibit execution|8137
|pfdmp|dac|1,0|||set non-0 if &profile set non-0|8143
|pffnc|dac|1,0|||set non-0 if funct just entered|8144
|pfstm|dic|16,+0|||to store starting time of stmt|8145
|pfetm|dic|16,+0|||to store ending time of stmt|8146
|pfnte|dac|1,0|||nr of table entries|8147
|pfste|dic|16,+0|||gets int rep of table entry size|8148
||ejc|||||8151
|pmdfl|dac|1,0|||pattern assignment flag|8155
|pmhbs|dac|1,0|||history stack base pointer|8156
|pmssl|dac|1,0|||length of subject string in chars|8157
|polcs|dac|1,1|||poll interval start value|8162
|polct|dac|1,1|||poll interval counter|8163
|prich|dac|1,0|||printer on interactive channel|8168
|prstd|dac|1,0|||tested by prtpg|8169
|prsto|dac|1,0|||standard listing option flag|8170
|prbuf|dac|1,0|||ptr to print bfr in static|8174
|precl|dac|1,0|||extended/compact listing flag|8175
|prlen|dac|1,0|||length of print buffer in chars|8176
|prlnw|dac|1,0|||length of print buffer in words|8177
|profs|dac|1,0|||offset to next location in prbuf|8178
|prtef|dac|1,0|||endfile flag|8179
||ejc|||||8180
|rdcln|dac|1,0|||current statement line number|8184
|rdnln|dac|1,0|||next statement line number|8185
|rsmem|dac|1,0|||reserve memory|8189
|stmcs|dac|1,1|||counter startup value|8193
|stmct|dac|1,1|||counter active value|8194
|a_aaa|dac|1,0|||start of adjustable values|8216
|cmpss|dac|1,0|||save subroutine stack ptr|8217
|dnamb|dac|1,0|||start of dynamic area|8218
|dnamp|dac|1,0|||next available loc in dynamic area|8219
|dname|dac|1,0|||end of available dynamic area|8220
|hshtb|dac|1,0|||pointer to start of vrblk hash tabl|8221
|hshte|dac|1,0|||pointer past end of vrblk hash tabl|8222
|iniss|dac|1,0|||save subroutine stack ptr|8223
|pftbl|dac|1,0|||gets adrs of (imag) table base|8224
|prnmv|dac|1,0|||vrblk ptr from last name search|8225
|statb|dac|1,0|||start of static area|8226
|state|dac|1,0|||end of static area|8227
|stxvr|dac|4,nulls|||vrblk pointer or null|8228
|r_aaa|dac|1,0|||start of relocatable values|8237
|r_arf|dac|1,0|||array block pointer for arref|8238
|r_ccb|dac|1,0|||ptr to ccblk being built (cdwrd)|8239
|r_cim|dac|1,0|||ptr to current compiler input str|8240
|r_cmp|dac|1,0|||copy of r_cim used in cmpil|8241
|r_cni|dac|1,0|||ptr to next compiler input string|8242
|r_cnt|dac|1,0|||cdblk pointer for setexit continue|8243
|r_cod|dac|1,0|||pointer to current cdblk or exblk|8244
|r_ctp|dac|1,0|||ptr to current ctblk for patst|8245
|r_cts|dac|1,0|||ptr to last string scanned by patst|8246
|r_ert|dac|1,0|||trblk pointer for errtype trace|8247
|r_etx|dac|4,nulls|||pointer to errtext string|8248
|r_exs|dac|1,0|||= save xl in expdm|8249
|r_fcb|dac|1,0|||fcblk chain head|8250
|r_fnc|dac|1,0|||trblk pointer for fnclevel trace|8251
|r_gtc|dac|1,0|||keep code ptr for gtcod,gtexp|8252
|r_ici|dac|1,0|||saved r_cim during include process.|8254
|r_ifa|dac|1,0|||array of file names by incl. depth|8256
|r_ifl|dac|1,0|||array of line nums by include depth|8257
|r_ifn|dac|1,0|||last include file name|8259
|r_inc|dac|1,0|||table of include file names seen|8260
|r_io1|dac|1,0|||file arg1 for ioput|8262
|r_io2|dac|1,0|||file arg2 for ioput|8263
|r_iof|dac|1,0|||fcblk ptr or 0|8264
|r_ion|dac|1,0|||name base ptr|8265
|r_iop|dac|1,0|||predecessor block ptr for ioput|8266
|r_iot|dac|1,0|||trblk ptr for ioput|8267
|r_pms|dac|1,0|||subject string ptr in pattern match|8272
|r_ra2|dac|1,0|||replace second argument last time|8273
|r_ra3|dac|1,0|||replace third argument last time|8274
|r_rpt|dac|1,0|||ptr to ctblk replace table last usd|8275
|r_scp|dac|1,0|||save pointer from last scane call|8276
|r_sfc|dac|4,nulls|||current source file name|8278
|r_sfn|dac|1,0|||ptr to source file name table|8279
|r_sxl|dac|1,0|||preserve xl in sortc|8281
|r_sxr|dac|1,0|||preserve xr in sorta/sortc|8282
|r_stc|dac|1,0|||trblk pointer for stcount trace|8283
|r_stl|dac|1,0|||source listing sub-title|8284
|r_sxc|dac|1,0|||code (cdblk) ptr for setexit trap|8285
|r_ttl|dac|4,nulls|||source listing title|8286
|r_xsc|dac|1,0|||string pointer for xscan|8287
||ejc|||||8288
|r_uba|dac|4,stndo|||binary at|8293
|r_ubm|dac|4,stndo|||binary ampersand|8294
|r_ubn|dac|4,stndo|||binary number sign|8295
|r_ubp|dac|4,stndo|||binary percent|8296
|r_ubt|dac|4,stndo|||binary not|8297
|r_uub|dac|4,stndo|||unary vertical bar|8298
|r_uue|dac|4,stndo|||unary equal|8299
|r_uun|dac|4,stndo|||unary number sign|8300
|r_uup|dac|4,stndo|||unary percent|8301
|r_uus|dac|4,stndo|||unary slash|8302
|r_uux|dac|4,stndo|||unary exclamation|8303
|r_yyy|dac|1,0|||last relocatable location|8304
|scnbl|dac|1,0|||set non-zero if scanned past blanks|8308
|scncc|dac|1,0|||non-zero to scan control card name|8309
|scngo|dac|1,0|||set non-zero to scan goto field|8310
|scnil|dac|1,0|||length of current input image|8311
|scnpt|dac|1,0|||pointer to next location in r_cim|8312
|scnrs|dac|1,0|||set non-zero to signal rescan|8313
|scnse|dac|1,0|||start of current element|8314
|scntp|dac|1,0|||save syntax type from last call|8315
|stage|dac|1,0|||initial value = initial compile|8319
||ejc|||||8320
|stbas|dac|1,0|||pointer past stack base|8324
|stxoc|dac|1,0|||code pointer offset|8328
|stxof|dac|1,0|||failure offset|8329
|timsx|dic|16,+0|||time at start of execution|8333
|timup|dac|1,0|||set when time up occurs|8334
|xsofs|dac|1,0|||offset to current location in r_xsc|8338
|w_yyy|dac|1,0||||8342
||ttl|27,s p i t b o l -- minimal code||||8343
||sec||||start of program section|8344
|s_aaa|ent|2,bl__i|||mark start of code|8345
||ttl|27,s p i t b o l -- relocation||||8347
|relaj|prc|25,e|1,0||entry point|8363
||mov|11,-(xs)|7,xr||save xr|8364
||mov|11,-(xs)|8,wa||save wa|8365
||mov|3,rlals|7,xl||save ptr to list of bounds|8366
||mov|7,xr|8,wb||ptr to first pointer to process|8367
|rlaj0|mov|7,xl|3,rlals||restore xl|8371
||bne|7,xr|9,(xs)|6,rlaj1|proceed if more to do|8372
||mov|8,wa|10,(xs)+||restore wa|8373
||mov|7,xr|10,(xs)+||restore xr|8374
||exi||||return to caller|8375
|rlaj1|mov|8,wa|9,(xr)||load next pointer on list|8379
||lct|8,wb|18,=rnsi_||number of sections of adjusters|8380
|rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|ok if past end of section|8384
||blt|8,wa|13,rlstr(xl)|6,rlaj3|or if before start of section|8385
||add|8,wa|13,rladj(xl)||within section, add adjustment|8386
||mov|9,(xr)|8,wa||return updated ptr to memory|8387
||brn|6,rlaj4|||done with this pointer|8388
|rlaj3|add|7,xl|19,*rssi_||advance to next section|8392
||bct|8,wb|6,rlaj2||jump if more to go|8393
|rlaj4|ica|7,xr|||increment to next ptr on list|8397
||brn|6,rlaj0|||jump to check  for completion|8398
||enp||||end procedure relaj|8399
||ejc|||||8400
|relcr|prc|25,e|1,0||entry point|8421
||add|7,xl|19,*rlsi_||point past build area|8422
||mov|11,-(xl)|8,wa||save original code address|8423
||mov|8,wa|22,=s_aaa||compute adjustment|8424
||sub|8,wa|9,(xl)||as new s_aaa minus original s_aaa|8425
||mov|11,-(xl)|8,wa||save code adjustment|8426
||mov|8,wa|22,=s_yyy||end of target code section|8427
||sub|8,wa|22,=s_aaa||length of code section|8428
||add|8,wa|13,num01(xl)||plus original start address|8429
||mov|11,-(xl)|8,wa||end of original code section|8430
||mov|11,-(xl)|8,wb||save constant section address|8431
||mov|8,wb|21,=c_aaa||start of constants section|8432
||mov|8,wa|21,=c_yyy||end of constants section|8433
||sub|8,wa|8,wb||length of constants section|8434
||sub|8,wb|9,(xl)||new c_aaa minus original c_aaa|8435
||mov|11,-(xl)|8,wb||save constant adjustment|8436
||add|8,wa|13,num01(xl)||length plus original start adr|8437
||mov|11,-(xl)|8,wa||save as end of original constants|8438
||mov|11,-(xl)|8,wc||save working globals address|8439
||mov|8,wc|20,=g_aaa||start of working globals section|8440
||mov|8,wa|20,=w_yyy||end of working section|8441
||sub|8,wa|8,wc||length of working globals|8442
||sub|8,wc|9,(xl)||new g_aaa minus original g_aaa|8443
||mov|11,-(xl)|8,wc||save working globals adjustment|8444
||add|8,wa|13,num01(xl)||length plus original start adr|8445
||mov|11,-(xl)|8,wa||save as end of working globals|8446
||mov|8,wb|3,statb||old start of static region|8447
||mov|11,-(xl)|8,wb||save|8448
||sub|7,xr|8,wb||compute adjustment|8449
||mov|11,-(xl)|7,xr||save new statb minus old statb|8450
||mov|11,-(xl)|3,state||old end of static region|8451
||mov|8,wb|3,dnamb||old start of dynamic region|8452
||mov|11,-(xl)|8,wb||save|8453
||scp|8,wa|||new start of dynamic|8454
||sub|8,wa|8,wb||compute adjustment|8455
||mov|11,-(xl)|8,wa||save new dnamb minus old dnamb|8456
||mov|8,wc|3,dnamp||old end of dynamic region in use|8457
||mov|11,-(xl)|8,wc||save as end of old dynamic region|8458
||exi|||||8459
||enp|||||8460
||ejc|||||8461
|reldn|prc|25,e|1,0||entry point|8476
||mov|3,rldcd|13,rlcda(xl)||save code adjustment|8477
||mov|3,rldst|13,rlsta(xl)||save static adjustment|8478
||mov|3,rldls|7,xl||save list pointer|8479
|rld01|add|9,(xr)|3,rldcd||adjust block type word|8483
||mov|7,xl|9,(xr)||load block type word|8484
||lei|7,xl|||load entry point id (bl_xx)|8485
||ejc|||||8498
||bsw|7,xl|2,bl___||switch on block type|8502
||iff|2,bl_ar|6,rld03||arblk|8539
||iff|2,bl_cd|6,rld07||cdblk|8539
||iff|2,bl_ex|6,rld10||exblk|8539
||iff|2,bl_ic|6,rld05||icblk|8539
||iff|2,bl_nm|6,rld13||nmblk|8539
||iff|2,bl_p0|6,rld13||p0blk|8539
||iff|2,bl_p1|6,rld14||p1blk|8539
||iff|2,bl_p2|6,rld14||p2blk|8539
||iff|2,bl_rc|6,rld05||rcblk|8539
||iff|2,bl_sc|6,rld05||scblk|8539
||iff|2,bl_se|6,rld13||seblk|8539
||iff|2,bl_tb|6,rld17||tbblk|8539
||iff|2,bl_vc|6,rld17||vcblk|8539
||iff|2,bl_xn|6,rld05||xnblk|8539
||iff|2,bl_xr|6,rld20||xrblk|8539
||iff|2,bl_bc|6,rld05||bcblk - dummy to fill out iffs|8539
||iff|2,bl_pd|6,rld15||pdblk|8539
||iff|2,bl_tr|6,rld19||trblk|8539
||iff|2,bl_bf|6,rld05||bfblk|8539
||iff|2,bl_cc|6,rld05||ccblk|8539
||iff|2,bl_cm|6,rld05||cmblk|8539
||iff|2,bl_ct|6,rld05||ctblk|8539
||iff|2,bl_df|6,rld05||dfblk|8539
||iff|2,bl_ef|6,rld08||efblk|8539
||iff|2,bl_ev|6,rld09||evblk|8539
||iff|2,bl_ff|6,rld11||ffblk|8539
||iff|2,bl_kv|6,rld13||kvblk|8539
||iff|2,bl_pf|6,rld16||pfblk|8539
||iff|2,bl_te|6,rld18||teblk|8539
||esw||||end of jump table|8539
|rld03|mov|8,wa|13,arlen(xr)||load length|8543
||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|8544
|rld04|add|8,wa|7,xr||point past last reloc field|8553
||add|8,wb|7,xr||point to first reloc field|8554
||mov|7,xl|3,rldls||point to list of bounds|8555
||jsr|6,relaj|||adjust pointers|8556
||ejc|||||8557
|rld05|mov|8,wa|9,(xr)||block type word|8567
||jsr|6,blkln|||get length of block|8568
||add|7,xr|8,wa||point to next block|8569
||blt|7,xr|8,wc|6,rld01|continue if more to process|8570
||mov|7,xl|3,rldls||restore xl|8571
||exi||||return to caller if done|8572
|rld07|mov|8,wa|13,cdlen(xr)||load length|8585
||mov|8,wb|19,*cdfal||set offset|8586
||bne|9,(xr)|22,=b_cdc|6,rld04|jump back if not complex goto|8587
||mov|8,wb|19,*cdcod||do not process cdfal word|8588
||brn|6,rld04|||jump back|8589
|rld08|mov|8,wa|19,*efrsl||set length|8597
||mov|8,wb|19,*efcod||and offset|8598
||brn|6,rld04|||all set|8599
|rld09|mov|8,wa|19,*offs3||point past third field|8603
||mov|8,wb|19,*evexp||set offset|8604
||brn|6,rld04|||all set|8605
|rld10|mov|8,wa|13,exlen(xr)||load length|8609
||mov|8,wb|19,*exflc||set offset|8610
||brn|6,rld04|||jump back|8611
||ejc|||||8612
|rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|skip dfblk if not first field|8626
||mov|11,-(xs)|7,xr||save xr|8627
||mov|7,xr|13,ffdfp(xr)||load old ptr to dfblk|8628
||add|7,xr|3,rldst||current location of dfblk|8629
||add|9,(xr)|3,rldcd||adjust dfblk type word|8630
||mov|8,wa|13,dflen(xr)||length of dfblk|8631
||mov|8,wb|19,*dfnam||offset to dfnam field|8632
||add|8,wa|7,xr||point past last reloc field|8633
||add|8,wb|7,xr||point to first reloc field|8634
||mov|7,xl|3,rldls||point to list of bounds|8635
||jsr|6,relaj|||adjust pointers|8636
||mov|7,xr|13,dfnam(xr)||pointer to static scblk|8637
||add|9,(xr)|3,rldcd||adjust scblk type word|8638
||mov|7,xr|10,(xs)+||restore ffblk pointer|8639
|rld12|mov|8,wa|19,*ffofs||set length|8645
||mov|8,wb|19,*ffdfp||set offset|8646
||brn|6,rld04|||all set|8647
|rld13|mov|8,wa|19,*offs2||point past second field|8651
||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|8652
||brn|6,rld04|||all set|8653
|rld14|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|8660
||mov|8,wb|19,*pthen||set offset|8661
||brn|6,rld04|||all set|8662
|rld15|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|8672
||add|7,xl|3,rldst||adjust for static relocation|8673
||mov|8,wa|13,dfpdl(xl)||get pdblk length|8674
||mov|8,wb|19,*pddfp||set offset|8675
||brn|6,rld04|||all set|8676
||ejc|||||8677
|rld16|add|13,pfvbl(xr)|3,rldst||adjust non-contiguous field|8684
||mov|8,wa|13,pflen(xr)||get pfblk length|8685
||mov|8,wb|19,*pfcod||offset to first reloc|8686
||brn|6,rld04|||all set|8687
|rld17|mov|8,wa|13,offs2(xr)||load length|8691
||mov|8,wb|19,*offs3||set offset|8692
||brn|6,rld04|||jump back|8693
|rld18|mov|8,wa|19,*tesi_||set length|8697
||mov|8,wb|19,*tesub||and offset|8698
||brn|6,rld04|||all set|8699
|rld19|mov|8,wa|19,*trsi_||set length|8703
||mov|8,wb|19,*trval||and offset|8704
||brn|6,rld04|||all set|8705
|rld20|mov|8,wa|13,xrlen(xr)||load length|8709
||mov|8,wb|19,*xrptr||set offset|8710
||brn|6,rld04|||jump back|8711
||enp||||end procedure reldn|8712
||ejc|||||8713
|reloc|prc|25,e|1,0||entry point|8725
||mov|7,xr|13,rldys(xl)||old start of dynamic|8726
||mov|8,wc|13,rldye(xl)||old end of dynamic|8727
||add|7,xr|13,rldya(xl)||create new start of dynamic|8728
||add|8,wc|13,rldya(xl)||create new end of dynamic|8729
||jsr|6,reldn|||relocate pointers in dynamic|8730
||jsr|6,relws|||relocate pointers in working sect|8731
||jsr|6,relst|||relocate pointers in static|8732
||exi||||return to caller|8733
||enp||||end procedure reloc|8734
||ejc|||||8735
|relst|prc|25,e|1,0||entry point|8750
||mov|7,xr|3,pftbl||profile table|8751
||bze|7,xr|6,rls01||branch if no table allocated|8752
||add|9,(xr)|13,rlcda(xl)||adjust block type word|8753
|rls01|mov|8,wc|3,hshtb||point to start of hash table|8757
||mov|8,wb|8,wc||point to first hash bucket|8758
||mov|8,wa|3,hshte||point beyond hash table|8759
||jsr|6,relaj|||adjust bucket pointers|8760
|rls02|beq|8,wc|3,hshte|6,rls05|done if none left|8764
||mov|7,xr|8,wc||else copy slot pointer|8765
||ica|8,wc|||bump slot pointer|8766
||sub|7,xr|19,*vrnxt||set offset to merge into loop|8767
|rls03|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|8771
||bze|7,xr|6,rls02||jump for next bucket if chain end|8772
||mov|8,wa|19,*vrlen||offset of first loc past ptr fields|8773
||mov|8,wb|19,*vrget||offset of first location in vrblk|8774
||bnz|13,vrlen(xr)|6,rls04||jump if not system variable|8775
||mov|8,wa|19,*vrsi_||offset to include vrsvp field|8776
|rls04|add|8,wa|7,xr||create end ptr|8780
||add|8,wb|7,xr||create start ptr|8781
||jsr|6,relaj|||adjust pointers in vrblk|8782
||brn|6,rls03|||check for another vrblk on chain|8783
|rls05|exi||||return to caller|8787
||enp||||end procedure relst|8788
||ejc|||||8789
|relws|prc|25,e|1,0||entry point|8805
||mov|8,wb|20,=a_aaa||point to start of adjustables|8806
||mov|8,wa|20,=r_yyy||point to end of adjustables|8807
||jsr|6,relaj|||relocate adjustable pointers|8808
||add|3,dname|13,rldya(xl)||adjust ptr missed by relaj|8809
||mov|8,wb|20,=kvrtn||case of kvrtn|8810
||mov|8,wa|8,wb||handled specially|8811
||ica|8,wa|||one value to adjust|8812
||jsr|6,relaj|||adjust kvrtn|8813
||exi||||return to caller|8814
||enp||||end procedure relws|8815
||ttl|27,s p i t b o l -- initialization||||8817
|start|prc|25,e|1,0||entry point|8827
||mov|3,mxint|8,wb|||8828
||mov|4,bitsm|8,wb|||8829
||zer|8,wb||||8830
||mov|7,xs|8,wa||discard return|8832
||jsr|6,systm|||initialise timer|8833
||sti|3,timsx|||store time|8836
||mov|3,statb|7,xr||start address of static|8837
||mov|3,rsmem|19,*e_srs||reserve memory|8889
||mov|3,stbas|7,xs||store stack base|8890
||sss|3,iniss|||save s-r stack ptr|8891
||ldi|4,intvh|||get 100|8896
||dvi|4,alfsp|||form 100 / alfsp|8897
||sti|3,alfsf|||store the factor|8898
||ldi|4,intvh|||get 100|8904
||dvi|4,gbsdp|||form 100 / gbsdp|8905
||sti|3,gbsed|||store the factor|8906
||lct|8,wb|18,=cfp_s||load counter for significant digits|8915
||ldr|4,reav1|||load 1.0|8916
|ini03|mlr|4,reavt|||* 10.0|8920
||bct|8,wb|6,ini03||loop till done|8921
||str|3,gtssc|||store 10**(max sig digits)|8922
||ldr|4,reap5|||load 0.5|8923
||dvr|3,gtssc|||compute 0.5*10**(max sig digits)|8924
||str|3,gtsrn|||store as rounding bias|8925
||zer|8,wc|||set to read parameters|8928
||jsr|6,prpar|||read them|8929
||ejc|||||8930
||sub|7,xl|19,*e_srs||allow for reserve memory|8935
||mov|8,wa|3,prlen||get print buffer length|8936
||add|8,wa|18,=cfp_a||add no. of chars in alphabet|8937
||add|8,wa|18,=nstmx||add chars for gtstg bfr|8938
||ctb|8,wa|1,8||convert to bytes, allowing a margin|8939
||mov|7,xr|3,statb||point to static base|8940
||add|7,xr|8,wa||increment for above buffers|8941
||add|7,xr|19,*e_hnb||increment for hash table|8942
||add|7,xr|19,*e_sts||bump for initial static block|8943
||jsr|6,sysmx|||get mxlen|8944
||mov|3,kvmxl|8,wa||provisionally store as maxlngth|8945
||mov|3,mxlen|8,wa||and as mxlen|8946
||bgt|7,xr|8,wa|6,ini06|skip if static hi exceeds mxlen|8947
||ctb|8,wa|1,1||round up and make bigger than mxlen|8948
||mov|7,xr|8,wa||use it instead|8949
|ini06|mov|3,dnamb|7,xr||dynamic base adrs|8954
||mov|3,dnamp|7,xr||dynamic ptr|8955
||bnz|8,wa|6,ini07||skip if non-zero mxlen|8956
||dca|7,xr|||point a word in front|8957
||mov|3,kvmxl|7,xr||use as maxlngth|8958
||mov|3,mxlen|7,xr||and as mxlen|8959
||ejc|||||8960
|ini07|mov|3,dname|7,xl||store dynamic end address|8965
||blt|3,dnamb|7,xl|6,ini09|skip if high enough|8966
||jsr|6,sysmm|||request more memory|8967
||wtb|7,xr|||get as baus (sgd05)|8968
||add|7,xl|7,xr||bump by amount obtained|8969
||bnz|7,xr|6,ini07||try again|8970
||mov|8,wa|18,=mxern||insufficient memory for maxlength|8972
||zer|8,wb|||no column number info|8973
||zer|8,wc|||no line number info|8974
||mov|7,xr|18,=stgic||initial compile stage|8975
||mov|7,xl|21,=nulls||no file name|8977
||jsr|6,sysea|||advise of error|8979
||ppm|6,ini08|||cant use error logic yet|8980
||brn|6,ini08|||force termination|8981
||erb|1,329|26,requested maxlngth too large|||8985
|ini08|mov|7,xr|21,=endmo||point to failure message|8987
||mov|8,wa|4,endml||message length|8988
||jsr|6,syspr|||print it (prtst not yet usable)|8989
||ppm||||should not fail|8990
||zer|7,xl|||no fcb chain yet|8991
||mov|8,wb|18,=num10||set special code value|8992
||jsr|6,sysej|||pack up (stopr not yet usable)|8993
|ini09|mov|7,xr|3,statb||point to static again|8997
||jsr|6,insta|||initialize static|8998
||mov|8,wa|18,=e_hnb||get number of hash headers|9002
||mti|8,wa|||convert to integer|9003
||sti|3,hshnb|||store for use by gtnvr procedure|9004
||lct|8,wa|8,wa||counter for clearing hash table|9005
||mov|3,hshtb|7,xr||pointer to hash table|9006
|ini11|zer|10,(xr)+|||blank a word|9010
||bct|8,wa|6,ini11||loop|9011
||mov|3,hshte|7,xr||end of hash table adrs is kept|9012
||mov|3,state|7,xr||store static end address|9013
||mov|8,wc|18,=num01||table will have only one bucket|9018
||mov|7,xl|21,=nulls||default table value|9019
||mov|3,r_sfc|7,xl||current source file name|9020
||jsr|6,tmake|||create table|9021
||mov|3,r_sfn|7,xr||save ptr to table|9022
||mov|8,wc|18,=num01||table will have only one bucket|9028
||mov|7,xl|21,=nulls||default table value|9029
||jsr|6,tmake|||create table|9030
||mov|3,r_inc|7,xr||save ptr to table|9031
||mov|8,wa|18,=ccinm||maximum nesting level|9036
||mov|7,xl|21,=nulls||null string default value|9037
||jsr|6,vmake|||create array|9038
||ppm|||||9039
||mov|3,r_ifa|7,xr||save ptr to array|9040
||mov|8,wa|18,=ccinm||maximum nesting level|9044
||mov|7,xl|21,=inton||integer one default value|9045
||jsr|6,vmake|||create array|9046
||ppm|||||9047
||mov|3,r_ifl|7,xr||save ptr to array|9048
||mov|7,xl|21,=v_inp||point to string /input/|9055
||mov|8,wb|18,=trtin||trblk type for input|9056
||jsr|6,inout|||perform input association|9057
||mov|7,xl|21,=v_oup||point to string /output/|9058
||mov|8,wb|18,=trtou||trblk type for output|9059
||jsr|6,inout|||perform output association|9060
||mov|8,wc|3,initr||terminal flag|9061
||bze|8,wc|6,ini13||skip if no terminal|9062
||jsr|6,prpar|||associate terminal|9063
||ejc|||||9064
|ini13|jsr|6,sysdc|||call date check|9068
||mov|3,flptr|7,xs||in case stack overflows in compiler|9069
||jsr|6,cmpil|||call compiler|9073
||mov|3,r_cod|7,xr||set ptr to first code block|9074
||mov|3,r_ttl|21,=nulls||forget title|9075
||mov|3,r_stl|21,=nulls||forget sub-title|9076
||zer|3,r_cim|||forget compiler input image|9077
||zer|3,r_ccb|||forget interim code block|9078
||zer|3,cnind|||in case end occurred with include|9080
||zer|3,lstid|||listing include depth|9081
||zer|7,xl|||clear dud value|9083
||zer|8,wb|||dont shift dynamic store up|9084
||zer|3,dnams|||collect sediment too|9086
||jsr|6,gbcol|||clear garbage left from compile|9087
||mov|3,dnams|7,xr||record new sediment size|9088
||bnz|3,cpsts|6,inix0||skip if no listing of comp stats|9092
||jsr|6,prtpg|||eject page|9093
||jsr|6,prtmm|||print memory usage|9097
||mti|3,cmerc|||get count of errors as integer|9098
||mov|7,xr|21,=encm3||point to /compile errors/|9099
||jsr|6,prtmi|||print it|9100
||mti|3,gbcnt|||garbage collection count|9101
||sbi|4,intv1|||adjust for unavoidable collect|9102
||mov|7,xr|21,=stpm5||point to /storage regenerations/|9103
||jsr|6,prtmi|||print gbcol count|9104
||jsr|6,systm|||get time|9105
||sbi|3,timsx|||get compilation time|9106
||mov|7,xr|21,=encm4||point to compilation time (msec)/|9107
||jsr|6,prtmi|||print message|9108
||add|3,lstlc|18,=num05||bump line count|9109
||bze|3,headp|6,inix0||no eject if nothing printed|9111
||jsr|6,prtpg|||eject printer|9112
||ejc|||||9114
|inix0|bgt|3,cswin|18,=iniln|6,inix1|skip if not default -in72 used|9120
||mov|3,cswin|18,=inils||else use default record length|9121
|inix1|jsr|6,systm|||get time again|9125
||sti|3,timsx|||store for end run processing|9126
||zer|3,gbcnt|||initialise collect count|9127
||jsr|6,sysbx|||call before starting execution|9128
||add|3,noxeq|3,cswex||add -noexecute flag|9129
||bnz|3,noxeq|6,inix2||jump if execution suppressed|9130
|iniy0|mnz|3,headp|||mark headers out regardless|9140
||zer|11,-(xs)|||set failure location on stack|9141
||mov|3,flptr|7,xs||save ptr to failure offset word|9142
||mov|7,xr|3,r_cod||load ptr to entry code block|9143
||mov|3,stage|18,=stgxt||set stage for execute time|9144
||mov|3,polcs|18,=num01||reset interface polling interval|9146
||mov|3,polct|18,=num01||reset interface polling interval|9147
||mov|3,pfnte|3,cmpsn||copy stmts compiled count in case|9151
||mov|3,pfdmp|3,kvpfl||start profiling if &profile set|9152
||jsr|6,systm|||time yet again|9153
||sti|3,pfstm||||9154
||jsr|6,stgcc|||compute stmgo countdown counters|9156
||bri|9,(xr)|||start xeq with first statement|9157
|inix2|zer|8,wa|||set abend value to zero|9162
||mov|8,wb|18,=nini9||set special code value|9170
||zer|7,xl|||no fcb chain|9171
||jsr|6,sysej|||end of job, exit to system|9172
||enp||||end procedure start|9173
|rstrt|prc|25,e|1,0||entry point|9177
||mov|7,xs|3,stbas||discard return|9178
||zer|7,xl|||clear xl|9179
||brn|6,iniy0|||resume execution|9180
||enp||||end procedure rstrt|9181
||ttl|27,s p i t b o l -- snobol4 operator routines||||9183
||ejc|||||9203
|o_add|ent||||entry point|9207
||jsr|6,arith|||fetch arithmetic operands|9209
||err|1,001|26,addition left operand is not numeric|||9210
||err|1,002|26,addition right operand is not numeric|||9211
||ppm|6,oadd1|||jump if real operands|9214
||adi|13,icval(xl)|||add right operand to left|9219
||ino|6,exint|||return integer if no overflow|9220
||erb|1,003|26,addition caused integer overflow|||9221
|oadd1|adr|13,rcval(xl)|||add right operand to left|9227
||rno|6,exrea|||return real if no overflow|9228
||erb|1,261|26,addition caused real overflow|||9229
||ejc|||||9231
|o_aff|ent||||entry point|9235
||mov|7,xr|10,(xs)+||load operand|9236
||jsr|6,gtnum|||convert to numeric|9237
||err|1,004|26,affirmation operand is not numeric|||9238
||mov|11,-(xs)|7,xr||result if converted to numeric|9239
||lcw|7,xr|||get next code word|9240
||bri|9,(xr)|||execute it|9241
||ejc|||||9242
|o_alt|ent||||entry point|9246
||mov|7,xr|10,(xs)+||load right operand|9247
||jsr|6,gtpat|||convert to pattern|9248
||err|1,005|26,alternation right operand is not pattern|||9249
|oalt1|mov|8,wb|22,=p_alt||set pcode for alternative node|9253
||jsr|6,pbild|||build alternative node|9254
||mov|7,xl|7,xr||save address of alternative node|9255
||mov|7,xr|10,(xs)+||load left operand|9256
||jsr|6,gtpat|||convert to pattern|9257
||err|1,006|26,alternation left operand is not pattern|||9258
||beq|7,xr|22,=p_alt|6,oalt2|jump if left arg is alternation|9259
||mov|13,pthen(xl)|7,xr||set left operand as successor|9260
||mov|11,-(xs)|7,xl||stack result|9261
||lcw|7,xr|||get next code word|9262
||bri|9,(xr)|||execute it|9263
|oalt2|mov|13,pthen(xl)|13,parm1(xr)||build the (b / c) node|9271
||mov|11,-(xs)|13,pthen(xr)||set a as new left arg|9272
||mov|7,xr|7,xl||set (b / c) as new right arg|9273
||brn|6,oalt1|||merge back to build a / (b / c)|9274
||ejc|||||9275
|o_amn|ent||||entry point|9279
||lcw|7,xr|||load number of subscripts|9280
||mov|8,wb|7,xr||set flag for by name|9281
||brn|6,arref|||jump to array reference routine|9282
||ejc|||||9283
|o_amv|ent||||entry point|9287
||lcw|7,xr|||load number of subscripts|9288
||zer|8,wb|||set flag for by value|9289
||brn|6,arref|||jump to array reference routine|9290
||ejc|||||9291
|o_aon|ent||||entry point|9295
||mov|7,xr|9,(xs)||load subscript value|9296
||mov|7,xl|13,num01(xs)||load array value|9297
||mov|8,wa|9,(xl)||load first word of array operand|9298
||beq|8,wa|22,=b_vct|6,oaon2|jump if vector reference|9299
||beq|8,wa|22,=b_tbt|6,oaon3|jump if table reference|9300
|oaon1|mov|7,xr|18,=num01||set number of subscripts to one|9304
||mov|8,wb|7,xr||set flag for by name|9305
||brn|6,arref|||jump to array reference routine|9306
|oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|use long routine if not integer|9310
||ldi|13,icval(xr)|||load integer subscript value|9311
||mfi|8,wa|6,exfal||copy as address int, fail if ovflo|9312
||bze|8,wa|6,exfal||fail if zero|9313
||add|8,wa|18,=vcvlb||compute offset in words|9314
||wtb|8,wa|||convert to bytes|9315
||mov|9,(xs)|8,wa||complete name on stack|9316
||blt|8,wa|13,vclen(xl)|6,oaon4|exit if subscript not too large|9317
||brn|6,exfal|||else fail|9318
|oaon3|mnz|8,wb|||set flag for name reference|9322
||jsr|6,tfind|||locate/create table element|9323
||ppm|6,exfal|||fail if access fails|9324
||mov|13,num01(xs)|7,xl||store name base on stack|9325
||mov|9,(xs)|8,wa||store name offset on stack|9326
|oaon4|lcw|7,xr|||result on stack, get code word|9330
||bri|9,(xr)|||execute next code word|9331
||ejc|||||9332
|o_aov|ent||||entry point|9336
||mov|7,xr|10,(xs)+||load subscript value|9337
||mov|7,xl|10,(xs)+||load array value|9338
||mov|8,wa|9,(xl)||load first word of array operand|9339
||beq|8,wa|22,=b_vct|6,oaov2|jump if vector reference|9340
||beq|8,wa|22,=b_tbt|6,oaov3|jump if table reference|9341
|oaov1|mov|11,-(xs)|7,xl||restack array value|9345
||mov|11,-(xs)|7,xr||restack subscript|9346
||mov|7,xr|18,=num01||set number of subscripts to one|9347
||zer|8,wb|||set flag for value call|9348
||brn|6,arref|||jump to array reference routine|9349
|oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|use long routine if not integer|9353
||ldi|13,icval(xr)|||load integer subscript value|9354
||mfi|8,wa|6,exfal||move as one word int, fail if ovflo|9355
||bze|8,wa|6,exfal||fail if zero|9356
||add|8,wa|18,=vcvlb||compute offset in words|9357
||wtb|8,wa|||convert to bytes|9358
||bge|8,wa|13,vclen(xl)|6,exfal|fail if subscript too large|9359
||jsr|6,acess|||access value|9360
||ppm|6,exfal|||fail if access fails|9361
||mov|11,-(xs)|7,xr||stack result|9362
||lcw|7,xr|||get next code word|9363
||bri|9,(xr)|||execute it|9364
|oaov3|zer|8,wb|||set flag for value reference|9368
||jsr|6,tfind|||call table search routine|9369
||ppm|6,exfal|||fail if access fails|9370
||mov|11,-(xs)|7,xr||stack result|9371
||lcw|7,xr|||get next code word|9372
||bri|9,(xr)|||execute it|9373
||ejc|||||9374
|o_ass|ent||||entry point|9378
|oass0|mov|8,wb|10,(xs)+||load value to be assigned|9382
||mov|8,wa|10,(xs)+||load name offset|9383
||mov|7,xl|9,(xs)||load name base|9384
||mov|9,(xs)|8,wb||store assigned value as result|9385
||jsr|6,asign|||perform assignment|9386
||ppm|6,exfal|||fail if assignment fails|9387
||lcw|7,xr|||result on stack, get code word|9388
||bri|9,(xr)|||execute next code word|9389
||ejc|||||9390
|o_cer|ent||||entry point|9394
||erb|1,007|26,compilation error encountered during execution|||9395
||ejc|||||9396
|o_cas|ent||||entry point|9400
||mov|8,wc|10,(xs)+||load name offset (parm2)|9401
||mov|7,xr|10,(xs)+||load name base (parm1)|9402
||mov|8,wb|22,=p_cas||set pcode for cursor assignment|9403
||jsr|6,pbild|||build node|9404
||mov|11,-(xs)|7,xr||stack result|9405
||lcw|7,xr|||get next code word|9406
||bri|9,(xr)|||execute it|9407
||ejc|||||9408
|o_cnc|ent||||entry point|9412
||mov|7,xr|9,(xs)||load right argument|9413
||beq|7,xr|21,=nulls|6,ocnc3|jump if right arg is null|9414
||mov|7,xl|12,1(xs)||load left argument|9415
||beq|7,xl|21,=nulls|6,ocnc4|jump if left argument is null|9416
||mov|8,wa|22,=b_scl||get constant to test for string|9417
||bne|8,wa|9,(xl)|6,ocnc2|jump if left arg not a string|9418
||bne|8,wa|9,(xr)|6,ocnc2|jump if right arg not a string|9419
|ocnc1|mov|8,wa|13,sclen(xl)||load left argument length|9423
||add|8,wa|13,sclen(xr)||compute result length|9424
||jsr|6,alocs|||allocate scblk for result|9425
||mov|12,1(xs)|7,xr||store result ptr over left argument|9426
||psc|7,xr|||prepare to store chars of result|9427
||mov|8,wa|13,sclen(xl)||get number of chars in left arg|9428
||plc|7,xl|||prepare to load left arg chars|9429
||mvc||||move characters of left argument|9430
||mov|7,xl|10,(xs)+||load right arg pointer, pop stack|9431
||mov|8,wa|13,sclen(xl)||load number of chars in right arg|9432
||plc|7,xl|||prepare to load right arg chars|9433
||mvc||||move characters of right argument|9434
||zer|7,xl|||clear garbage value in xl|9435
||lcw|7,xr|||result on stack, get code word|9436
||bri|9,(xr)|||execute next code word|9437
|ocnc2|jsr|6,gtstg|||convert right arg to string|9441
||ppm|6,ocnc5|||jump if right arg is not string|9442
||mov|7,xl|7,xr||save right arg ptr|9443
||jsr|6,gtstg|||convert left arg to string|9444
||ppm|6,ocnc6|||jump if left arg is not a string|9445
||mov|11,-(xs)|7,xr||stack left argument|9446
||mov|11,-(xs)|7,xl||stack right argument|9447
||mov|7,xl|7,xr||move left arg to proper reg|9448
||mov|7,xr|9,(xs)||move right arg to proper reg|9449
||brn|6,ocnc1|||merge back to concatenate strings|9450
||ejc|||||9451
|ocnc3|ica|7,xs|||remove right arg from stack|9457
||lcw|7,xr|||left argument on stack|9458
||bri|9,(xr)|||execute next code word|9459
|ocnc4|ica|7,xs|||unstack one argument|9463
||mov|9,(xs)|7,xr||store right argument|9464
||lcw|7,xr|||result on stack, get code word|9465
||bri|9,(xr)|||execute next code word|9466
|ocnc5|mov|7,xl|7,xr||move right argument ptr|9470
||mov|7,xr|10,(xs)+||load left arg pointer|9471
|ocnc6|jsr|6,gtpat|||convert left arg to pattern|9475
||err|1,008|26,concatenation left operand is not a string or pattern|||9476
||mov|11,-(xs)|7,xr||save result on stack|9477
||mov|7,xr|7,xl||point to right operand|9478
||jsr|6,gtpat|||convert to pattern|9479
||err|1,009|26,concatenation right operand is not a string or pattern|||9480
||mov|7,xl|7,xr||move for pconc|9481
||mov|7,xr|10,(xs)+||reload left operand ptr|9482
||jsr|6,pconc|||concatenate patterns|9483
||mov|11,-(xs)|7,xr||stack result|9484
||lcw|7,xr|||get next code word|9485
||bri|9,(xr)|||execute it|9486
||ejc|||||9487
|o_com|ent||||entry point|9491
||mov|7,xr|10,(xs)+||load operand|9492
||mov|8,wa|9,(xr)||load type word|9493
|ocom1|beq|8,wa|22,=b_icl|6,ocom2|jump if integer|9497
||beq|8,wa|22,=b_rcl|6,ocom3|jump if real|9500
||jsr|6,gtnum|||else convert to numeric|9502
||err|1,010|26,negation operand is not numeric|||9503
||brn|6,ocom1|||back to check cases|9504
|ocom2|ldi|13,icval(xr)|||load integer value|9508
||ngi||||negate|9509
||ino|6,exint|||return integer if no overflow|9510
||erb|1,011|26,negation caused integer overflow|||9511
|ocom3|ldr|13,rcval(xr)|||load real value|9517
||ngr||||negate|9518
||brn|6,exrea|||return real result|9519
||ejc|||||9521
|o_dvd|ent||||entry point|9525
||jsr|6,arith|||fetch arithmetic operands|9526
||err|1,012|26,division left operand is not numeric|||9527
||err|1,013|26,division right operand is not numeric|||9528
||ppm|6,odvd2|||jump if real operands|9531
||dvi|13,icval(xl)|||divide left operand by right|9536
||ino|6,exint|||result ok if no overflow|9537
||erb|1,014|26,division caused integer overflow|||9538
|odvd2|dvr|13,rcval(xl)|||divide left operand by right|9544
||rno|6,exrea|||return real if no overflow|9545
||erb|1,262|26,division caused real overflow|||9546
||ejc|||||9548
|o_exp|ent||||entry point|9552
||mov|7,xr|10,(xs)+||load exponent|9553
||jsr|6,gtnum|||convert to number|9554
||err|1,015|26,exponentiation right operand is not numeric|||9555
||mov|7,xl|7,xr||move exponent to xl|9556
||mov|7,xr|10,(xs)+||load base|9557
||jsr|6,gtnum|||convert to numeric|9558
||err|1,016|26,exponentiation left operand is not numeric|||9559
||beq|9,(xl)|22,=b_rcl|6,oexp7|jump if real exponent|9562
||ldi|13,icval(xl)|||load exponent|9564
||ilt|6,oex12|||jump if negative exponent|9565
||beq|8,wa|22,=b_rcl|6,oexp3|jump if base is real|9568
||mfi|8,wa|6,oexp2||convert exponent to 1 word integer|9573
||lct|8,wa|8,wa||set loop counter|9574
||ldi|13,icval(xr)|||load base as initial value|9575
||bnz|8,wa|6,oexp1||jump into loop if non-zero exponent|9576
||ieq|6,oexp4|||error if 0**0|9577
||ldi|4,intv1|||nonzero**0|9578
||brn|6,exint|||give one as result for nonzero**0|9579
|oex13|mli|13,icval(xr)|||multiply by base|9583
||iov|6,oexp2|||jump if overflow|9584
|oexp1|bct|8,wa|6,oex13||loop if more to go|9585
||brn|6,exint|||else return integer result|9586
|oexp2|erb|1,017|26,exponentiation caused integer overflow|||9590
||ejc|||||9591
|oexp3|mfi|8,wa|6,oexp6||convert exponent to one word|9599
||lct|8,wa|8,wa||set loop counter|9600
||ldr|13,rcval(xr)|||load base as initial value|9601
||bnz|8,wa|6,oexp5||jump into loop if non-zero exponent|9602
||req|6,oexp4|||error if 0.0**0|9603
||ldr|4,reav1|||nonzero**0|9604
||brn|6,exrea|||return 1.0 if nonzero**zero|9605
|oexp4|erb|1,018|26,exponentiation result is undefined|||9610
|oex14|mlr|13,rcval(xr)|||multiply by base|9616
||rov|6,oexp6|||jump if overflow|9617
|oexp5|bct|8,wa|6,oex14||loop till computation complete|9618
||brn|6,exrea|||then return real result|9619
|oexp6|erb|1,266|26,exponentiation caused real overflow|||9623
|oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|jump if base real|9628
||ldi|13,icval(xr)|||load integer base|9629
||itr||||convert to real|9630
||jsr|6,rcbld|||create real in (xr)|9631
|oexp8|zer|8,wb|||set positive result flag|9636
||ldr|13,rcval(xr)|||load base to ra|9637
||rne|6,oexp9|||jump if base non-zero|9638
||ldr|13,rcval(xl)|||base is zero.  check exponent|9639
||req|6,oexp4|||jump if 0.0 ** 0.0|9640
||ldr|4,reav0|||0.0 to non-zero exponent yields 0.0|9641
||brn|6,exrea|||return zero result|9642
|oexp9|rgt|6,oex10|||jump if base gt 0.0|9648
||ngr||||make base positive|9649
||jsr|6,rcbld|||create positive base in (xr)|9650
||ldr|13,rcval(xl)|||examine exponent|9651
||chp||||chop to integral value|9652
||rti|6,oexp6|||convert to integer, br if too large|9653
||sbr|13,rcval(xl)|||chop(exponent) - exponent|9654
||rne|6,oex11|||non-integral power with neg base|9655
||mfi|8,wb|||record even/odd exponent|9656
||anb|8,wb|4,bits1||odd exponent yields negative result|9657
||ldr|13,rcval(xr)|||restore base to ra|9658
|oex10|lnf||||log of base|9662
||rov|6,oexp6|||too large|9663
||mlr|13,rcval(xl)|||times exponent|9664
||rov|6,oexp6|||too large|9665
||etx||||e ** (exponent * ln(base))|9666
||rov|6,oexp6|||too large|9667
||bze|8,wb|6,exrea||if no sign fixup required|9668
||ngr||||negative result needed|9669
||brn|6,exrea||||9670
|oex11|erb|1,311|26,exponentiation of negative base to non-integral power|||9674
|oex12|mov|11,-(xs)|7,xr||stack base|9683
||itr||||convert to real exponent|9684
||jsr|6,rcbld|||real negative exponent in (xr)|9685
||mov|7,xl|7,xr||put exponent in xl|9686
||mov|7,xr|10,(xs)+||restore base value|9687
||brn|6,oexp7|||process real exponent|9688
||ejc|||||9692
|o_fex|ent||||entry point|9700
||brn|6,evlx6|||jump to failure loc in evalx|9701
||ejc|||||9702
|o_fif|ent||||entry point|9706
||erb|1,020|26,goto evaluation failure|||9707
||ejc|||||9708
|o_fnc|ent||||entry point|9712
||lcw|8,wa|||load number of arguments|9713
||lcw|7,xr|||load function vrblk pointer|9714
||mov|7,xl|13,vrfnc(xr)||load function pointer|9715
||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9716
||bri|9,(xl)|||jump to function if arg count ok|9717
||ejc|||||9718
|o_fne|ent||||entry point|9722
||lcw|8,wa|||get next code word|9723
||bne|8,wa|21,=ornm_|6,ofne1|fail if not evaluating expression|9724
||bze|13,num02(xs)|6,evlx3||ok if expr. was wanted by value|9725
|ofne1|erb|1,021|26,function called by name returned a value|||9729
||ejc|||||9730
|o_fns|ent||||entry point|9734
||lcw|7,xr|||load function vrblk pointer|9735
||mov|8,wa|18,=num01||set number of arguments to one|9736
||mov|7,xl|13,vrfnc(xr)||load function pointer|9737
||bne|8,wa|13,fargs(xl)|6,cfunc|use central routine if wrong num|9738
||bri|9,(xl)|||jump to function if arg count ok|9739
||ejc|||||9740
|o_fun|ent||||entry point|9743
||erb|1,022|26,undefined function called|||9744
||ejc|||||9745
|o_goc|ent||||entry point|9749
||mov|7,xr|13,num01(xs)||load name base pointer|9750
||bhi|7,xr|3,state|6,ogoc1|jump if not natural variable|9751
||add|7,xr|19,*vrtra||else point to vrtra field|9752
||bri|9,(xr)|||and jump through it|9753
|ogoc1|erb|1,023|26,goto operand is not a natural variable|||9757
||ejc|||||9758
|o_god|ent||||entry point|9762
||mov|7,xr|9,(xs)||load operand|9763
||mov|8,wa|9,(xr)||load first word|9764
||beq|8,wa|22,=b_cds|6,bcds0|jump if code block to code routine|9765
||beq|8,wa|22,=b_cdc|6,bcdc0|jump if code block to code routine|9766
||erb|1,024|26,goto operand in direct goto is not code|||9767
||ejc|||||9768
|o_gof|ent||||entry point|9775
||mov|7,xr|3,flptr||point to fail offset on stack|9776
||ica|9,(xr)|||point failure to o_fif word|9777
||icp||||point to next code word|9778
||lcw|7,xr|||fetch next code word|9779
||bri|9,(xr)|||execute it|9780
||ejc|||||9781
|o_ima|ent||||entry point|9789
||mov|8,wb|22,=p_imc||set pcode for last node|9790
||mov|8,wc|10,(xs)+||pop name offset (parm2)|9791
||mov|7,xr|10,(xs)+||pop name base (parm1)|9792
||jsr|6,pbild|||build p_imc node|9793
||mov|7,xl|7,xr||save ptr to node|9794
||mov|7,xr|9,(xs)||load left argument|9795
||jsr|6,gtpat|||convert to pattern|9796
||err|1,025|26,immediate assignment left operand is not pattern|||9797
||mov|9,(xs)|7,xr||save ptr to left operand pattern|9798
||mov|8,wb|22,=p_ima||set pcode for first node|9799
||jsr|6,pbild|||build p_ima node|9800
||mov|13,pthen(xr)|10,(xs)+||set left operand as p_ima successor|9801
||jsr|6,pconc|||concatenate to form final pattern|9802
||mov|11,-(xs)|7,xr||stack result|9803
||lcw|7,xr|||get next code word|9804
||bri|9,(xr)|||execute it|9805
||ejc|||||9806
|o_inn|ent||||entry point|9810
||mnz|8,wb|||set flag for result by name|9811
||brn|6,indir|||jump to common routine|9812
||ejc|||||9813
|o_int|ent||||entry point|9817
||mov|9,(xs)|21,=nulls||replace operand with null|9818
||lcw|7,xr|||get next code word|9819
||bri|9,(xr)|||execute next code word|9820
||ejc|||||9821
|o_inv|ent||||entry point|9825
||zer|8,wb|||set flag for by value|9826
||brn|6,indir|||jump to common routine|9827
||ejc|||||9828
|o_kwn|ent||||entry point|9832
||jsr|6,kwnam|||get keyword name|9833
||brn|6,exnam|||exit with result name|9834
||ejc|||||9835
|o_kwv|ent||||entry point|9839
||jsr|6,kwnam|||get keyword name|9840
||mov|3,dnamp|7,xr||delete kvblk|9841
||jsr|6,acess|||access value|9842
||ppm|6,exnul|||dummy (unused) failure return|9843
||mov|11,-(xs)|7,xr||stack result|9844
||lcw|7,xr|||get next code word|9845
||bri|9,(xr)|||execute it|9846
||ejc|||||9847
|o_lex|ent||||entry point|9851
||mov|8,wa|19,*evsi_||set size of evblk|9852
||jsr|6,alloc|||allocate space for evblk|9853
||mov|9,(xr)|22,=b_evt||set type word|9854
||mov|13,evvar(xr)|21,=trbev||set dummy trblk pointer|9855
||lcw|8,wa|||load exblk pointer|9856
||mov|13,evexp(xr)|8,wa||set exblk pointer|9857
||mov|7,xl|7,xr||move name base to proper reg|9858
||mov|8,wa|19,*evvar||set name offset = zero|9859
||brn|6,exnam|||exit with name in (xl,wa)|9860
||ejc|||||9861
|o_lpt|ent||||entry point|9865
||lcw|7,xr|||load pattern pointer|9866
||mov|11,-(xs)|7,xr||stack result|9867
||lcw|7,xr|||get next code word|9868
||bri|9,(xr)|||execute it|9869
||ejc|||||9870
|o_lvn|ent||||entry point|9874
||lcw|8,wa|||load vrblk pointer|9875
||mov|11,-(xs)|8,wa||stack vrblk ptr (name base)|9876
||mov|11,-(xs)|19,*vrval||stack name offset|9877
||lcw|7,xr|||get next code word|9878
||bri|9,(xr)|||execute next code word|9879
||ejc|||||9880
|o_mlt|ent||||entry point|9884
||jsr|6,arith|||fetch arithmetic operands|9885
||err|1,026|26,multiplication left operand is not numeric|||9886
||err|1,027|26,multiplication right operand is not numeric|||9887
||ppm|6,omlt1|||jump if real operands|9890
||mli|13,icval(xl)|||multiply left operand by right|9895
||ino|6,exint|||return integer if no overflow|9896
||erb|1,028|26,multiplication caused integer overflow|||9897
|omlt1|mlr|13,rcval(xl)|||multiply left operand by right|9903
||rno|6,exrea|||return real if no overflow|9904
||erb|1,263|26,multiplication caused real overflow|||9905
||ejc|||||9907
|o_nam|ent||||entry point|9911
||mov|8,wa|19,*nmsi_||set length of nmblk|9912
||jsr|6,alloc|||allocate nmblk|9913
||mov|9,(xr)|22,=b_nml||set name block code|9914
||mov|13,nmofs(xr)|10,(xs)+||set name offset from operand|9915
||mov|13,nmbas(xr)|10,(xs)+||set name base from operand|9916
||mov|11,-(xs)|7,xr||stack result|9917
||lcw|7,xr|||get next code word|9918
||bri|9,(xr)|||execute it|9919
||ejc|||||9920
|o_nta|ent||||entry point|9926
||lcw|8,wa|||load new failure offset|9927
||mov|11,-(xs)|3,flptr||stack old failure pointer|9928
||mov|11,-(xs)|8,wa||stack new failure offset|9929
||mov|3,flptr|7,xs||set new failure pointer|9930
||lcw|7,xr|||get next code word|9931
||bri|9,(xr)|||execute next code word|9932
|o_ntb|ent||||entry point|9936
||mov|3,flptr|13,num02(xs)||restore old failure pointer|9937
||brn|6,exfal|||and fail|9938
|o_ntc|ent||||entry point|9942
||ica|7,xs|||pop failure offset|9943
||mov|3,flptr|10,(xs)+||restore old failure pointer|9944
||brn|6,exnul|||exit giving null result|9945
||ejc|||||9946
|o_oun|ent||||entry point|9950
||erb|1,029|26,undefined operator referenced|||9951
||ejc|||||9952
|o_pas|ent||||entry point|9960
||mov|8,wb|22,=p_pac||load pcode for p_pac node|9961
||mov|8,wc|10,(xs)+||load name offset (parm2)|9962
||mov|7,xr|10,(xs)+||load name base (parm1)|9963
||jsr|6,pbild|||build p_pac node|9964
||mov|7,xl|7,xr||save ptr to node|9965
||mov|7,xr|9,(xs)||load left operand|9966
||jsr|6,gtpat|||convert to pattern|9967
||err|1,030|26,pattern assignment left operand is not pattern|||9968
||mov|9,(xs)|7,xr||save ptr to left operand pattern|9969
||mov|8,wb|22,=p_paa||set pcode for p_paa node|9970
||jsr|6,pbild|||build p_paa node|9971
||mov|13,pthen(xr)|10,(xs)+||set left operand as p_paa successor|9972
||jsr|6,pconc|||concatenate to form final pattern|9973
||mov|11,-(xs)|7,xr||stack result|9974
||lcw|7,xr|||get next code word|9975
||bri|9,(xr)|||execute it|9976
||ejc|||||9977
|o_pmn|ent||||entry point|9981
||zer|8,wb|||set type code for match by name|9982
||brn|6,match|||jump to routine to start match|9983
||ejc|||||9984
|o_pms|ent||||entry point|9992
||mov|8,wb|18,=num02||set flag for statement to match|9993
||brn|6,match|||jump to routine to start match|9994
||ejc|||||9995
|o_pmv|ent||||entry point|9999
||mov|8,wb|18,=num01||set type code for value match|10000
||brn|6,match|||jump to routine to start match|10001
||ejc|||||10002
|o_pop|ent||||entry point|10006
||ica|7,xs|||pop top stack entry|10007
||lcw|7,xr|||get next code word|10008
||bri|9,(xr)|||execute next code word|10009
||ejc|||||10010
|o_stp|ent||||entry point|10014
||brn|6,lend0|||jump to end circuit|10015
||ejc|||||10016
|o_rnm|ent||||entry point|10023
||brn|6,evlx4|||return to evalx procedure|10024
||ejc|||||10025
|o_rpl|ent||||entry point|10039
||jsr|6,gtstg|||convert replacement val to string|10040
||err|1,031|26,pattern replacement right operand is not a string|||10041
||mov|7,xl|9,(xs)||load subject string pointer|10045
||add|8,wa|13,sclen(xl)||add subject string length|10050
||add|8,wa|13,num02(xs)||add starting cursor|10051
||sub|8,wa|13,num01(xs)||minus final cursor = total length|10052
||bze|8,wa|6,orpl3||jump if result is null|10053
||mov|11,-(xs)|7,xr||restack replacement string|10054
||jsr|6,alocs|||allocate scblk for result|10055
||mov|8,wa|13,num03(xs)||get initial cursor (part 1 len)|10056
||mov|13,num03(xs)|7,xr||stack result pointer|10057
||psc|7,xr|||point to characters of result|10058
||bze|8,wa|6,orpl1||jump if first part is null|10062
||mov|7,xl|13,num01(xs)||else point to subject string|10063
||plc|7,xl|||point to subject string chars|10064
||mvc||||move first part to result|10065
||ejc|||||10066
|orpl1|mov|7,xl|10,(xs)+||load replacement string, pop|10071
||mov|8,wa|13,sclen(xl)||load length|10072
||bze|8,wa|6,orpl2||jump if null replacement|10073
||plc|7,xl|||else point to chars of replacement|10074
||mvc||||move in chars (part 2)|10075
|orpl2|mov|7,xl|10,(xs)+||load subject string pointer, pop|10079
||mov|8,wc|10,(xs)+||load final cursor, pop|10080
||mov|8,wa|13,sclen(xl)||load subject string length|10081
||sub|8,wa|8,wc||minus final cursor = part 3 length|10082
||bze|8,wa|6,oass0||jump to assign if part 3 is null|10083
||plc|7,xl|8,wc||else point to last part of string|10084
||mvc||||move part 3 to result|10085
||brn|6,oass0|||jump to perform assignment|10086
|orpl3|add|7,xs|19,*num02||pop subject str ptr, final cursor|10090
||mov|9,(xs)|21,=nulls||set null result|10091
||brn|6,oass0|||jump to assign null value|10092
||ejc|||||10111
|o_rvl|ent||||entry point|10119
||brn|6,evlx3|||return to evalx procedure|10120
||ejc|||||10121
|o_sla|ent||||entry point|10127
||lcw|8,wa|||load new failure offset|10128
||mov|11,-(xs)|3,flptr||stack old failure pointer|10129
||mov|11,-(xs)|8,wa||stack new failure offset|10130
||mov|3,flptr|7,xs||set new failure pointer|10131
||lcw|7,xr|||get next code word|10132
||bri|9,(xr)|||execute next code word|10133
|o_slb|ent||||entry point|10137
||mov|7,xr|10,(xs)+||load result|10138
||ica|7,xs|||pop fail offset|10139
||mov|3,flptr|9,(xs)||restore old failure pointer|10140
||mov|9,(xs)|7,xr||restack result|10141
||lcw|8,wa|||load new code offset|10142
||add|8,wa|3,r_cod||point to absolute code location|10143
||lcp|8,wa|||set new code pointer|10144
||lcw|7,xr|||get next code word|10145
||bri|9,(xr)|||execute next code word|10146
|o_slc|ent||||entry point|10150
||lcw|8,wa|||load new fail offset|10151
||mov|9,(xs)|8,wa||store new fail offset|10152
||lcw|7,xr|||get next code word|10153
||bri|9,(xr)|||execute next code word|10154
|o_sld|ent||||entry point|10158
||ica|7,xs|||pop failure offset|10159
||mov|3,flptr|10,(xs)+||restore old failure pointer|10160
||lcw|7,xr|||get next code word|10161
||bri|9,(xr)|||execute next code word|10162
||ejc|||||10163
|o_sub|ent||||entry point|10167
||jsr|6,arith|||fetch arithmetic operands|10168
||err|1,032|26,subtraction left operand is not numeric|||10169
||err|1,033|26,subtraction right operand is not numeric|||10170
||ppm|6,osub1|||jump if real operands|10173
||sbi|13,icval(xl)|||subtract right operand from left|10178
||ino|6,exint|||return integer if no overflow|10179
||erb|1,034|26,subtraction caused integer overflow|||10180
|osub1|sbr|13,rcval(xl)|||subtract right operand from left|10186
||rno|6,exrea|||return real if no overflow|10187
||erb|1,264|26,subtraction caused real overflow|||10188
||ejc|||||10190
|o_txr|ent||||entry point|10194
||brn|6,trxq1|||jump into trxeq procedure|10195
||ejc|||||10196
|o_unf|ent||||entry point|10206
||erb|1,035|26,unexpected failure in -nofail mode|||10207
||ttl|27,s p i t b o l -- block action routines||||10208
|b_aaa|ent|2,bl__i|||entry point of first block routine|10253
||ejc|||||10254
|b_exl|ent|2,bl_ex|||entry point (exblk)|10263
||mov|11,-(xs)|7,xr||stack result|10264
||lcw|7,xr|||get next code word|10265
||bri|9,(xr)|||execute it|10266
||ejc|||||10267
|b_sel|ent|2,bl_se|||entry point (seblk)|10274
||mov|11,-(xs)|7,xr||stack result|10275
||lcw|7,xr|||get next code word|10276
||bri|9,(xr)|||execute it|10277
|b_e__|ent|2,bl__i|||entry point|10281
||ejc|||||10282
|b_trt|ent|2,bl_tr|||entry point (trblk)|10288
|b_t__|ent|2,bl__i|||end of trblk,seblk,exblk entries|10292
||ejc|||||10293
|b_art|ent|2,bl_ar|||entry point (arblk)|10299
||ejc|||||10300
|b_bct|ent|2,bl_bc|||entry point (bcblk)|10308
||ejc|||||10309
|b_bft|ent|2,bl_bf|||entry point (bfblk)|10317
||ejc|||||10318
|b_cct|ent|2,bl_cc|||entry point (ccblk)|10324
||ejc|||||10325
|b_cdc|ent|2,bl_cd|||entry point (cdblk)|10336
|bcdc0|mov|7,xs|3,flptr||pop garbage off stack|10337
||mov|9,(xs)|13,cdfal(xr)||set failure offset|10338
||brn|6,stmgo|||enter stmt|10339
||ejc|||||10340
|b_cds|ent|2,bl_cd|||entry point (cdblk)|10348
|bcds0|mov|7,xs|3,flptr||pop garbage off stack|10349
||mov|9,(xs)|19,*cdfal||set failure offset|10350
||brn|6,stmgo|||enter stmt|10351
||ejc|||||10352
|b_cmt|ent|2,bl_cm|||entry point (cmblk)|10358
||ejc|||||10359
|b_ctt|ent|2,bl_ct|||entry point (ctblk)|10365
||ejc|||||10366
|b_dfc|ent|2,bl_df|||entry point|10375
||mov|8,wa|13,dfpdl(xl)||load length of pdblk|10376
||jsr|6,alloc|||allocate pdblk|10377
||mov|9,(xr)|22,=b_pdt||store type word|10378
||mov|13,pddfp(xr)|7,xl||store dfblk pointer|10379
||mov|8,wc|7,xr||save pointer to pdblk|10380
||add|7,xr|8,wa||point past pdblk|10381
||lct|8,wa|13,fargs(xl)||set to count fields|10382
|bdfc1|mov|11,-(xr)|10,(xs)+||move a field value|10386
||bct|8,wa|6,bdfc1||loop till all moved|10387
||mov|7,xr|8,wc||recall pointer to pdblk|10388
||brn|6,exsid|||exit setting id field|10389
||ejc|||||10390
|b_efc|ent|2,bl_ef|||entry point (efblk)|10399
||mov|8,wc|13,fargs(xl)||load number of arguments|10402
||wtb|8,wc|||convert to offset|10403
||mov|11,-(xs)|7,xl||save pointer to efblk|10404
||mov|7,xt|7,xs||copy pointer to arguments|10405
|befc1|ica|7,xt|||point to next entry|10409
||mov|7,xr|9,(xs)||load pointer to efblk|10410
||dca|8,wc|||decrement eftar offset|10411
||add|7,xr|8,wc||point to next eftar entry|10412
||mov|7,xr|13,eftar(xr)||load eftar entry|10413
||bsw|7,xr|1,5||switch on type|10422
||iff|1,0|6,befc7||no conversion needed|10440
||iff|1,1|6,befc2||string|10440
||iff|1,2|6,befc3||integer|10440
||iff|1,3|6,befc4||real|10440
||iff|1,4|6,beff1||file|10440
||esw||||end of switch on type|10440
|beff1|mov|11,-(xs)|7,xt||save entry pointer|10445
||mov|3,befof|8,wc||save offset|10446
||mov|11,-(xs)|9,(xt)||stack arg pointer|10447
||jsr|6,iofcb|||convert to fcb|10448
||err|1,298|26,external function argument is not file|||10449
||err|1,298|26,external function argument is not file|||10450
||err|1,298|26,external function argument is not file|||10451
||mov|7,xr|8,wa||point to fcb|10452
||mov|7,xt|10,(xs)+||reload entry pointer|10453
||brn|6,befc5|||jump to merge|10454
|befc2|mov|11,-(xs)|9,(xt)||stack arg ptr|10459
||jsr|6,gtstg|||convert argument to string|10460
||err|1,039|26,external function argument is not a string|||10461
||brn|6,befc6|||jump to merge|10462
||ejc|||||10463
|befc3|mov|7,xr|9,(xt)||load next argument|10469
||mov|3,befof|8,wc||save offset|10470
||jsr|6,gtint|||convert to integer|10471
||err|1,040|26,external function argument is not integer|||10472
||brn|6,befc5|||merge with real case|10475
|befc4|mov|7,xr|9,(xt)||load next argument|10479
||mov|3,befof|8,wc||save offset|10480
||jsr|6,gtrea|||convert to real|10481
||err|1,265|26,external function argument is not real|||10482
|befc5|mov|8,wc|3,befof||restore offset|10487
|befc6|mov|9,(xt)|7,xr||store converted result|10491
|befc7|bnz|8,wc|6,befc1||loop back if more to go|10495
||mov|7,xl|10,(xs)+||restore efblk pointer|10499
||mov|8,wa|13,fargs(xl)||get number of args|10500
||jsr|6,sysex|||call routine to call external fnc|10501
||ppm|6,exfal|||fail if failure|10502
||err|1,327|26,calling external function - not found|||10503
||err|1,326|26,calling external function - bad argument type|||10504
||wtb|8,wa|||convert number of args to bytes|10506
||add|7,xs|8,wa||remove arguments from stack|10507
||ejc|||||10509
||mov|8,wb|13,efrsl(xl)||get result type id|10517
||bnz|8,wb|6,befa8||branch if not unconverted|10518
||bne|9,(xr)|22,=b_scl|6,befc8|jump if not a string|10519
||bze|13,sclen(xr)|6,exnul||return null if null|10520
|befa8|bne|8,wb|18,=num01|6,befc8|jump if not a string|10524
||bze|13,sclen(xr)|6,exnul||return null if null|10525
|befc8|blt|7,xr|3,dnamb|6,befc9|jump if not in dynamic storage|10529
||ble|7,xr|3,dnamp|6,exixr|return result if already dynamic|10530
|befc9|mov|8,wa|9,(xr)||get possible type word|10534
||bze|8,wb|6,bef11||jump if unconverted result|10535
||mov|8,wa|22,=b_scl||string|10536
||beq|8,wb|18,=num01|6,bef10|yes jump|10537
||mov|8,wa|22,=b_icl||integer|10538
||beq|8,wb|18,=num02|6,bef10|yes jump|10539
||mov|8,wa|22,=b_rcl||real|10542
|bef10|mov|9,(xr)|8,wa||stored before copying to dynamic|10547
|bef11|beq|9,(xr)|22,=b_scl|6,bef12|branch if string result|10551
||jsr|6,blkln|||get length of block|10552
||mov|7,xl|7,xr||copy address of old block|10553
||jsr|6,alloc|||allocate dynamic block same size|10554
||mov|11,-(xs)|7,xr||set pointer to new block as result|10555
||mvw||||copy old block to dynamic block|10556
||zer|7,xl|||clear garbage value|10557
||lcw|7,xr|||get next code word|10558
||bri|9,(xr)|||execute next code word|10559
|bef12|mov|7,xl|7,xr||save source string pointer|10565
||mov|8,wa|13,sclen(xr)||fetch string length|10566
||bze|8,wa|6,exnul||return null string if length zero|10567
||jsr|6,alocs|||allocate space for string|10568
||mov|11,-(xs)|7,xr||save as result pointer|10569
||psc|7,xr|||prepare to store chars of result|10570
||plc|7,xl|||point to chars in source string|10571
||mov|8,wa|8,wc||number of characters to copy|10572
||mvc||||move characters to result string|10573
||zer|7,xl|||clear garbage value|10574
||lcw|7,xr|||get next code word|10575
||bri|9,(xr)|||execute next code word|10576
||ejc|||||10578
|b_evt|ent|2,bl_ev|||entry point (evblk)|10584
||ejc|||||10585
|b_ffc|ent|2,bl_ff|||entry point (ffblk)|10594
||mov|7,xr|7,xl||copy ffblk pointer|10595
||lcw|8,wc|||load next code word|10596
||mov|7,xl|9,(xs)||load pdblk pointer|10597
||bne|9,(xl)|22,=b_pdt|6,bffc2|jump if not pdblk at all|10598
||mov|8,wa|13,pddfp(xl)||load dfblk pointer from pdblk|10599
|bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|jump if this is the correct ffblk|10603
||mov|7,xr|13,ffnxt(xr)||else link to next ffblk on chain|10604
||bnz|7,xr|6,bffc1||loop back if another entry to check|10605
|bffc2|erb|1,041|26,field function argument is wrong datatype|||10609
||ejc|||||10610
|bffc3|mov|8,wa|13,ffofs(xr)||load field offset|10616
||beq|8,wc|21,=ofne_|6,bffc5|jump if called by name|10617
||add|7,xl|8,wa||else point to value field|10618
||mov|7,xr|9,(xl)||load value|10619
||bne|9,(xr)|22,=b_trt|6,bffc4|jump if not trapped|10620
||sub|7,xl|8,wa||else restore name base,offset|10621
||mov|9,(xs)|8,wc||save next code word over pdblk ptr|10622
||jsr|6,acess|||access value|10623
||ppm|6,exfal|||fail if access fails|10624
||mov|8,wc|9,(xs)||restore next code word|10625
|bffc4|mov|9,(xs)|7,xr||store value on stack (over pdblk)|10629
||mov|7,xr|8,wc||copy next code word|10630
||mov|7,xl|9,(xr)||load entry address|10631
||bri|7,xl|||jump to routine for next code word|10632
|bffc5|mov|11,-(xs)|8,wa||store name offset (base is set)|10636
||lcw|7,xr|||get next code word|10637
||bri|9,(xr)|||execute next code word|10638
||ejc|||||10639
|b_icl|ent|2,bl_ic|||entry point (icblk)|10648
||mov|11,-(xs)|7,xr||stack result|10649
||lcw|7,xr|||get next code word|10650
||bri|9,(xr)|||execute it|10651
||ejc|||||10652
|b_kvt|ent|2,bl_kv|||entry point (kvblk)|10658
||ejc|||||10659
|b_nml|ent|2,bl_nm|||entry point (nmblk)|10670
||mov|11,-(xs)|7,xr||stack result|10671
||lcw|7,xr|||get next code word|10672
||bri|9,(xr)|||execute it|10673
||ejc|||||10674
|b_pdt|ent|2,bl_pd|||entry point (pdblk)|10680
||ejc|||||10681
|b_pfc|ent|2,bl_pf|||entry point (pfblk)|10707
||mov|3,bpfpf|7,xl||save pfblk ptr (need not be reloc)|10708
||mov|7,xr|7,xl||copy for the moment|10709
||mov|7,xl|13,pfvbl(xr)||point to vrblk for function|10710
|bpf01|mov|8,wb|7,xl||save pointer|10714
||mov|7,xl|13,vrval(xl)||load value|10715
||beq|9,(xl)|22,=b_trt|6,bpf01|loop if trblk|10716
||mov|3,bpfsv|7,xl||save old value|10720
||mov|7,xl|8,wb||point back to block with value|10721
||mov|13,vrval(xl)|21,=nulls||set value to null|10722
||mov|8,wa|13,fargs(xr)||load number of arguments|10723
||add|7,xr|19,*pfarg||point to pfarg entries|10724
||bze|8,wa|6,bpf04||jump if no arguments|10725
||mov|7,xt|7,xs||ptr to last arg|10726
||wtb|8,wa|||convert no. of args to bytes offset|10727
||add|7,xt|8,wa||point before first arg|10728
||mov|3,bpfxt|7,xt||remember arg pointer|10729
||ejc|||||10730
|bpf02|mov|7,xl|10,(xr)+||load vrblk ptr for next argument|10736
|bpf03|mov|8,wc|7,xl||save pointer|10740
||mov|7,xl|13,vrval(xl)||load next value|10741
||beq|9,(xl)|22,=b_trt|6,bpf03|loop back if trblk|10742
||mov|8,wa|7,xl||keep old value|10746
||mov|7,xt|3,bpfxt||point before next stacked arg|10747
||mov|8,wb|11,-(xt)||load argument (new value)|10748
||mov|9,(xt)|8,wa||save old value|10749
||mov|3,bpfxt|7,xt||keep arg ptr for next time|10750
||mov|7,xl|8,wc||point back to block with value|10751
||mov|13,vrval(xl)|8,wb||set new value|10752
||bne|7,xs|3,bpfxt|6,bpf02|loop if not all done|10753
|bpf04|mov|7,xl|3,bpfpf||restore pfblk pointer|10757
||mov|8,wa|13,pfnlo(xl)||load number of locals|10758
||bze|8,wa|6,bpf07||jump if no locals|10759
||mov|8,wb|21,=nulls||get null constant|10760
||lct|8,wa|8,wa||set local counter|10761
|bpf05|mov|7,xl|10,(xr)+||load vrblk ptr for next local|10765
|bpf06|mov|8,wc|7,xl||save pointer|10769
||mov|7,xl|13,vrval(xl)||load next value|10770
||beq|9,(xl)|22,=b_trt|6,bpf06|loop back if trblk|10771
||mov|11,-(xs)|7,xl||stack old value|10775
||mov|7,xl|8,wc||point back to block with value|10776
||mov|13,vrval(xl)|8,wb||set null as new value|10777
||bct|8,wa|6,bpf05||loop till all locals processed|10778
||ejc|||||10779
|bpf07|zer|7,xr|||zero reg xr in case|10788
||bze|3,kvpfl|6,bpf7c||skip if profiling is off|10789
||beq|3,kvpfl|18,=num02|6,bpf7a|branch on type of profile|10790
||jsr|6,systm|||get current time|10794
||sti|3,pfetm|||save for a sec|10795
||sbi|3,pfstm|||find time used by caller|10796
||jsr|6,icbld|||build into an icblk|10797
||ldi|3,pfetm|||reload current time|10798
||brn|6,bpf7b|||merge|10799
|bpf7a|ldi|3,pfstm|||get start time of calling stmt|10803
||jsr|6,icbld|||assemble an icblk round it|10804
||jsr|6,systm|||get now time|10805
|bpf7b|sti|3,pfstm|||set start time of 1st func stmt|10809
||mnz|3,pffnc|||flag function entry|10810
|bpf7c|mov|11,-(xs)|7,xr||stack icblk ptr (or zero)|10814
||mov|8,wa|3,r_cod||load old code block pointer|10815
||scp|8,wb|||get code pointer|10817
||sub|8,wb|8,wa||make code pointer into offset|10818
||mov|7,xl|3,bpfpf||recall pfblk pointer|10819
||mov|11,-(xs)|3,bpfsv||stack old value of function name|10820
||mov|11,-(xs)|8,wa||stack code block pointer|10821
||mov|11,-(xs)|8,wb||stack code offset|10822
||mov|11,-(xs)|3,flprt||stack old flprt|10823
||mov|11,-(xs)|3,flptr||stack old failure pointer|10824
||mov|11,-(xs)|7,xl||stack pointer to pfblk|10825
||zer|11,-(xs)|||dummy zero entry for fail return|10826
||chk||||check for stack overflow|10827
||mov|3,flptr|7,xs||set new fail return value|10828
||mov|3,flprt|7,xs||set new flprt|10829
||mov|8,wa|3,kvtra||load trace value|10830
||add|8,wa|3,kvftr||add ftrace value|10831
||bnz|8,wa|6,bpf09||jump if tracing possible|10832
||icv|3,kvfnc|||else bump fnclevel|10833
|bpf08|mov|7,xr|13,pfcod(xl)||point to vrblk of entry label|10837
||mov|7,xr|13,vrlbl(xr)||point to target code|10838
||beq|7,xr|21,=stndl|6,bpf17|test for undefined label|10839
||bne|9,(xr)|22,=b_trt|6,bpf8a|jump if not trapped|10840
||mov|7,xr|13,trlbl(xr)||else load ptr to real label code|10841
|bpf8a|bri|9,(xr)|||off to execute function|10842
|bpf09|mov|7,xr|13,pfctr(xl)||load possible call trace trblk|10846
||mov|7,xl|13,pfvbl(xl)||load vrblk pointer for function|10847
||mov|8,wa|19,*vrval||set name offset for variable|10848
||bze|3,kvtra|6,bpf10||jump if trace mode is off|10849
||bze|7,xr|6,bpf10||or if there is no call trace|10850
||dcv|3,kvtra|||decrement trace count|10854
||bze|13,trfnc(xr)|6,bpf11||jump if print trace|10855
||jsr|6,trxeq|||execute function type trace|10856
||ejc|||||10857
|bpf10|bze|3,kvftr|6,bpf16||jump if ftrace is off|10863
||dcv|3,kvftr|||else decrement ftrace|10864
|bpf11|jsr|6,prtsn|||print statement number|10868
||jsr|6,prtnm|||print function name|10869
||mov|8,wa|18,=ch_pp||load left paren|10870
||jsr|6,prtch|||print left paren|10871
||mov|7,xl|13,num01(xs)||recover pfblk pointer|10872
||bze|13,fargs(xl)|6,bpf15||skip if no arguments|10873
||zer|8,wb|||else set argument counter|10874
||brn|6,bpf13|||jump into loop|10875
|bpf12|mov|8,wa|18,=ch_cm||load comma|10879
||jsr|6,prtch|||print to separate from last arg|10880
|bpf13|mov|9,(xs)|8,wb||save arg ctr (over failoffs is ok)|10884
||wtb|8,wb|||convert to byte offset|10885
||add|7,xl|8,wb||point to next argument pointer|10886
||mov|7,xr|13,pfarg(xl)||load next argument vrblk ptr|10887
||sub|7,xl|8,wb||restore pfblk pointer|10888
||mov|7,xr|13,vrval(xr)||load next value|10889
||jsr|6,prtvl|||print argument value|10890
||ejc|||||10891
||mov|8,wb|9,(xs)||restore argument counter|10895
||icv|8,wb|||increment argument counter|10896
||blt|8,wb|13,fargs(xl)|6,bpf12|loop if more to print|10897
|bpf15|mov|8,wa|18,=ch_rp||load right paren|10901
||jsr|6,prtch|||print to terminate output|10902
||jsr|6,prtnl|||terminate print line|10903
|bpf16|icv|3,kvfnc|||increment fnclevel|10907
||mov|7,xl|3,r_fnc||load ptr to possible trblk|10908
||jsr|6,ktrex|||call keyword trace routine|10909
||mov|7,xl|13,num01(xs)||restore pfblk pointer|10913
||brn|6,bpf08|||jump back to execute function|10914
|bpf17|mov|3,flptr|13,num02(xs)||reset so exfal can return to evalx|10918
||erb|1,286|26,function call to undefined entry label|||10919
||ejc|||||10922
|b_rcl|ent|2,bl_rc|||entry point (rcblk)|10931
||mov|11,-(xs)|7,xr||stack result|10932
||lcw|7,xr|||get next code word|10933
||bri|9,(xr)|||execute it|10934
||ejc|||||10936
|b_scl|ent|2,bl_sc|||entry point (scblk)|10945
||mov|11,-(xs)|7,xr||stack result|10946
||lcw|7,xr|||get next code word|10947
||bri|9,(xr)|||execute it|10948
||ejc|||||10949
|b_tbt|ent|2,bl_tb|||entry point (tbblk)|10955
||ejc|||||10956
|b_tet|ent|2,bl_te|||entry point (teblk)|10962
||ejc|||||10963
|b_vct|ent|2,bl_vc|||entry point (vcblk)|10969
||ejc|||||10970
|b_vr_|ent|2,bl__i|||mark start of vrblk entry points|10977
|b_vra|ent|2,bl__i|||entry point|10986
||mov|7,xl|7,xr||copy name base (vrget = 0)|10987
||mov|8,wa|19,*vrval||set name offset|10988
||jsr|6,acess|||access value|10989
||ppm|6,exfal|||fail if access fails|10990
||mov|11,-(xs)|7,xr||stack result|10991
||lcw|7,xr|||get next code word|10992
||bri|9,(xr)|||execute it|10993
||ejc|||||10994
|b_vre|ent||||entry point|11002
||erb|1,042|26,attempt to change value of protected variable|||11003
||ejc|||||11004
|b_vrg|ent||||entry point|11013
||mov|7,xr|13,vrlbo(xr)||load code pointer|11014
||mov|7,xl|9,(xr)||load entry address|11015
||bri|7,xl|||jump to routine for next code word|11016
||ejc|||||11017
|b_vrl|ent||||entry point|11026
||mov|11,-(xs)|13,vrval(xr)||load value onto stack (vrget = 0)|11027
||lcw|7,xr|||get next code word|11028
||bri|9,(xr)|||execute next code word|11029
||ejc|||||11030
|b_vrs|ent||||entry point|11039
||mov|13,vrvlo(xr)|9,(xs)||store value, leave on stack|11040
||lcw|7,xr|||get next code word|11041
||bri|9,(xr)|||execute next code word|11042
||ejc|||||11043
|b_vrt|ent||||entry point|11051
||sub|7,xr|19,*vrtra||point back to start of vrblk|11052
||mov|7,xl|7,xr||copy vrblk pointer|11053
||mov|8,wa|19,*vrval||set name offset|11054
||mov|7,xr|13,vrlbl(xl)||load pointer to trblk|11055
||bze|3,kvtra|6,bvrt2||jump if trace is off|11056
||dcv|3,kvtra|||else decrement trace count|11057
||bze|13,trfnc(xr)|6,bvrt1||jump if print trace case|11058
||jsr|6,trxeq|||else execute full trace|11059
||brn|6,bvrt2|||merge to jump to label|11060
|bvrt1|jsr|6,prtsn|||print statement number|11064
||mov|7,xr|7,xl||copy vrblk pointer|11065
||mov|8,wa|18,=ch_cl||colon|11066
||jsr|6,prtch|||print it|11067
||mov|8,wa|18,=ch_pp||left paren|11068
||jsr|6,prtch|||print it|11069
||jsr|6,prtvn|||print label name|11070
||mov|8,wa|18,=ch_rp||right paren|11071
||jsr|6,prtch|||print it|11072
||jsr|6,prtnl|||terminate line|11073
||mov|7,xr|13,vrlbl(xl)||point back to trblk|11074
|bvrt2|mov|7,xr|13,trlbl(xr)||load pointer to actual code|11078
||bri|9,(xr)|||execute statement at label|11079
||ejc|||||11080
|b_vrv|ent||||entry point|11091
||mov|8,wb|9,(xs)||load value (leave copy on stack)|11092
||sub|7,xr|19,*vrsto||point to vrblk|11093
||mov|7,xl|7,xr||copy vrblk pointer|11094
||mov|8,wa|19,*vrval||set offset|11095
||jsr|6,asign|||call assignment routine|11096
||ppm|6,exfal|||fail if assignment fails|11097
||lcw|7,xr|||else get next code word|11098
||bri|9,(xr)|||execute next code word|11099
||ejc|||||11100
|b_xnt|ent|2,bl_xn|||entry point (xnblk)|11106
||ejc|||||11107
|b_xrt|ent|2,bl_xr|||entry point (xrblk)|11113
|b_yyy|ent|2,bl__i|||last block routine entry point|11117
||ttl|27,s p i t b o l -- pattern matching routines||||11118
|p_aaa|ent|2,bl__i|||entry to mark first pattern|11127
||ejc|||||11157
||ejc|||||11211
||ejc|||||11262
||ejc|||||11290
||ejc|||||11338
||ejc|||||11378
||ejc|||||11415
||ejc|||||11449
||ejc|||||11499
||ejc|||||11539
|p_aba|ent|2,bl_p0|||p0blk|11548
||mov|11,-(xs)|8,wb||stack cursor|11549
||mov|11,-(xs)|7,xr||stack dummy node ptr|11550
||mov|11,-(xs)|3,pmhbs||stack old stack base ptr|11551
||mov|11,-(xs)|21,=ndabb||stack ptr to node ndabb|11552
||mov|3,pmhbs|7,xs||store new stack base ptr|11553
||brn|6,succp|||succeed|11554
||ejc|||||11555
|p_abb|ent||||entry point|11561
||mov|3,pmhbs|8,wb||restore history stack base ptr|11562
||brn|6,flpop|||fail and pop dummy node ptr|11563
||ejc|||||11564
|p_abc|ent|2,bl_p0|||p0blk|11570
||mov|7,xt|3,pmhbs||keep p_abb stack base|11571
||mov|8,wa|13,num03(xt)||load initial cursor|11572
||mov|3,pmhbs|13,num01(xt)||restore outer stack base ptr|11573
||beq|7,xt|7,xs|6,pabc1|jump if no history stack entries|11574
||mov|11,-(xs)|7,xt||else save inner pmhbs entry|11575
||mov|11,-(xs)|21,=ndabd||stack ptr to special node ndabd|11576
||brn|6,pabc2|||merge|11577
|pabc1|add|7,xs|19,*num04||remove ndabb entry and cursor|11581
|pabc2|bne|8,wa|8,wb|6,succp|allow further attempt if non-null|11585
||mov|7,xr|13,pthen(xr)||bypass alternative node so as to ...|11586
||brn|6,succp|||... refuse further match attempts|11587
||ejc|||||11588
|p_abd|ent||||entry point|11594
||mov|3,pmhbs|8,wb||restore inner stack base ptr|11595
||brn|6,failp|||and fail|11596
||ejc|||||11597
|p_abo|ent|2,bl_p0|||p0blk|11603
||brn|6,exfal|||signal statement failure|11604
||ejc|||||11605
|p_alt|ent|2,bl_p1|||p1blk|11611
||mov|11,-(xs)|8,wb||stack cursor|11612
||mov|11,-(xs)|13,parm1(xr)||stack pointer to alternative|11613
||chk||||check for stack overflow|11614
||brn|6,succp|||if all ok, then succeed|11615
||ejc|||||11616
|p_ans|ent|2,bl_p1|||p1blk|11622
||beq|8,wb|3,pmssl|6,failp|fail if no chars left|11623
||mov|7,xl|3,r_pms||else point to subject string|11624
||plc|7,xl|8,wb||point to current character|11625
||lch|8,wa|9,(xl)||load current character|11626
||bne|8,wa|13,parm1(xr)|6,failp|fail if no match|11627
||icv|8,wb|||else bump cursor|11628
||brn|6,succp|||and succeed|11629
||ejc|||||11630
|p_any|ent|2,bl_p2|||p2blk|11637
|pany1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|11641
||mov|7,xl|3,r_pms||else point to subject string|11642
||plc|7,xl|8,wb||get char ptr to current character|11643
||lch|8,wa|9,(xl)||load current character|11644
||mov|7,xl|13,parm1(xr)||point to ctblk|11645
||wtb|8,wa|||change to byte offset|11646
||add|7,xl|8,wa||point to entry in ctblk|11647
||mov|8,wa|13,ctchs(xl)||load word from ctblk|11648
||anb|8,wa|13,parm2(xr)||and with selected bit|11649
||zrb|8,wa|6,failp||fail if no match|11650
||icv|8,wb|||else bump cursor|11651
||brn|6,succp|||and succeed|11652
||ejc|||||11653
|p_ayd|ent|2,bl_p1|||p1blk|11659
||jsr|6,evals|||evaluate string argument|11660
||err|1,043|26,any evaluated argument is not a string|||11661
||ppm|6,failp|||fail if evaluation failure|11662
||ppm|6,pany1|||merge multi-char case if ok|11663
||ejc|||||11664
|p_arb|ent|2,bl_p0|||p0blk|11673
||mov|7,xr|13,pthen(xr)||load successor pointer|11674
||mov|11,-(xs)|8,wb||stack dummy cursor|11675
||mov|11,-(xs)|7,xr||stack successor pointer|11676
||mov|11,-(xs)|8,wb||stack cursor|11677
||mov|11,-(xs)|21,=ndarc||stack ptr to special node ndarc|11678
||bri|9,(xr)|||execute next node matching null|11679
||ejc|||||11680
|p_arc|ent||||entry point|11686
||beq|8,wb|3,pmssl|6,flpop|fail and pop stack to successor|11687
||icv|8,wb|||else bump cursor|11688
||mov|11,-(xs)|8,wb||stack updated cursor|11689
||mov|11,-(xs)|7,xr||restack pointer to ndarc node|11690
||mov|7,xr|13,num02(xs)||load successor pointer|11691
||bri|9,(xr)|||off to reexecute successor node|11692
||ejc|||||11693
|p_bal|ent|2,bl_p0|||p0blk|11702
||zer|8,wc|||zero parentheses level counter|11703
||mov|7,xl|3,r_pms||point to subject string|11704
||plc|7,xl|8,wb||point to current character|11705
||brn|6,pbal2|||jump into scan loop|11706
|pbal1|lch|8,wa|10,(xl)+||load next character, bump pointer|11710
||icv|8,wb|||push cursor for character|11711
||beq|8,wa|18,=ch_pp|6,pbal3|jump if left paren|11712
||beq|8,wa|18,=ch_rp|6,pbal4|jump if right paren|11713
||bze|8,wc|6,pbal5||else succeed if at outer level|11714
|pbal2|bne|8,wb|3,pmssl|6,pbal1|loop back unless end of string|11718
||brn|6,failp|||in which case, fail|11719
|pbal3|icv|8,wc|||bump paren level|11723
||brn|6,pbal2|||loop back to check end of string|11724
|pbal4|bze|8,wc|6,failp||fail if no matching left paren|11728
||dcv|8,wc|||else decrement level counter|11729
||bnz|8,wc|6,pbal2||loop back if not at outer level|11730
|pbal5|mov|11,-(xs)|8,wb||stack cursor|11734
||mov|11,-(xs)|7,xr||stack ptr to bal node for extend|11735
||brn|6,succp|||and succeed|11736
||ejc|||||11737
|p_bkd|ent|2,bl_p1|||p1blk|11743
||jsr|6,evals|||evaluate string expression|11744
||err|1,044|26,break evaluated argument is not a string|||11745
||ppm|6,failp|||fail if evaluation fails|11746
||ppm|6,pbrk1|||merge with multi-char case if ok|11747
||ejc|||||11748
|p_bks|ent|2,bl_p1|||p1blk|11754
||mov|8,wc|3,pmssl||get subject string length|11755
||sub|8,wc|8,wb||get number of characters left|11756
||bze|8,wc|6,failp||fail if no characters left|11757
||lct|8,wc|8,wc||set counter for chars left|11758
||mov|7,xl|3,r_pms||point to subject string|11759
||plc|7,xl|8,wb||point to current character|11760
|pbks1|lch|8,wa|10,(xl)+||load next char, bump pointer|11764
||beq|8,wa|13,parm1(xr)|6,succp|succeed if break character found|11765
||icv|8,wb|||else push cursor|11766
||bct|8,wc|6,pbks1||loop back if more to go|11767
||brn|6,failp|||fail if end of string, no break chr|11768
||ejc|||||11769
|p_brk|ent|2,bl_p2|||p2blk|11776
|pbrk1|mov|8,wc|3,pmssl||load subject string length|11780
||sub|8,wc|8,wb||get number of characters left|11781
||bze|8,wc|6,failp||fail if no characters left|11782
||lct|8,wc|8,wc||set counter for characters left|11783
||mov|7,xl|3,r_pms||else point to subject string|11784
||plc|7,xl|8,wb||point to current character|11785
||mov|3,psave|7,xr||save node pointer|11786
|pbrk2|lch|8,wa|10,(xl)+||load next char, bump pointer|11790
||mov|7,xr|13,parm1(xr)||load pointer to ctblk|11791
||wtb|8,wa|||convert to byte offset|11792
||add|7,xr|8,wa||point to ctblk entry|11793
||mov|8,wa|13,ctchs(xr)||load ctblk word|11794
||mov|7,xr|3,psave||restore node pointer|11795
||anb|8,wa|13,parm2(xr)||and with selected bit|11796
||nzb|8,wa|6,succp||succeed if break character found|11797
||icv|8,wb|||else push cursor|11798
||bct|8,wc|6,pbrk2||loop back unless end of string|11799
||brn|6,failp|||fail if end of string, no break chr|11800
||ejc|||||11801
|p_bkx|ent|2,bl_p0|||p0blk|11811
||icv|8,wb|||step cursor past previous break chr|11812
||brn|6,succp|||succeed to rematch break|11813
||ejc|||||11814
|p_bxd|ent|2,bl_p1|||p1blk|11825
||jsr|6,evals|||evaluate string argument|11826
||err|1,045|26,breakx evaluated argument is not a string|||11827
||ppm|6,failp|||fail if evaluation fails|11828
||ppm|6,pbrk1|||merge with break if all ok|11829
||ejc|||||11830
|p_cas|ent|2,bl_p2|||p2blk|11837
||mov|11,-(xs)|7,xr||save node pointer|11838
||mov|11,-(xs)|8,wb||save cursor|11839
||mov|7,xl|13,parm1(xr)||load name base|11840
||mti|8,wb|||load cursor as integer|11841
||mov|8,wb|13,parm2(xr)||load name offset|11842
||jsr|6,icbld|||get icblk for cursor value|11843
||mov|8,wa|8,wb||move name offset|11844
||mov|8,wb|7,xr||move value to assign|11845
||jsr|6,asinp|||perform assignment|11846
||ppm|6,flpop|||fail on assignment failure|11847
||mov|8,wb|10,(xs)+||else restore cursor|11848
||mov|7,xr|10,(xs)+||restore node pointer|11849
||brn|6,succp|||and succeed matching null|11850
||ejc|||||11851
|p_exa|ent|2,bl_p1|||p1blk|11860
||jsr|6,evalp|||evaluate expression|11861
||ppm|6,failp|||fail if evaluation fails|11862
||blo|8,wa|22,=p_aaa|6,pexa1|jump if result is not a pattern|11863
||mov|11,-(xs)|8,wb||stack dummy cursor|11867
||mov|11,-(xs)|7,xr||stack ptr to p_exa node|11868
||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|11869
||mov|11,-(xs)|21,=ndexb||stack ptr to special node ndexb|11870
||mov|3,pmhbs|7,xs||store new stack base pointer|11871
||mov|7,xr|7,xl||copy node pointer|11872
||bri|9,(xr)|||match first node in expression pat|11873
|pexa1|beq|8,wa|22,=b_scl|6,pexa2|jump if it is already a string|11877
||mov|11,-(xs)|7,xl||else stack result|11878
||mov|7,xl|7,xr||save node pointer|11879
||jsr|6,gtstg|||convert result to string|11880
||err|1,046|26,expression does not evaluate to pattern|||11881
||mov|8,wc|7,xr||copy string pointer|11882
||mov|7,xr|7,xl||restore node pointer|11883
||mov|7,xl|8,wc||copy string pointer again|11884
|pexa2|bze|13,sclen(xl)|6,succp||just succeed if null string|11888
||brn|6,pstr1|||else merge with string circuit|11889
||ejc|||||11890
|p_exb|ent||||entry point|11899
||mov|3,pmhbs|8,wb||restore outer level stack pointer|11900
||brn|6,flpop|||fail and pop p_exa node ptr|11901
||ejc|||||11902
|p_exc|ent||||entry point|11911
||mov|3,pmhbs|8,wb||restore inner stack base pointer|11912
||brn|6,failp|||and fail into expr pattern alternvs|11913
||ejc|||||11914
|p_fal|ent|2,bl_p0|||p0blk|11920
||brn|6,failp|||just signal failure|11921
||ejc|||||11922
|p_fen|ent|2,bl_p0|||p0blk|11931
||mov|11,-(xs)|8,wb||stack dummy cursor|11932
||mov|11,-(xs)|21,=ndabo||stack ptr to abort node|11933
||brn|6,succp|||and succeed matching null|11934
||ejc|||||11935
|p_fna|ent|2,bl_p0|||p0blk|11944
||mov|11,-(xs)|3,pmhbs||stack current history stack base|11945
||mov|11,-(xs)|21,=ndfnb||stack indir ptr to p_fnb (failure)|11946
||mov|3,pmhbs|7,xs||begin new history stack|11947
||brn|6,succp|||succeed|11948
||ejc|||||11949
|p_fnb|ent|2,bl_p0|||p0blk|11955
||mov|3,pmhbs|8,wb||restore outer pmhbs stack base|11956
||brn|6,failp|||...and fail|11957
||ejc|||||11958
|p_fnc|ent|2,bl_p0|||p0blk|11964
||mov|7,xt|3,pmhbs||get inner stack base ptr|11965
||mov|3,pmhbs|13,num01(xt)||restore outer stack base|11966
||beq|7,xt|7,xs|6,pfnc1|optimize if no alternatives|11967
||mov|11,-(xs)|7,xt||else stack inner stack base|11968
||mov|11,-(xs)|21,=ndfnd||stack ptr to ndfnd|11969
||brn|6,succp|||succeed|11970
|pfnc1|add|7,xs|19,*num02||pop off p_fnb entry|11974
||brn|6,succp|||succeed|11975
||ejc|||||11976
|p_fnd|ent|2,bl_p0|||p0blk|11982
||mov|7,xs|8,wb||pop stack to fence() history base|11983
||brn|6,flpop|||pop base entry and fail|11984
||ejc|||||11985
|p_ima|ent|2,bl_p0|||p0blk|11994
||mov|11,-(xs)|8,wb||stack cursor|11995
||mov|11,-(xs)|7,xr||stack dummy node pointer|11996
||mov|11,-(xs)|3,pmhbs||stack old stack base pointer|11997
||mov|11,-(xs)|21,=ndimb||stack ptr to special node ndimb|11998
||mov|3,pmhbs|7,xs||store new stack base pointer|11999
||brn|6,succp|||and succeed|12000
||ejc|||||12001
|p_imb|ent||||entry point|12010
||mov|3,pmhbs|8,wb||restore history stack base ptr|12011
||brn|6,flpop|||fail and pop dummy node ptr|12012
||ejc|||||12013
|p_imc|ent|2,bl_p2|||p2blk|12023
||mov|7,xt|3,pmhbs||load pointer to p_imb entry|12024
||mov|8,wa|8,wb||copy final cursor|12025
||mov|8,wb|13,num03(xt)||load initial cursor|12026
||mov|3,pmhbs|13,num01(xt)||restore outer stack base pointer|12027
||beq|7,xt|7,xs|6,pimc1|jump if no history stack entries|12028
||mov|11,-(xs)|7,xt||else save inner pmhbs pointer|12029
||mov|11,-(xs)|21,=ndimd||and a ptr to special node ndimd|12030
||brn|6,pimc2|||merge|12031
|pimc1|add|7,xs|19,*num04||remove ndimb entry and cursor|12035
|pimc2|mov|11,-(xs)|8,wa||save current (final) cursor|12039
||mov|11,-(xs)|7,xr||save current node pointer|12040
||mov|7,xl|3,r_pms||point to subject string|12041
||sub|8,wa|8,wb||compute substring length|12042
||jsr|6,sbstr|||build substring|12043
||mov|8,wb|7,xr||move result|12044
||mov|7,xr|9,(xs)||reload node pointer|12045
||mov|7,xl|13,parm1(xr)||load name base|12046
||mov|8,wa|13,parm2(xr)||load name offset|12047
||jsr|6,asinp|||perform assignment|12048
||ppm|6,flpop|||fail if assignment fails|12049
||mov|7,xr|10,(xs)+||else restore node pointer|12050
||mov|8,wb|10,(xs)+||restore cursor|12051
||brn|6,succp|||and succeed|12052
||ejc|||||12053
|p_imd|ent||||entry point|12062
||mov|3,pmhbs|8,wb||restore inner stack base pointer|12063
||brn|6,failp|||and fail|12064
||ejc|||||12065
|p_len|ent|2,bl_p1|||p1blk|12071
|plen1|add|8,wb|13,parm1(xr)||push cursor indicated amount|12075
||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12076
||brn|6,failp|||else fail|12077
||ejc|||||12078
|p_lnd|ent|2,bl_p1|||p1blk|12084
||jsr|6,evali|||evaluate integer argument|12085
||err|1,047|26,len evaluated argument is not integer|||12086
||err|1,048|26,len evaluated argument is negative or too large|||12087
||ppm|6,failp|||fail if evaluation fails|12088
||ppm|6,plen1|||merge with normal circuit if ok|12089
||ejc|||||12090
|p_nad|ent|2,bl_p1|||p1blk|12096
||jsr|6,evals|||evaluate string argument|12097
||err|1,049|26,notany evaluated argument is not a string|||12098
||ppm|6,failp|||fail if evaluation fails|12099
||ppm|6,pnay1|||merge with multi-char case if ok|12100
||ejc|||||12101
|p_nas|ent|2,bl_p1|||entry point|12107
||beq|8,wb|3,pmssl|6,failp|fail if no chars left|12108
||mov|7,xl|3,r_pms||else point to subject string|12109
||plc|7,xl|8,wb||point to current character in strin|12110
||lch|8,wa|9,(xl)||load current character|12111
||beq|8,wa|13,parm1(xr)|6,failp|fail if match|12112
||icv|8,wb|||else bump cursor|12113
||brn|6,succp|||and succeed|12114
||ejc|||||12115
|p_nay|ent|2,bl_p2|||p2blk|12122
|pnay1|beq|8,wb|3,pmssl|6,failp|fail if no characters left|12126
||mov|7,xl|3,r_pms||else point to subject string|12127
||plc|7,xl|8,wb||point to current character|12128
||lch|8,wa|9,(xl)||load current character|12129
||wtb|8,wa|||convert to byte offset|12130
||mov|7,xl|13,parm1(xr)||load pointer to ctblk|12131
||add|7,xl|8,wa||point to entry in ctblk|12132
||mov|8,wa|13,ctchs(xl)||load entry from ctblk|12133
||anb|8,wa|13,parm2(xr)||and with selected bit|12134
||nzb|8,wa|6,failp||fail if character is matched|12135
||icv|8,wb|||else bump cursor|12136
||brn|6,succp|||and succeed|12137
||ejc|||||12138
|p_nth|ent|2,bl_p0|||p0blk (dummy)|12151
||mov|7,xt|3,pmhbs||load pointer to base of stack|12152
||mov|8,wa|13,num01(xt)||load saved pmhbs (or pattern type)|12153
||ble|8,wa|18,=num02|6,pnth2|jump if outer level (pattern type)|12154
||mov|3,pmhbs|8,wa||restore outer stack base pointer|12158
||mov|7,xr|13,num02(xt)||restore pointer to p_exa node|12159
||beq|7,xt|7,xs|6,pnth1|jump if no history stack entries|12160
||mov|11,-(xs)|7,xt||else stack inner stack base ptr|12161
||mov|11,-(xs)|21,=ndexc||stack ptr to special node ndexc|12162
||brn|6,succp|||and succeed|12163
|pnth1|add|7,xs|19,*num04||remove p_exb entry and node ptr|12167
||brn|6,succp|||and succeed|12168
|pnth2|mov|3,pmssl|8,wb||save final cursor in safe place|12172
||bze|3,pmdfl|6,pnth6||jump if no pattern assignments|12173
||ejc|||||12174
|pnth3|dca|7,xt|||point past cursor entry|12181
||mov|8,wa|11,-(xt)||load node pointer|12182
||beq|8,wa|21,=ndpad|6,pnth4|jump if ndpad entry|12183
||bne|8,wa|21,=ndpab|6,pnth5|jump if not ndpab entry|12184
||mov|11,-(xs)|13,num01(xt)||stack initial cursor|12189
||chk||||check for stack overflow|12190
||brn|6,pnth3|||loop back if ok|12191
|pnth4|mov|8,wa|13,num01(xt)||load final cursor|12196
||mov|8,wb|9,(xs)||load initial cursor from stack|12197
||mov|9,(xs)|7,xt||save history stack scan ptr|12198
||sub|8,wa|8,wb||compute length of string|12199
||mov|7,xl|3,r_pms||point to subject string|12203
||jsr|6,sbstr|||construct substring|12204
||mov|8,wb|7,xr||copy substring pointer|12205
||mov|7,xt|9,(xs)||reload history stack scan ptr|12206
||mov|7,xl|13,num02(xt)||load pointer to p_pac node with nam|12207
||mov|8,wa|13,parm2(xl)||load name offset|12208
||mov|7,xl|13,parm1(xl)||load name base|12209
||jsr|6,asinp|||perform assignment|12210
||ppm|6,exfal|||match fails if name eval fails|12211
||mov|7,xt|10,(xs)+||else restore history stack ptr|12212
||ejc|||||12213
|pnth5|bne|7,xt|7,xs|6,pnth3|loop if more entries to scan|12219
|pnth6|mov|7,xs|3,pmhbs||wipe out history stack|12223
||mov|8,wb|10,(xs)+||load initial cursor|12224
||mov|8,wc|10,(xs)+||load match type code|12225
||mov|8,wa|3,pmssl||load final cursor value|12226
||mov|7,xl|3,r_pms||point to subject string|12227
||zer|3,r_pms|||clear subject string ptr for gbcol|12228
||bze|8,wc|6,pnth7||jump if call by name|12229
||beq|8,wc|18,=num02|6,pnth9|exit if statement level call|12230
||sub|8,wa|8,wb||compute length of string|12234
||jsr|6,sbstr|||build substring|12235
||mov|11,-(xs)|7,xr||stack result|12236
||lcw|7,xr|||get next code word|12237
||bri|9,(xr)|||execute it|12238
|pnth7|mov|11,-(xs)|8,wb||stack initial cursor|12242
||mov|11,-(xs)|8,wa||stack final cursor|12243
|pnth8|mov|11,-(xs)|7,xl||stack subject pointer|12252
|pnth9|lcw|7,xr|||get next code word|12256
||bri|9,(xr)|||execute next code word|12257
||ejc|||||12258
|p_pos|ent|2,bl_p1|||p1blk|12264
||beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12282
||bnz|8,wb|6,failp||don't look further if cursor not 0|12283
||mov|7,xt|3,pmhbs||get history stack base ptr|12284
||bne|7,xr|11,-(xt)|6,failp|fail if pos is not first node|12285
|ppos2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12289
||mov|8,wb|13,parm1(xr)||get desired cursor position|12290
||bgt|8,wb|3,pmssl|6,exfal|abort if off end|12291
||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12292
||brn|6,succp|||continue match with adjusted cursor|12293
||ejc|||||12294
|p_psd|ent|2,bl_p1|||p1blk|12300
||jsr|6,evali|||evaluate integer argument|12301
||err|1,050|26,pos evaluated argument is not integer|||12302
||err|1,051|26,pos evaluated argument is negative or too large|||12303
||ppm|6,failp|||fail if evaluation fails|12304
||ppm|6,ppos1|||process expression case|12305
|ppos1|beq|8,wb|13,parm1(xr)|6,succp|succeed if at right location|12307
||bnz|8,wb|6,failp||don't look further if cursor not 0|12308
||bnz|3,evlif|6,failp||fail if complex argument|12309
||mov|7,xt|3,pmhbs||get history stack base ptr|12310
||mov|8,wa|3,evlio||get original node ptr|12311
||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12312
||brn|6,ppos2|||merge with integer argument code|12313
||ejc|||||12314
|p_paa|ent|2,bl_p0|||p0blk|12323
||mov|11,-(xs)|8,wb||stack initial cursor|12324
||mov|11,-(xs)|21,=ndpab||stack ptr to ndpab special node|12325
||brn|6,succp|||and succeed matching null|12326
||ejc|||||12327
|p_pab|ent||||entry point|12336
||brn|6,failp|||just fail (entry is already popped)|12337
||ejc|||||12338
|p_pac|ent|2,bl_p2|||p2blk|12348
||mov|11,-(xs)|8,wb||stack dummy cursor value|12349
||mov|11,-(xs)|7,xr||stack pointer to p_pac node|12350
||mov|11,-(xs)|8,wb||stack final cursor|12351
||mov|11,-(xs)|21,=ndpad||stack ptr to special ndpad node|12352
||mnz|3,pmdfl|||set dot flag non-zero|12353
||brn|6,succp|||and succeed|12354
||ejc|||||12355
|p_pad|ent||||entry point|12364
||brn|6,flpop|||fail and remove p_pac node|12365
||ejc|||||12366
|p_rem|ent|2,bl_p0|||p0blk|12372
||mov|8,wb|3,pmssl||point cursor to end of string|12373
||brn|6,succp|||and succeed|12374
||ejc|||||12375
|p_rpd|ent|2,bl_p1|||p1blk|12393
||jsr|6,evali|||evaluate integer argument|12394
||err|1,052|26,rpos evaluated argument is not integer|||12395
||err|1,053|26,rpos evaluated argument is negative or too large|||12396
||ppm|6,failp|||fail if evaluation fails|12397
||ppm|6,prps1|||merge with normal case if ok|12398
|prps1|mov|8,wc|3,pmssl||get length of string|12400
||sub|8,wc|8,wb||get number of characters remaining|12401
||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12402
||bnz|8,wb|6,failp||don't look further if cursor not 0|12403
||bnz|3,evlif|6,failp||fail if complex argument|12404
||mov|7,xt|3,pmhbs||get history stack base ptr|12405
||mov|8,wa|3,evlio||get original node ptr|12406
||bne|8,wa|11,-(xt)|6,failp|fail if pos is not first node|12407
||brn|6,prps2|||merge with integer arg code|12408
||ejc|||||12409
|p_rps|ent|2,bl_p1|||p1blk|12415
||mov|8,wc|3,pmssl||get length of string|12421
||sub|8,wc|8,wb||get number of characters remaining|12422
||beq|8,wc|13,parm1(xr)|6,succp|succeed if at right location|12423
||bnz|8,wb|6,failp||don't look further if cursor not 0|12424
||mov|7,xt|3,pmhbs||get history stack base ptr|12425
||bne|7,xr|11,-(xt)|6,failp|fail if rpos is not first node|12426
|prps2|bne|11,-(xt)|21,=nduna|6,failp|fail if not unanchored mode|12430
||mov|8,wb|3,pmssl||point to end of string|12431
||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12432
||sub|8,wb|13,parm1(xr)||else set new cursor|12433
||mov|13,num02(xt)|8,wb||fake number of unanchored moves|12434
||brn|6,succp|||continue match with adjusted cursor|12435
||ejc|||||12436
|p_rtb|ent|2,bl_p1|||p1blk|12442
|prtb1|mov|8,wc|8,wb||save initial cursor|12446
||mov|8,wb|3,pmssl||point to end of string|12447
||blt|8,wb|13,parm1(xr)|6,failp|fail if string not long enough|12448
||sub|8,wb|13,parm1(xr)||else set new cursor|12449
||bge|8,wb|8,wc|6,succp|and succeed if not too far already|12450
||brn|6,failp|||in which case, fail|12451
||ejc|||||12452
|p_rtd|ent|2,bl_p1|||p1blk|12458
||jsr|6,evali|||evaluate integer argument|12459
||err|1,054|26,rtab evaluated argument is not integer|||12460
||err|1,055|26,rtab evaluated argument is negative or too large|||12461
||ppm|6,failp|||fail if evaluation fails|12462
||ppm|6,prtb1|||merge with normal case if success|12463
||ejc|||||12464
|p_spd|ent|2,bl_p1|||p1blk|12470
||jsr|6,evals|||evaluate string argument|12471
||err|1,056|26,span evaluated argument is not a string|||12472
||ppm|6,failp|||fail if evaluation fails|12473
||ppm|6,pspn1|||merge with multi-char case if ok|12474
||ejc|||||12475
|p_spn|ent|2,bl_p2|||p2blk|12482
|pspn1|mov|8,wc|3,pmssl||copy subject string length|12486
||sub|8,wc|8,wb||calculate number of characters left|12487
||bze|8,wc|6,failp||fail if no characters left|12488
||mov|7,xl|3,r_pms||point to subject string|12489
||plc|7,xl|8,wb||point to current character|12490
||mov|3,psavc|8,wb||save initial cursor|12491
||mov|3,psave|7,xr||save node pointer|12492
||lct|8,wc|8,wc||set counter for chars left|12493
|pspn2|lch|8,wa|10,(xl)+||load next character, bump pointer|12497
||wtb|8,wa|||convert to byte offset|12498
||mov|7,xr|13,parm1(xr)||point to ctblk|12499
||add|7,xr|8,wa||point to ctblk entry|12500
||mov|8,wa|13,ctchs(xr)||load ctblk entry|12501
||mov|7,xr|3,psave||restore node pointer|12502
||anb|8,wa|13,parm2(xr)||and with selected bit|12503
||zrb|8,wa|6,pspn3||jump if no match|12504
||icv|8,wb|||else push cursor|12505
||bct|8,wc|6,pspn2||loop back unless end of string|12506
|pspn3|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12510
||brn|6,failp|||else fail if null string matched|12511
||ejc|||||12512
|p_sps|ent|2,bl_p1|||p1blk|12518
||mov|8,wc|3,pmssl||get subject string length|12519
||sub|8,wc|8,wb||calculate number of characters left|12520
||bze|8,wc|6,failp||fail if no characters left|12521
||mov|7,xl|3,r_pms||else point to subject string|12522
||plc|7,xl|8,wb||point to current character|12523
||mov|3,psavc|8,wb||save initial cursor|12524
||lct|8,wc|8,wc||set counter for characters left|12525
|psps1|lch|8,wa|10,(xl)+||load next character, bump pointer|12529
||bne|8,wa|13,parm1(xr)|6,psps2|jump if no match|12530
||icv|8,wb|||else push cursor|12531
||bct|8,wc|6,psps1||and loop unless end of string|12532
|psps2|bne|8,wb|3,psavc|6,succp|succeed if chars matched|12536
||brn|6,failp|||fail if null string matched|12537
||ejc|||||12538
|p_str|ent|2,bl_p1|||p1blk|12547
||mov|7,xl|13,parm1(xr)||get pointer to string|12548
|pstr1|mov|3,psave|7,xr||save node pointer|12552
||mov|7,xr|3,r_pms||load subject string pointer|12553
||plc|7,xr|8,wb||point to current character|12554
||add|8,wb|13,sclen(xl)||compute new cursor position|12555
||bgt|8,wb|3,pmssl|6,failp|fail if past end of string|12556
||mov|3,psavc|8,wb||save updated cursor|12557
||mov|8,wa|13,sclen(xl)||get number of chars to compare|12558
||plc|7,xl|||point to chars of test string|12559
||cmc|6,failp|6,failp||compare, fail if not equal|12560
||mov|7,xr|3,psave||if all matched, restore node ptr|12561
||mov|8,wb|3,psavc||restore updated cursor|12562
||brn|6,succp|||and succeed|12563
||ejc|||||12564
|p_suc|ent|2,bl_p0|||p0blk|12573
||mov|11,-(xs)|8,wb||stack cursor|12574
||mov|11,-(xs)|7,xr||stack pointer to this node|12575
||brn|6,succp|||succeed matching null|12576
||ejc|||||12577
|p_tab|ent|2,bl_p1|||p1blk|12583
|ptab1|bgt|8,wb|13,parm1(xr)|6,failp|fail if too far already|12587
||mov|8,wb|13,parm1(xr)||else set new cursor position|12588
||ble|8,wb|3,pmssl|6,succp|succeed if not off end|12589
||brn|6,failp|||else fail|12590
||ejc|||||12591
|p_tbd|ent|2,bl_p1|||p1blk|12597
||jsr|6,evali|||evaluate integer argument|12598
||err|1,057|26,tab evaluated argument is not integer|||12599
||err|1,058|26,tab evaluated argument is negative or too large|||12600
||ppm|6,failp|||fail if evaluation fails|12601
||ppm|6,ptab1|||merge with normal case if ok|12602
||ejc|||||12603
|p_una|ent||||entry point|12609
||mov|7,xr|8,wb||copy initial pattern node pointer|12610
||mov|8,wb|9,(xs)||get initial cursor|12611
||beq|8,wb|3,pmssl|6,exfal|match fails if at end of string|12612
||icv|8,wb|||else increment cursor|12613
||mov|9,(xs)|8,wb||store incremented cursor|12614
||mov|11,-(xs)|7,xr||restack initial node ptr|12615
||mov|11,-(xs)|21,=nduna||restack unanchored node|12616
||bri|9,(xr)|||rematch first node|12617
||ejc|||||12618
|p_yyy|ent|2,bl__i|||mark last entry in pattern section|12626
||ttl|27,s p i t b o l -- snobol4 built-in label routines||||12627
||ejc|||||12638
|l_abo|ent||||entry point|12642
|labo1|mov|8,wa|3,kvert||load error code|12646
||bze|8,wa|6,labo3||jump if no error has occured|12647
||jsr|6,sysax|||call after execution proc|12649
||mov|8,wc|3,kvstn||current statement|12653
||jsr|6,filnm|||obtain file name for this statement|12654
||mov|7,xr|3,r_cod||current code block|12657
||mov|8,wc|13,cdsln(xr)||line number|12658
||zer|8,wb|||column number|12662
||mov|7,xr|3,stage|||12663
||jsr|6,sysea|||advise system of error|12664
||ppm|6,stpr4|||if system does not want print|12665
||jsr|6,prtpg|||else eject printer|12667
||bze|7,xr|6,labo2||did sysea request print|12669
||jsr|6,prtst|||print text from sysea|12670
|labo2|jsr|6,ermsg|||print error message|12672
||zer|7,xr|||indicate no message to print|12673
||brn|6,stopr|||jump to routine to stop run|12674
|labo3|erb|1,036|26,goto abort with no preceding error|||12678
||ejc|||||12679
|l_cnt|ent||||entry point|12683
|lcnt1|mov|7,xr|3,r_cnt||load continuation code block ptr|12687
||bze|7,xr|6,lcnt3||jump if no previous error|12688
||zer|3,r_cnt|||clear flag|12689
||mov|3,r_cod|7,xr||else store as new code block ptr|12690
||bne|9,(xr)|22,=b_cdc|6,lcnt2|jump if not complex go|12691
||mov|8,wa|3,stxoc||get offset of error|12692
||bge|8,wa|3,stxof|6,lcnt4|jump if error in goto evaluation|12693
|lcnt2|add|7,xr|3,stxof||add failure offset|12697
||lcp|7,xr|||load code pointer|12698
||mov|7,xs|3,flptr||reset stack pointer|12699
||lcw|7,xr|||get next code word|12700
||bri|9,(xr)|||execute next code word|12701
|lcnt3|icv|3,errft|||fatal error|12705
||erb|1,037|26,goto continue with no preceding error|||12706
|lcnt4|icv|3,errft|||fatal error|12711
||erb|1,332|26,goto continue with error in failure goto|||12712
||ejc|||||12713
|l_end|ent||||entry point|12717
|lend0|mov|7,xr|21,=endms||point to message /normal term.../|12721
||brn|6,stopr|||jump to routine to stop run|12722
||ejc|||||12723
|l_frt|ent||||entry point|12727
||mov|8,wa|21,=scfrt||point to string /freturn/|12728
||brn|6,retrn|||jump to common return routine|12729
||ejc|||||12730
|l_nrt|ent||||entry point|12734
||mov|8,wa|21,=scnrt||point to string /nreturn/|12735
||brn|6,retrn|||jump to common return routine|12736
||ejc|||||12737
|l_rtn|ent||||entry point|12741
||mov|8,wa|21,=scrtn||point to string /return/|12742
||brn|6,retrn|||jump to common return routine|12743
||ejc|||||12744
|l_scn|ent||||entry point|12748
||mov|7,xr|3,r_cnt||load continuation code block ptr|12749
||bze|7,xr|6,lscn2||jump if no previous error|12750
||zer|3,r_cnt|||clear flag|12751
||bne|3,kvert|18,=nm320|6,lscn1|error must be user interrupt|12752
||beq|3,kvert|18,=nm321|6,lscn2|detect scontinue loop|12753
||mov|3,r_cod|7,xr||else store as new code block ptr|12754
||add|7,xr|3,stxoc||add resume offset|12755
||lcp|7,xr|||load code pointer|12756
||lcw|7,xr|||get next code word|12757
||bri|9,(xr)|||execute next code word|12758
|lscn1|icv|3,errft|||fatal error|12762
||erb|1,331|26,goto scontinue with no user interrupt|||12763
|lscn2|icv|3,errft|||fatal error|12767
||erb|1,321|26,goto scontinue with no preceding error|||12768
||ejc|||||12769
|l_und|ent||||entry point|12773
||erb|1,038|26,goto undefined label|||12774
||ttl|27,s p i t b o l -- predefined snobol4 functions||||12775
||ejc|||||12800
|s_any|ent||||entry point|12854
||mov|8,wb|22,=p_ans||set pcode for single char case|12855
||mov|7,xl|22,=p_any||pcode for multi-char case|12856
||mov|8,wc|22,=p_ayd||pcode for expression case|12857
||jsr|6,patst|||call common routine to build node|12858
||err|1,059|26,any argument is not a string or expression|||12859
||mov|11,-(xs)|7,xr||stack result|12860
||lcw|7,xr|||get next code word|12861
||bri|9,(xr)|||execute it|12862
||ejc|||||12863
|s_app|ent||||entry point|12889
||bze|8,wa|6,sapp3||jump if no arguments|12890
||dcv|8,wa|||else get applied func arg count|12891
||mov|8,wb|8,wa||copy|12892
||wtb|8,wb|||convert to bytes|12893
||mov|7,xt|7,xs||copy stack pointer|12894
||add|7,xt|8,wb||point to function argument on stack|12895
||mov|7,xr|9,(xt)||load function ptr (apply 1st arg)|12896
||bze|8,wa|6,sapp2||jump if no args for applied func|12897
||lct|8,wb|8,wa||else set counter for loop|12898
|sapp1|dca|7,xt|||point to next argument|12902
||mov|13,num01(xt)|9,(xt)||move argument up|12903
||bct|8,wb|6,sapp1||loop till all moved|12904
|sapp2|ica|7,xs|||adjust stack ptr for apply 1st arg|12908
||jsr|6,gtnvr|||get variable block addr for func|12909
||ppm|6,sapp3|||jump if not natural variable|12910
||mov|7,xl|13,vrfnc(xr)||else point to function block|12911
||brn|6,cfunc|||go call applied function|12912
|sapp3|erb|1,060|26,apply first arg is not natural variable name|||12916
||ejc|||||12917
|s_abn|ent||||entry point|12924
||zer|7,xr|||set parm1 = 0 for the moment|12925
||mov|8,wb|22,=p_alt||set pcode for alternative node|12926
||jsr|6,pbild|||build alternative node|12927
||mov|7,xl|7,xr||save ptr to alternative pattern|12928
||mov|8,wb|22,=p_abc||pcode for p_abc|12929
||zer|7,xr|||p0blk|12930
||jsr|6,pbild|||build p_abc node|12931
||mov|13,pthen(xr)|7,xl||put alternative node as successor|12932
||mov|8,wa|7,xl||remember alternative node pointer|12933
||mov|7,xl|7,xr||copy p_abc node ptr|12934
||mov|7,xr|9,(xs)||load arbno argument|12935
||mov|9,(xs)|8,wa||stack alternative node pointer|12936
||jsr|6,gtpat|||get arbno argument as pattern|12937
||err|1,061|26,arbno argument is not pattern|||12938
||jsr|6,pconc|||concat arg with p_abc node|12939
||mov|7,xl|7,xr||remember ptr to concd patterns|12940
||mov|8,wb|22,=p_aba||pcode for p_aba|12941
||zer|7,xr|||p0blk|12942
||jsr|6,pbild|||build p_aba node|12943
||mov|13,pthen(xr)|7,xl||concatenate nodes|12944
||mov|7,xl|9,(xs)||recall ptr to alternative node|12945
||mov|13,parm1(xl)|7,xr||point alternative back to argument|12946
||lcw|7,xr|||get next code word|12947
||bri|9,(xr)|||execute next code word|12948
||ejc|||||12949
|s_arg|ent||||entry point|12953
||jsr|6,gtsmi|||get second arg as small integer|12954
||err|1,062|26,arg second argument is not integer|||12955
||ppm|6,exfal|||fail if out of range or negative|12956
||mov|8,wa|7,xr||save argument number|12957
||mov|7,xr|10,(xs)+||load first argument|12958
||jsr|6,gtnvr|||locate vrblk|12959
||ppm|6,sarg1|||jump if not natural variable|12960
||mov|7,xr|13,vrfnc(xr)||else load function block pointer|12961
||bne|9,(xr)|22,=b_pfc|6,sarg1|jump if not program defined|12962
||bze|8,wa|6,exfal||fail if arg number is zero|12963
||bgt|8,wa|13,fargs(xr)|6,exfal|fail if arg number is too large|12964
||wtb|8,wa|||else convert to byte offset|12965
||add|7,xr|8,wa||point to argument selected|12966
||mov|7,xr|13,pfagb(xr)||load argument vrblk pointer|12967
||brn|6,exvnm|||exit to build nmblk|12968
|sarg1|erb|1,063|26,arg first argument is not program function name|||12972
||ejc|||||12973
|s_arr|ent||||entry point|12977
||mov|7,xl|10,(xs)+||load initial element value|12978
||mov|7,xr|10,(xs)+||load first argument|12979
||jsr|6,gtint|||convert first arg to integer|12980
||ppm|6,sar02|||jump if not integer|12981
||ldi|13,icval(xr)|||load integer value|12985
||ile|6,sar10|||jump if zero or neg (bad dimension)|12986
||mfi|8,wa|6,sar11||else convert to one word, test ovfl|12987
||jsr|6,vmake|||create vector|12988
||ppm|6,sar11|||fail if too large|12989
||brn|6,exsid|||exit setting idval|12990
||ejc|||||12991
|sar02|mov|11,-(xs)|7,xr||replace argument on stack|12997
||jsr|6,xscni|||initialize scan of first argument|12998
||err|1,064|26,array first argument is not integer or string|||12999
||ppm|6,exnul|||dummy (unused) null string exit|13000
||mov|11,-(xs)|3,r_xsc||save prototype pointer|13001
||mov|11,-(xs)|7,xl||save default value|13002
||zer|3,arcdm|||zero count of dimensions|13003
||zer|3,arptr|||zero offset to indicate pass one|13004
||ldi|4,intv1|||load integer one|13005
||sti|3,arnel|||initialize element count|13006
|sar03|ldi|4,intv1|||load one as default low bound|13013
||sti|3,arsvl|||save as low bound|13014
||mov|8,wc|18,=ch_cl||set delimiter one = colon|13015
||mov|7,xl|18,=ch_cm||set delimiter two = comma|13016
||zer|8,wa|||retain blanks in prototype|13017
||jsr|6,xscan|||scan next bound|13018
||bne|8,wa|18,=num01|6,sar04|jump if not colon|13019
||jsr|6,gtint|||convert low bound|13023
||err|1,065|26,array first argument lower bound is not integer|||13024
||ldi|13,icval(xr)|||load value of low bound|13025
||sti|3,arsvl|||store low bound value|13026
||mov|8,wc|18,=ch_cm||set delimiter one = comma|13027
||mov|7,xl|8,wc||and delimiter two = comma|13028
||zer|8,wa|||retain blanks in prototype|13029
||jsr|6,xscan|||scan high bound|13030
||ejc|||||13031
|sar04|jsr|6,gtint|||convert high bound to integer|13037
||err|1,066|26,array first argument upper bound is not integer|||13038
||ldi|13,icval(xr)|||get high bound|13039
||sbi|3,arsvl|||subtract lower bound|13040
||iov|6,sar10|||bad dimension if overflow|13041
||ilt|6,sar10|||bad dimension if negative|13042
||adi|4,intv1|||add 1 to get dimension|13043
||iov|6,sar10|||bad dimension if overflow|13044
||mov|7,xl|3,arptr||load offset (also pass indicator)|13045
||bze|7,xl|6,sar05||jump if first pass|13046
||add|7,xl|9,(xs)||point to current location in arblk|13050
||sti|13,cfp_i(xl)|||store dimension|13051
||ldi|3,arsvl|||load low bound|13052
||sti|9,(xl)|||store low bound|13053
||add|3,arptr|19,*ardms||bump offset to next bounds|13054
||brn|6,sar06|||jump to check for end of bounds|13055
|sar05|icv|3,arcdm|||bump dimension count|13059
||mli|3,arnel|||multiply dimension by count so far|13060
||iov|6,sar11|||too large if overflow|13061
||sti|3,arnel|||else store updated element count|13062
|sar06|bnz|8,wa|6,sar03||loop back unless end of bounds|13066
||bnz|3,arptr|6,sar09||jump if end of pass 2|13067
||ejc|||||13068
||ldi|3,arnel|||get number of elements|13074
||mfi|8,wb|6,sar11||get as addr integer, test ovflo|13075
||wtb|8,wb|||else convert to length in bytes|13076
||mov|8,wa|19,*arsi_||set size of standard fields|13077
||lct|8,wc|3,arcdm||set dimension count to control loop|13078
|sar07|add|8,wa|19,*ardms||allow space for one set of bounds|13082
||bct|8,wc|6,sar07||loop back till all accounted for|13083
||mov|7,xl|8,wa||save size (=arofs)|13084
||add|8,wa|8,wb||add space for elements|13088
||ica|8,wa|||allow for arpro prototype field|13089
||bgt|8,wa|3,mxlen|6,sar11|fail if too large|13090
||jsr|6,alloc|||else allocate arblk|13091
||mov|8,wb|9,(xs)||load default value|13092
||mov|9,(xs)|7,xr||save arblk pointer|13093
||mov|8,wc|8,wa||save length in bytes|13094
||btw|8,wa|||convert length back to words|13095
||lct|8,wa|8,wa||set counter to control loop|13096
|sar08|mov|10,(xr)+|8,wb||set one word|13100
||bct|8,wa|6,sar08||loop till all set|13101
||ejc|||||13102
||mov|7,xr|10,(xs)+||reload arblk pointer|13108
||mov|8,wb|9,(xs)||load prototype|13109
||mov|9,(xr)|22,=b_art||set type word|13110
||mov|13,arlen(xr)|8,wc||store length in bytes|13111
||zer|13,idval(xr)|||zero id till we get it built|13112
||mov|13,arofs(xr)|7,xl||set prototype field ptr|13113
||mov|13,arndm(xr)|3,arcdm||set number of dimensions|13114
||mov|8,wc|7,xr||save arblk pointer|13115
||add|7,xr|7,xl||point to prototype field|13116
||mov|9,(xr)|8,wb||store prototype ptr in arblk|13117
||mov|3,arptr|19,*arlbd||set offset for pass 2 bounds scan|13118
||mov|3,r_xsc|8,wb||reset string pointer for xscan|13119
||mov|9,(xs)|8,wc||store arblk pointer on stack|13120
||zer|3,xsofs|||reset offset ptr to start of string|13121
||brn|6,sar03|||jump back to rescan bounds|13122
|sar09|mov|7,xr|10,(xs)+||reload pointer to arblk|13126
||brn|6,exsid|||exit setting idval|13127
|sar10|erb|1,067|26,array dimension is zero, negative or out of range|||13131
|sar11|erb|1,068|26,array size exceeds maximum permitted|||13135
||ejc|||||13136
|s_atn|ent||||entry point|13141
||mov|7,xr|10,(xs)+||get argument|13142
||jsr|6,gtrea|||convert to real|13143
||err|1,301|26,atan argument not numeric|||13144
||ldr|13,rcval(xr)|||load accumulator with argument|13145
||atn||||take arctangent|13146
||brn|6,exrea|||overflow, out of range not possible|13147
||ejc|||||13148
||ejc|||||13151
|s_bsp|ent||||entry point|13155
||jsr|6,iofcb|||call fcblk routine|13156
||err|1,316|26,backspace argument is not a suitable name|||13157
||err|1,316|26,backspace argument is not a suitable name|||13158
||err|1,317|26,backspace file does not exist|||13159
||jsr|6,sysbs|||call backspace file function|13160
||err|1,317|26,backspace file does not exist|||13161
||err|1,318|26,backspace file does not permit backspace|||13162
||err|1,319|26,backspace caused non-recoverable error|||13163
||brn|6,exnul|||return null as result|13164
||ejc|||||13165
|s_brk|ent||||entry point|13198
||mov|8,wb|22,=p_bks||set pcode for single char case|13199
||mov|7,xl|22,=p_brk||pcode for multi-char case|13200
||mov|8,wc|22,=p_bkd||pcode for expression case|13201
||jsr|6,patst|||call common routine to build node|13202
||err|1,069|26,break argument is not a string or expression|||13203
||mov|11,-(xs)|7,xr||stack result|13204
||lcw|7,xr|||get next code word|13205
||bri|9,(xr)|||execute it|13206
||ejc|||||13207
|s_bkx|ent||||entry point|13214
||mov|8,wb|22,=p_bks||pcode for single char argument|13215
||mov|7,xl|22,=p_brk||pcode for multi-char argument|13216
||mov|8,wc|22,=p_bxd||pcode for expression case|13217
||jsr|6,patst|||call common routine to build node|13218
||err|1,070|26,breakx argument is not a string or expression|||13219
||mov|11,-(xs)|7,xr||save ptr to break node|13223
||mov|8,wb|22,=p_bkx||set pcode for breakx node|13224
||jsr|6,pbild|||build it|13225
||mov|13,pthen(xr)|9,(xs)||set break node as successor|13226
||mov|8,wb|22,=p_alt||set pcode for alternation node|13227
||jsr|6,pbild|||build (parm1=alt=breakx node)|13228
||mov|8,wa|7,xr||save ptr to alternation node|13229
||mov|7,xr|9,(xs)||point to break node|13230
||mov|13,pthen(xr)|8,wa||set alternate node as successor|13231
||lcw|7,xr|||result on stack|13232
||bri|9,(xr)|||execute next code word|13233
||ejc|||||13234
|s_chr|ent||||entry point|13238
||jsr|6,gtsmi|||convert arg to integer|13239
||err|1,281|26,char argument not integer|||13240
||ppm|6,schr1|||too big error exit|13241
||bge|8,wc|18,=cfp_a|6,schr1|see if out of range of host set|13242
||mov|8,wa|18,=num01||if not set scblk allocation|13243
||mov|8,wb|8,wc||save char code|13244
||jsr|6,alocs|||allocate 1 bau scblk|13245
||mov|7,xl|7,xr||copy scblk pointer|13246
||psc|7,xl|||get set to stuff char|13247
||sch|8,wb|9,(xl)||stuff it|13248
||csc|7,xl|||complete store character|13249
||zer|7,xl|||clear slop in xl|13250
||mov|11,-(xs)|7,xr||stack result|13251
||lcw|7,xr|||get next code word|13252
||bri|9,(xr)|||execute it|13253
|schr1|erb|1,282|26,char argument not in range|||13257
||ejc|||||13258
|s_chp|ent||||entry point|13263
||mov|7,xr|10,(xs)+||get argument|13264
||jsr|6,gtrea|||convert to real|13265
||err|1,302|26,chop argument not numeric|||13266
||ldr|13,rcval(xr)|||load accumulator with argument|13267
||chp||||truncate to integer valued real|13268
||brn|6,exrea|||no overflow possible|13269
||ejc|||||13270
|s_clr|ent||||entry point|13275
||jsr|6,xscni|||initialize to scan argument|13276
||err|1,071|26,clear argument is not a string|||13277
||ppm|6,sclr2|||jump if null|13278
|sclr1|mov|8,wc|18,=ch_cm||set delimiter one = comma|13283
||mov|7,xl|8,wc||delimiter two = comma|13284
||mnz|8,wa|||skip/trim blanks in prototype|13285
||jsr|6,xscan|||scan next variable name|13286
||jsr|6,gtnvr|||locate vrblk|13287
||err|1,072|26,clear argument has null variable name|||13288
||zer|13,vrget(xr)|||else flag by zeroing vrget field|13289
||bnz|8,wa|6,sclr1||loop back if stopped by comma|13290
|sclr2|mov|8,wb|3,hshtb||point to start of hash table|13294
|sclr3|beq|8,wb|3,hshte|6,exnul|exit returning null if none left|13298
||mov|7,xr|8,wb||else copy slot pointer|13299
||ica|8,wb|||bump slot pointer|13300
||sub|7,xr|19,*vrnxt||set offset to merge into loop|13301
|sclr4|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|13305
||bze|7,xr|6,sclr3||jump for next bucket if chain end|13306
||bnz|13,vrget(xr)|6,sclr5||jump if not flagged|13307
||ejc|||||13308
||jsr|6,setvr|||for flagged var, restore vrget|13314
||brn|6,sclr4|||and loop back for next vrblk|13315
|sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|check for protected variable|13320
||mov|7,xl|7,xr||copy vrblk pointer|13321
|sclr6|mov|8,wa|7,xl||save block pointer|13325
||mov|7,xl|13,vrval(xl)||load next value field|13326
||beq|9,(xl)|22,=b_trt|6,sclr6|loop back if trapped|13327
||mov|7,xl|8,wa||restore block pointer|13331
||mov|13,vrval(xl)|21,=nulls||store null constant value|13332
||brn|6,sclr4|||loop back for next vrblk|13333
||ejc|||||13334
|s_cod|ent||||entry point|13338
||mov|7,xr|10,(xs)+||load argument|13339
||jsr|6,gtcod|||convert to code|13340
||ppm|6,exfal|||fail if conversion is impossible|13341
||mov|11,-(xs)|7,xr||stack result|13342
||zer|3,r_ccb|||forget interim code block|13343
||lcw|7,xr|||get next code word|13344
||bri|9,(xr)|||execute it|13345
||ejc|||||13346
|s_col|ent||||entry point|13350
||mov|7,xr|10,(xs)+||load argument|13351
||jsr|6,gtint|||convert to integer|13352
||err|1,073|26,collect argument is not integer|||13353
||ldi|13,icval(xr)|||load collect argument|13354
||sti|3,clsvi|||save collect argument|13355
||zer|8,wb|||set no move up|13356
||zer|3,r_ccb|||forget interim code block|13357
||zer|3,dnams|||collect sediment too|13359
||jsr|6,gbcol|||perform garbage collection|13360
||mov|3,dnams|7,xr||record new sediment size|13361
||mov|8,wa|3,dname||point to end of memory|13365
||sub|8,wa|3,dnamp||subtract next location|13366
||btw|8,wa|||convert bytes to words|13367
||mti|8,wa|||convert words available as integer|13368
||sbi|3,clsvi|||subtract argument|13369
||iov|6,exfal|||fail if overflow|13370
||ilt|6,exfal|||fail if not enough|13371
||adi|3,clsvi|||else recompute available|13372
||brn|6,exint|||and exit with integer result|13373
||ejc|||||13374
|s_cnv|ent||||entry point|13403
||jsr|6,gtstg|||convert second argument to string|13404
||ppm|6,scv29|||error if second argument not string|13405
||bze|8,wa|6,scv29||or if null string|13406
||mov|7,xl|9,(xs)||load first argument|13410
||bne|9,(xl)|22,=b_pdt|6,scv01|jump if not program defined|13411
||mov|7,xl|13,pddfp(xl)||point to dfblk|13415
||mov|7,xl|13,dfnam(xl)||load datatype name|13416
||jsr|6,ident|||compare with second arg|13417
||ppm|6,exits|||exit if ident with arg as result|13418
||brn|6,exfal|||else fail|13419
|scv01|mov|11,-(xs)|7,xr||save string argument|13423
||mov|7,xl|21,=svctb||point to table of names to compare|13424
||zer|8,wb|||initialize counter|13425
||mov|8,wc|8,wa||save length of argument string|13426
|scv02|mov|7,xr|10,(xl)+||load next table entry, bump pointer|13430
||bze|7,xr|6,exfal||fail if zero marking end of list|13431
||bne|8,wc|13,sclen(xr)|6,scv05|jump if wrong length|13432
||mov|3,cnvtp|7,xl||else store table pointer|13433
||plc|7,xr|||point to chars of table entry|13434
||mov|7,xl|9,(xs)||load pointer to string argument|13435
||plc|7,xl|||point to chars of string arg|13436
||mov|8,wa|8,wc||set number of chars to compare|13437
||cmc|6,scv04|6,scv04||compare, jump if no match|13438
||ejc|||||13439
|scv03|mov|7,xl|8,wb||copy entry number|13445
||ica|7,xs|||pop string arg off stack|13446
||mov|7,xr|10,(xs)+||load first argument|13447
||bsw|7,xl|2,cnvtt||jump to appropriate routine|13448
||iff|1,0|6,scv06||string|13466
||iff|1,1|6,scv07||integer|13466
||iff|1,2|6,scv09||name|13466
||iff|1,3|6,scv10||pattern|13466
||iff|1,4|6,scv11||array|13466
||iff|1,5|6,scv19||table|13466
||iff|1,6|6,scv25||expression|13466
||iff|1,7|6,scv26||code|13466
||iff|1,8|6,scv27||numeric|13466
||iff|2,cnvrt|6,scv08||real|13466
||esw||||end of switch table|13466
|scv04|mov|7,xl|3,cnvtp||restore table pointer, merge|13470
|scv05|icv|8,wb|||bump entry number|13474
||brn|6,scv02|||loop back to check next entry|13475
|scv06|mov|11,-(xs)|7,xr||replace string argument on stack|13479
||jsr|6,gtstg|||convert to string|13480
||ppm|6,exfal|||fail if conversion not possible|13481
||mov|11,-(xs)|7,xr||stack result|13482
||lcw|7,xr|||get next code word|13483
||bri|9,(xr)|||execute it|13484
||ejc|||||13485
|scv07|jsr|6,gtint|||convert to integer|13491
||ppm|6,exfal|||fail if conversion not possible|13492
||mov|11,-(xs)|7,xr||stack result|13493
||lcw|7,xr|||get next code word|13494
||bri|9,(xr)|||execute it|13495
|scv08|jsr|6,gtrea|||convert to real|13501
||ppm|6,exfal|||fail if conversion not possible|13502
||mov|11,-(xs)|7,xr||stack result|13503
||lcw|7,xr|||get next code word|13504
||bri|9,(xr)|||execute it|13505
|scv09|beq|9,(xr)|22,=b_nml|6,exixr|return if already a name|13510
||jsr|6,gtnvr|||else try string to name convert|13511
||ppm|6,exfal|||fail if conversion not possible|13512
||brn|6,exvnm|||else exit building nmblk for vrblk|13513
|scv10|jsr|6,gtpat|||convert to pattern|13517
||ppm|6,exfal|||fail if conversion not possible|13518
||mov|11,-(xs)|7,xr||stack result|13519
||lcw|7,xr|||get next code word|13520
||bri|9,(xr)|||execute it|13521
|scv11|mov|11,-(xs)|7,xr||save argument on stack|13530
||zer|8,wa|||use table chain block addresses|13531
||jsr|6,gtarr|||get an array|13532
||ppm|6,exfal|||fail if empty table|13533
||ppm|6,exfal|||fail if not convertible|13534
||mov|7,xl|10,(xs)+||reload original arg|13535
||bne|9,(xl)|22,=b_tbt|6,exsid|exit if original not a table|13536
||mov|11,-(xs)|7,xr||sort the intermediate array|13537
||mov|11,-(xs)|21,=nulls||on first column|13538
||zer|8,wa|||sort ascending|13539
||jsr|6,sorta|||do sort|13540
||ppm|6,exfal|||if sort fails, so shall we|13541
||mov|8,wb|7,xr||save array result|13542
||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13543
||mfi|8,wa|||get as one word integer|13544
||lct|8,wa|8,wa||copy to control loop|13545
||add|7,xr|19,*arvl2||point to first element in array|13546
|scv12|mov|7,xl|9,(xr)||get teblk address|13550
||mov|10,(xr)+|13,tesub(xl)||replace with subscript|13551
||mov|10,(xr)+|13,teval(xl)||replace with value|13552
||bct|8,wa|6,scv12||loop till all copied over|13553
||mov|7,xr|8,wb||retrieve array address|13554
||brn|6,exsid|||exit setting id field|13555
|scv19|mov|8,wa|9,(xr)||load first word of block|13559
||mov|11,-(xs)|7,xr||replace arblk pointer on stack|13560
||beq|8,wa|22,=b_tbt|6,exits|return arg if already a table|13561
||bne|8,wa|22,=b_art|6,exfal|else fail if not an array|13562
||ejc|||||13563
||bne|13,arndm(xr)|18,=num02|6,exfal|fail if not 2-dim array|13569
||ldi|13,ardm2(xr)|||load dim 2|13570
||sbi|4,intv2|||subtract 2 to compare|13571
||ine|6,exfal|||fail if dim2 not 2|13572
||ldi|13,ardim(xr)|||load dim 1 (number of elements)|13576
||mfi|8,wa|||get as one word integer|13577
||lct|8,wb|8,wa||copy to control loop|13578
||add|8,wa|18,=tbsi_||add space for standard fields|13579
||wtb|8,wa|||convert length to bytes|13580
||jsr|6,alloc|||allocate space for tbblk|13581
||mov|8,wc|7,xr||copy tbblk pointer|13582
||mov|11,-(xs)|7,xr||save tbblk pointer|13583
||mov|10,(xr)+|22,=b_tbt||store type word|13584
||zer|10,(xr)+|||store zero for idval for now|13585
||mov|10,(xr)+|8,wa||store length|13586
||mov|10,(xr)+|21,=nulls||null initial lookup value|13587
|scv20|mov|10,(xr)+|8,wc||set bucket ptr to point to tbblk|13591
||bct|8,wb|6,scv20||loop till all initialized|13592
||mov|8,wb|19,*arvl2||set offset to first arblk element|13593
|scv21|mov|7,xl|13,num01(xs)||point to arblk|13597
||beq|8,wb|13,arlen(xl)|6,scv24|jump if all moved|13598
||add|7,xl|8,wb||else point to current location|13599
||add|8,wb|19,*num02||bump offset|13600
||mov|7,xr|9,(xl)||load subscript name|13601
||dca|7,xl|||adjust ptr to merge (trval=1+1)|13602
||ejc|||||13603
|scv22|mov|7,xl|13,trval(xl)||point to next value|13609
||beq|9,(xl)|22,=b_trt|6,scv22|loop back if trapped|13610
|scv23|mov|11,-(xs)|7,xl||stack value|13614
||mov|7,xl|13,num01(xs)||load tbblk pointer|13615
||jsr|6,tfind|||build teblk (note wb gt 0 by name)|13616
||ppm|6,exfal|||fail if acess fails|13617
||mov|13,teval(xl)|10,(xs)+||store value in teblk|13618
||brn|6,scv21|||loop back for next element|13619
|scv24|mov|7,xr|10,(xs)+||load tbblk pointer|13623
||ica|7,xs|||pop arblk pointer|13624
||brn|6,exsid|||exit setting idval|13625
|scv25|zer|8,wb|||by value|13630
||jsr|6,gtexp|||convert to expression|13631
||ppm|6,exfal|||fail if conversion not possible|13635
||zer|3,r_ccb|||forget interim code block|13636
||mov|11,-(xs)|7,xr||stack result|13637
||lcw|7,xr|||get next code word|13638
||bri|9,(xr)|||execute it|13639
|scv26|jsr|6,gtcod|||convert to code|13643
||ppm|6,exfal|||fail if conversion is not possible|13644
||zer|3,r_ccb|||forget interim code block|13645
||mov|11,-(xs)|7,xr||stack result|13646
||lcw|7,xr|||get next code word|13647
||bri|9,(xr)|||execute it|13648
|scv27|jsr|6,gtnum|||convert to numeric|13652
||ppm|6,exfal|||fail if unconvertible|13653
|scv31|mov|11,-(xs)|7,xr||stack result|13654
||lcw|7,xr|||get next code word|13655
||bri|9,(xr)|||execute it|13656
||ejc|||||13657
|scv29|erb|1,074|26,convert second argument is not a string|||13683
|s_cop|ent||||entry point|13687
||jsr|6,copyb|||copy the block|13688
||ppm|6,exits|||return if no idval field|13689
||brn|6,exsid|||exit setting id value|13690
||ejc|||||13691
|s_cos|ent||||entry point|13696
||mov|7,xr|10,(xs)+||get argument|13697
||jsr|6,gtrea|||convert to real|13698
||err|1,303|26,cos argument not numeric|||13699
||ldr|13,rcval(xr)|||load accumulator with argument|13700
||cos||||take cosine|13701
||rno|6,exrea|||if no overflow, return result in ra|13702
||erb|1,322|26,cos argument is out of range|||13703
||ejc|||||13704
|s_dat|ent||||entry point|13709
||jsr|6,xscni|||prepare to scan argument|13710
||err|1,075|26,data argument is not a string|||13711
||err|1,076|26,data argument is null|||13712
||mov|8,wc|18,=ch_pp||delimiter one = left paren|13716
||mov|7,xl|8,wc||delimiter two = left paren|13717
||mnz|8,wa|||skip/trim blanks in prototype|13718
||jsr|6,xscan|||scan datatype name|13719
||bnz|8,wa|6,sdat1||skip if left paren found|13720
||erb|1,077|26,data argument is missing a left paren|||13721
|sdat1|mov|7,xl|7,xr||save name ptr|13731
||mov|8,wa|13,sclen(xr)||get length|13733
||ctb|8,wa|2,scsi_||compute space needed|13734
||jsr|6,alost|||request static store for name|13735
||mov|11,-(xs)|7,xr||save datatype name|13736
||mvw||||copy name to static|13737
||mov|7,xr|9,(xs)||get name ptr|13738
||zer|7,xl|||scrub dud register|13739
||jsr|6,gtnvr|||locate vrblk for datatype name|13740
||err|1,078|26,data argument has null datatype name|||13741
||mov|3,datdv|7,xr||save vrblk pointer for datatype|13742
||mov|3,datxs|7,xs||store starting stack value|13743
||zer|8,wb|||zero count of field names|13744
|sdat2|mov|8,wc|18,=ch_rp||delimiter one = right paren|13748
||mov|7,xl|18,=ch_cm||delimiter two = comma|13749
||mnz|8,wa|||skip/trim blanks in prototype|13750
||jsr|6,xscan|||scan next field name|13751
||bnz|8,wa|6,sdat3||jump if delimiter found|13752
||erb|1,079|26,data argument is missing a right paren|||13753
|sdat3|jsr|6,gtnvr|||locate vrblk for field name|13757
||err|1,080|26,data argument has null field name|||13758
||mov|11,-(xs)|7,xr||stack vrblk pointer|13759
||icv|8,wb|||increment counter|13760
||beq|8,wa|18,=num02|6,sdat2|loop back if stopped by comma|13761
||ejc|||||13762
||mov|8,wa|18,=dfsi_||set size of dfblk standard fields|13768
||add|8,wa|8,wb||add number of fields|13769
||wtb|8,wa|||convert length to bytes|13770
||mov|8,wc|8,wb||preserve no. of fields|13771
||jsr|6,alost|||allocate space for dfblk|13772
||mov|8,wb|8,wc||get no of fields|13773
||mov|7,xt|3,datxs||point to start of stack|13774
||mov|8,wc|9,(xt)||load datatype name|13775
||mov|9,(xt)|7,xr||save dfblk pointer on stack|13776
||mov|10,(xr)+|22,=b_dfc||store type word|13777
||mov|10,(xr)+|8,wb||store number of fields (fargs)|13778
||mov|10,(xr)+|8,wa||store length (dflen)|13779
||sub|8,wa|19,*pddfs||compute pdblk length (for dfpdl)|13780
||mov|10,(xr)+|8,wa||store pdblk length (dfpdl)|13781
||mov|10,(xr)+|8,wc||store datatype name (dfnam)|13782
||lct|8,wc|8,wb||copy number of fields|13783
|sdat4|mov|10,(xr)+|11,-(xt)||move one field name vrblk pointer|13787
||bct|8,wc|6,sdat4||loop till all moved|13788
||mov|8,wc|8,wa||copy length of pdblk for later loop|13792
||mov|7,xr|3,datdv||point to vrblk|13793
||mov|7,xt|3,datxs||point back on stack|13794
||mov|7,xl|9,(xt)||load dfblk pointer|13795
||jsr|6,dffnc|||define function|13796
||ejc|||||13797
|sdat5|mov|8,wa|19,*ffsi_||set length of ffblk|13808
||jsr|6,alloc|||allocate space for ffblk|13809
||mov|9,(xr)|22,=b_ffc||set type word|13810
||mov|13,fargs(xr)|18,=num01||store fargs (always one)|13811
||mov|7,xt|3,datxs||point back on stack|13812
||mov|13,ffdfp(xr)|9,(xt)||copy dfblk ptr to ffblk|13813
||dca|8,wc|||decrement old dfpdl to get next ofs|13814
||mov|13,ffofs(xr)|8,wc||set offset to this field|13815
||zer|13,ffnxt(xr)|||tentatively set zero forward ptr|13816
||mov|7,xl|7,xr||copy ffblk pointer for dffnc|13817
||mov|7,xr|9,(xs)||load vrblk pointer for field|13818
||mov|7,xr|13,vrfnc(xr)||load current function pointer|13819
||bne|9,(xr)|22,=b_ffc|6,sdat6|skip if not currently a field func|13820
||mov|13,ffnxt(xl)|7,xr||link new ffblk to previous chain|13825
|sdat6|mov|7,xr|10,(xs)+||load vrblk pointer|13829
||jsr|6,dffnc|||define field function|13830
||bne|7,xs|3,datxs|6,sdat5|loop back till all done|13831
||ica|7,xs|||pop dfblk pointer|13832
||brn|6,exnul|||return with null result|13833
||ejc|||||13834
|s_dtp|ent||||entry point|13838
||mov|7,xr|10,(xs)+||load argument|13839
||jsr|6,dtype|||get datatype|13840
||mov|11,-(xs)|7,xr||stack result|13841
||lcw|7,xr|||get next code word|13842
||bri|9,(xr)|||execute it|13843
||ejc|||||13844
|s_dte|ent||||entry point|13848
||mov|7,xr|10,(xs)+||load argument|13849
||jsr|6,gtint|||convert to an integer|13850
||err|1,330|26,date argument is not integer|||13851
||jsr|6,sysdt|||call system date routine|13852
||mov|8,wa|13,num01(xl)||load length for sbstr|13853
||bze|8,wa|6,exnul||return null if length is zero|13854
||zer|8,wb|||set zero offset|13855
||jsr|6,sbstr|||use sbstr to build scblk|13856
||mov|11,-(xs)|7,xr||stack result|13857
||lcw|7,xr|||get next code word|13858
||bri|9,(xr)|||execute it|13859
||ejc|||||13860
|s_def|ent||||entry point|13864
||mov|7,xr|10,(xs)+||load second argument|13865
||zer|3,deflb|||zero label pointer in case null|13866
||beq|7,xr|21,=nulls|6,sdf01|jump if null second argument|13867
||jsr|6,gtnvr|||else find vrblk for label|13868
||ppm|6,sdf12|||jump if not a variable name|13869
||mov|3,deflb|7,xr||else set specified entry|13870
|sdf01|jsr|6,xscni|||prepare to scan first argument|13874
||err|1,081|26,define first argument is not a string|||13875
||err|1,082|26,define first argument is null|||13876
||mov|8,wc|18,=ch_pp||delimiter one = left paren|13877
||mov|7,xl|8,wc||delimiter two = left paren|13878
||mnz|8,wa|||skip/trim blanks in prototype|13879
||jsr|6,xscan|||scan out function name|13880
||bnz|8,wa|6,sdf02||jump if left paren found|13881
||erb|1,083|26,define first argument is missing a left paren|||13882
|sdf02|jsr|6,gtnvr|||get variable name|13886
||err|1,084|26,define first argument has null function name|||13887
||mov|3,defvr|7,xr||save vrblk pointer for function nam|13888
||zer|8,wb|||zero count of arguments|13889
||mov|3,defxs|7,xs||save initial stack pointer|13890
||bnz|3,deflb|6,sdf03||jump if second argument given|13891
||mov|3,deflb|7,xr||else default is function name|13892
|sdf03|mov|8,wc|18,=ch_rp||delimiter one = right paren|13896
||mov|7,xl|18,=ch_cm||delimiter two = comma|13897
||mnz|8,wa|||skip/trim blanks in prototype|13898
||jsr|6,xscan|||scan out next argument name|13899
||bnz|8,wa|6,sdf04||skip if delimiter found|13900
||erb|1,085|26,null arg name or missing ) in define first arg.|||13901
||ejc|||||13902
|sdf04|bne|7,xr|21,=nulls|6,sdf05|skip if non-null|13908
||bze|8,wb|6,sdf06||ignore null if case of no arguments|13909
|sdf05|jsr|6,gtnvr|||get vrblk pointer|13913
||ppm|6,sdf03|||loop back to ignore null name|13914
||mov|11,-(xs)|7,xr||stack argument vrblk pointer|13915
||icv|8,wb|||increment counter|13916
||beq|8,wa|18,=num02|6,sdf03|loop back if stopped by a comma|13917
|sdf06|mov|3,defna|8,wb||save number of arguments|13921
||zer|8,wb|||zero count of locals|13922
|sdf07|mov|8,wc|18,=ch_cm||set delimiter one = comma|13926
||mov|7,xl|8,wc||set delimiter two = comma|13927
||mnz|8,wa|||skip/trim blanks in prototype|13928
||jsr|6,xscan|||scan out next local name|13929
||bne|7,xr|21,=nulls|6,sdf08|skip if non-null|13930
||bze|8,wa|6,sdf09||exit scan if end of string|13931
|sdf08|jsr|6,gtnvr|||get vrblk pointer|13935
||ppm|6,sdf07|||loop back to ignore null name|13936
||icv|8,wb|||if ok, increment count|13937
||mov|11,-(xs)|7,xr||stack vrblk pointer|13938
||bnz|8,wa|6,sdf07||loop back if stopped by a comma|13939
||ejc|||||13940
|sdf09|mov|8,wa|8,wb||copy count of locals|13946
||add|8,wa|3,defna||add number of arguments|13947
||mov|8,wc|8,wa||set sum args+locals as loop count|13948
||add|8,wa|18,=pfsi_||add space for standard fields|13949
||wtb|8,wa|||convert length to bytes|13950
||jsr|6,alloc|||allocate space for pfblk|13951
||mov|7,xl|7,xr||save pointer to pfblk|13952
||mov|10,(xr)+|22,=b_pfc||store first word|13953
||mov|10,(xr)+|3,defna||store number of arguments|13954
||mov|10,(xr)+|8,wa||store length (pflen)|13955
||mov|10,(xr)+|3,defvr||store vrblk ptr for function name|13956
||mov|10,(xr)+|8,wb||store number of locals|13957
||zer|10,(xr)+|||deal with label later|13958
||zer|10,(xr)+|||zero pfctr|13959
||zer|10,(xr)+|||zero pfrtr|13960
||bze|8,wc|6,sdf11||skip if no args or locals|13961
||mov|8,wa|7,xl||keep pfblk pointer|13962
||mov|7,xt|3,defxs||point before arguments|13963
||lct|8,wc|8,wc||get count of args+locals for loop|13964
|sdf10|mov|10,(xr)+|11,-(xt)||store one entry and bump pointers|13968
||bct|8,wc|6,sdf10||loop till all stored|13969
||mov|7,xl|8,wa||recover pfblk pointer|13970
||ejc|||||13971
|sdf11|mov|7,xs|3,defxs||pop stack|13977
||mov|13,pfcod(xl)|3,deflb||store label vrblk in pfblk|13978
||mov|7,xr|3,defvr||point back to vrblk for function|13979
||jsr|6,dffnc|||define function|13980
||brn|6,exnul|||and exit returning null|13981
|sdf12|erb|1,086|26,define function entry point is not defined label|||13985
||ejc|||||13986
|s_det|ent||||entry point|13990
||mov|7,xr|10,(xs)+||load argument|13991
||jsr|6,gtvar|||locate variable|13992
||err|1,087|26,detach argument is not appropriate name|||13993
||jsr|6,dtach|||detach i/o association from name|13994
||brn|6,exnul|||return null result|13995
||ejc|||||13996
|s_dif|ent||||entry point|14000
||mov|7,xr|10,(xs)+||load second argument|14001
||mov|7,xl|10,(xs)+||load first argument|14002
||jsr|6,ident|||call ident comparison routine|14003
||ppm|6,exfal|||fail if ident|14004
||brn|6,exnul|||return null if differ|14005
||ejc|||||14006
|s_dmp|ent||||entry point|14010
||jsr|6,gtsmi|||load dump arg as small integer|14011
||err|1,088|26,dump argument is not integer|||14012
||err|1,089|26,dump argument is negative or too large|||14013
||jsr|6,dumpr|||else call dump routine|14014
||brn|6,exnul|||and return null as result|14015
||ejc|||||14016
|s_dup|ent||||entry point|14020
||jsr|6,gtsmi|||get second argument as small integr|14021
||err|1,090|26,dupl second argument is not integer|||14022
||ppm|6,sdup7|||jump if negative or too big|14023
||mov|8,wb|7,xr||save duplication factor|14024
||jsr|6,gtstg|||get first arg as string|14025
||ppm|6,sdup4|||jump if not a string|14026
||mti|8,wa|||acquire length as integer|14030
||sti|3,dupsi|||save for the moment|14031
||mti|8,wb|||get duplication factor as integer|14032
||mli|3,dupsi|||form product|14033
||iov|6,sdup3|||jump if overflow|14034
||ieq|6,exnul|||return null if result length = 0|14035
||mfi|8,wa|6,sdup3||get as addr integer, check ovflo|14036
|sdup1|mov|7,xl|7,xr||save string pointer|14040
||jsr|6,alocs|||allocate space for string|14041
||mov|11,-(xs)|7,xr||save as result pointer|14042
||mov|8,wc|7,xl||save pointer to argument string|14043
||psc|7,xr|||prepare to store chars of result|14044
||lct|8,wb|8,wb||set counter to control loop|14045
|sdup2|mov|7,xl|8,wc||point back to argument string|14049
||mov|8,wa|13,sclen(xl)||get number of characters|14050
||plc|7,xl|||point to chars in argument string|14051
||mvc||||move characters to result string|14052
||bct|8,wb|6,sdup2||loop till all duplications done|14053
||zer|7,xl|||clear garbage value|14054
||lcw|7,xr|||get next code word|14055
||bri|9,(xr)|||execute next code word|14056
||ejc|||||14057
|sdup3|mov|8,wa|3,dname||set impossible length for alocs|14063
||brn|6,sdup1|||merge back|14064
|sdup4|jsr|6,gtpat|||convert argument to pattern|14068
||err|1,091|26,dupl first argument is not a string or pattern|||14069
||mov|11,-(xs)|7,xr||store pattern on stack|14073
||mov|7,xr|21,=ndnth||start off with null pattern|14074
||bze|8,wb|6,sdup6||null pattern is result if dupfac=0|14075
||mov|11,-(xs)|8,wb||preserve loop count|14076
|sdup5|mov|7,xl|7,xr||copy current value as right argumnt|14080
||mov|7,xr|13,num01(xs)||get a new copy of left|14081
||jsr|6,pconc|||concatenate|14082
||dcv|9,(xs)|||count down|14083
||bnz|9,(xs)|6,sdup5||loop|14084
||ica|7,xs|||pop loop count|14085
|sdup6|mov|9,(xs)|7,xr||store result on stack|14089
||lcw|7,xr|||get next code word|14090
||bri|9,(xr)|||execute next code word|14091
|sdup7|ica|7,xs|||pop first argument|14095
||brn|6,exfal|||fail|14096
||ejc|||||14097
|s_ejc|ent||||entry point|14101
||jsr|6,iofcb|||call fcblk routine|14102
||err|1,092|26,eject argument is not a suitable name|||14103
||ppm|6,sejc1|||null argument|14104
||err|1,093|26,eject file does not exist|||14105
||jsr|6,sysef|||call eject file function|14106
||err|1,093|26,eject file does not exist|||14107
||err|1,094|26,eject file does not permit page eject|||14108
||err|1,095|26,eject caused non-recoverable output error|||14109
||brn|6,exnul|||return null as result|14110
|sejc1|jsr|6,sysep|||call routine to eject printer|14114
||brn|6,exnul|||exit with null result|14115
||ejc|||||14116
|s_enf|ent||||entry point|14120
||jsr|6,iofcb|||call fcblk routine|14121
||err|1,096|26,endfile argument is not a suitable name|||14122
||err|1,097|26,endfile argument is null|||14123
||err|1,098|26,endfile file does not exist|||14124
||jsr|6,sysen|||call endfile routine|14125
||err|1,098|26,endfile file does not exist|||14126
||err|1,099|26,endfile file does not permit endfile|||14127
||err|1,100|26,endfile caused non-recoverable output error|||14128
||mov|8,wb|7,xl||remember vrblk ptr from iofcb call|14129
||mov|7,xr|7,xl||copy pointer|14130
|senf1|mov|7,xl|7,xr||remember previous entry|14134
||mov|7,xr|13,trval(xr)||chain along|14135
||bne|9,(xr)|22,=b_trt|6,exnul|skip out if chain end|14136
||bne|13,trtyp(xr)|18,=trtfc|6,senf1|loop if not found|14137
||mov|13,trval(xl)|13,trval(xr)||remove trtrf|14138
||mov|3,enfch|13,trtrf(xr)||point to head of iochn|14139
||mov|8,wc|13,trfpt(xr)||point to fcblk|14140
||mov|7,xr|8,wb||filearg1 vrblk from iofcb|14141
||jsr|6,setvr|||reset it|14142
||mov|7,xl|20,=r_fcb||ptr to head of fcblk chain|14143
||sub|7,xl|19,*num02||adjust ready to enter loop|14144
|senf2|mov|7,xr|7,xl||copy ptr|14148
||mov|7,xl|13,num02(xl)||get next link|14149
||bze|7,xl|6,senf4||stop if chain end|14150
||beq|13,num03(xl)|8,wc|6,senf3|jump if fcblk found|14151
||brn|6,senf2|||loop|14152
|senf3|mov|13,num02(xr)|13,num02(xl)||delete fcblk from chain|14156
|senf4|mov|7,xl|3,enfch||get chain head|14160
||bze|7,xl|6,exnul||finished if chain end|14161
||mov|3,enfch|13,trtrf(xl)||chain along|14162
||mov|8,wa|13,ionmo(xl)||name offset|14163
||mov|7,xl|13,ionmb(xl)||name base|14164
||jsr|6,dtach|||detach name|14165
||brn|6,senf4|||loop till done|14166
||ejc|||||14167
|s_eqf|ent||||entry point|14171
||jsr|6,acomp|||call arithmetic comparison routine|14172
||err|1,101|26,eq first argument is not numeric|||14173
||err|1,102|26,eq second argument is not numeric|||14174
||ppm|6,exfal|||fail if lt|14175
||ppm|6,exnul|||return null if eq|14176
||ppm|6,exfal|||fail if gt|14177
||ejc|||||14178
|s_evl|ent||||entry point|14182
||mov|7,xr|10,(xs)+||load argument|14183
||lcw|8,wc|||load next code word|14189
||bne|8,wc|21,=ofne_|6,sevl1|jump if called by value|14190
||scp|7,xl|||copy code pointer|14191
||mov|8,wa|9,(xl)||get next code word|14192
||bne|8,wa|21,=ornm_|6,sevl2|by name unless expression|14193
||bnz|13,num01(xs)|6,sevl2||jump if by name|14194
|sevl1|zer|8,wb|||set flag for by value|14198
||mov|11,-(xs)|8,wc||save code word|14200
||jsr|6,gtexp|||convert to expression|14201
||err|1,103|26,eval argument is not expression|||14202
||zer|3,r_ccb|||forget interim code block|14203
||zer|8,wb|||set flag for by value|14204
||jsr|6,evalx|||evaluate expression by value|14208
||ppm|6,exfal|||fail if evaluation fails|14209
||mov|7,xl|7,xr||copy result|14210
||mov|7,xr|9,(xs)||reload next code word|14211
||mov|9,(xs)|7,xl||stack result|14212
||bri|9,(xr)|||jump to execute next code word|14213
|sevl2|mov|8,wb|18,=num01||set flag for by name|14217
||jsr|6,gtexp|||convert to expression|14219
||err|1,103|26,eval argument is not expression|||14220
||zer|3,r_ccb|||forget interim code block|14221
||mov|8,wb|18,=num01||set flag for by name|14222
||jsr|6,evalx|||evaluate expression by name|14224
||ppm|6,exfal|||fail if evaluation fails|14225
||brn|6,exnam|||exit with name|14226
||ejc|||||14229
|s_ext|ent||||entry point|14233
||zer|8,wb|||clear amount of static shift|14234
||zer|3,r_ccb|||forget interim code block|14235
||zer|3,dnams|||collect sediment too|14237
||jsr|6,gbcol|||compact memory by collecting|14238
||mov|3,dnams|7,xr||record new sediment size|14239
||jsr|6,gtstg||||14243
||err|1,288|26,exit second argument is not a string|||14244
||mov|7,xl|7,xr||copy second arg string pointer|14245
||jsr|6,gtstg|||convert arg to string|14246
||err|1,104|26,exit first argument is not suitable integer or string|||14247
||mov|11,-(xs)|7,xl||save second argument|14248
||mov|7,xl|7,xr||copy first arg string ptr|14249
||jsr|6,gtint|||check it is integer|14250
||ppm|6,sext1|||skip if unconvertible|14251
||zer|7,xl|||note it is integer|14252
||ldi|13,icval(xr)|||get integer arg|14253
|sext1|mov|8,wb|3,r_fcb||get fcblk chain header|14257
||mov|7,xr|21,=headv||point to v.v string|14258
||mov|8,wa|10,(xs)+||provide second argument scblk|14259
||jsr|6,sysxi|||call external routine|14260
||err|1,105|26,exit action not available in this implementation|||14261
||err|1,106|26,exit action caused irrecoverable error|||14262
||ieq|6,exnul|||return if argument 0|14263
||igt|6,sext2|||skip if positive|14264
||ngi||||make positive|14265
|sext2|mfi|8,wc|||get value in work reg|14273
||add|8,wa|8,wc||prepare to test for continue|14274
||beq|8,wa|18,=num05|6,sext5|continued execution if 4 plus 1|14275
||zer|3,gbcnt|||resuming execution so reset|14276
||bge|8,wc|18,=num03|6,sext3|skip if was 3 or 4|14277
||mov|11,-(xs)|8,wc||save value|14278
||zer|8,wc|||set to read options|14279
||jsr|6,prpar|||read syspp options|14280
||mov|8,wc|10,(xs)+||restore value|14281
|sext3|mnz|3,headp|||assume no headers|14285
||bne|8,wc|18,=num01|6,sext4|skip if not 1|14286
||zer|3,headp|||request header printing|14287
|sext4|jsr|6,systm|||get execution time start (sgd11)|14291
||sti|3,timsx|||save as initial time|14292
||ldi|3,kvstc|||reset to ensure ...|14293
||sti|3,kvstl|||... correct execution stats|14294
||jsr|6,stgcc|||recompute countdown counters|14295
||brn|6,exnul|||resume execution|14296
|sext5|mov|7,xr|21,=inton||integer one|14304
||brn|6,exixr|||return as result|14305
||ejc|||||14307
|s_exp|ent||||entry point|14312
||mov|7,xr|10,(xs)+||get argument|14313
||jsr|6,gtrea|||convert to real|14314
||err|1,304|26,exp argument not numeric|||14315
||ldr|13,rcval(xr)|||load accumulator with argument|14316
||etx||||take exponential|14317
||rno|6,exrea|||if no overflow, return result in ra|14318
||erb|1,305|26,exp produced real overflow|||14319
||ejc|||||14320
|s_fld|ent||||entry point|14325
||jsr|6,gtsmi|||get second argument (field number)|14326
||err|1,107|26,field second argument is not integer|||14327
||ppm|6,exfal|||fail if out of range|14328
||mov|8,wb|7,xr||else save integer value|14329
||mov|7,xr|10,(xs)+||load first argument|14330
||jsr|6,gtnvr|||point to vrblk|14331
||ppm|6,sfld1|||jump (error) if not variable name|14332
||mov|7,xr|13,vrfnc(xr)||else point to function block|14333
||bne|9,(xr)|22,=b_dfc|6,sfld1|error if not datatype function|14334
||bze|8,wb|6,exfal||fail if argument number is zero|14338
||bgt|8,wb|13,fargs(xr)|6,exfal|fail if too large|14339
||wtb|8,wb|||else convert to byte offset|14340
||add|7,xr|8,wb||point to field name|14341
||mov|7,xr|13,dfflb(xr)||load vrblk pointer|14342
||brn|6,exvnm|||exit to build nmblk|14343
|sfld1|erb|1,108|26,field first argument is not datatype name|||14347
||ejc|||||14348
|s_fnc|ent||||entry point|14352
||mov|8,wb|22,=p_fnc||set pcode for p_fnc|14353
||zer|7,xr|||p0blk|14354
||jsr|6,pbild|||build p_fnc node|14355
||mov|7,xl|7,xr||save pointer to it|14356
||mov|7,xr|10,(xs)+||get argument|14357
||jsr|6,gtpat|||convert to pattern|14358
||err|1,259|26,fence argument is not pattern|||14359
||jsr|6,pconc|||concatenate to p_fnc node|14360
||mov|7,xl|7,xr||save ptr to concatenated pattern|14361
||mov|8,wb|22,=p_fna||set for p_fna pcode|14362
||zer|7,xr|||p0blk|14363
||jsr|6,pbild|||construct p_fna node|14364
||mov|13,pthen(xr)|7,xl||set pattern as pthen|14365
||mov|11,-(xs)|7,xr||set as result|14366
||lcw|7,xr|||get next code word|14367
||bri|9,(xr)|||execute next code word|14368
||ejc|||||14369
|s_gef|ent||||entry point|14373
||jsr|6,acomp|||call arithmetic comparison routine|14374
||err|1,109|26,ge first argument is not numeric|||14375
||err|1,110|26,ge second argument is not numeric|||14376
||ppm|6,exfal|||fail if lt|14377
||ppm|6,exnul|||return null if eq|14378
||ppm|6,exnul|||return null if gt|14379
||ejc|||||14380
|s_gtf|ent||||entry point|14384
||jsr|6,acomp|||call arithmetic comparison routine|14385
||err|1,111|26,gt first argument is not numeric|||14386
||err|1,112|26,gt second argument is not numeric|||14387
||ppm|6,exfal|||fail if lt|14388
||ppm|6,exfal|||fail if eq|14389
||ppm|6,exnul|||return null if gt|14390
||ejc|||||14391
|s_hst|ent||||entry point|14395
||mov|8,wc|10,(xs)+||get fifth arg|14396
||mov|8,wb|10,(xs)+||get fourth arg|14397
||mov|7,xr|10,(xs)+||get third arg|14398
||mov|7,xl|10,(xs)+||get second arg|14399
||mov|8,wa|10,(xs)+||get first arg|14400
||jsr|6,syshs|||enter syshs routine|14401
||err|1,254|26,erroneous argument for host|||14402
||err|1,255|26,error during execution of host|||14403
||ppm|6,shst1|||store host string|14404
||ppm|6,exnul|||return null result|14405
||ppm|6,exixr|||return xr|14406
||ppm|6,exfal|||fail return|14407
||ppm|6,shst3|||store actual string|14408
||ppm|6,shst4|||return copy of xr|14409
|shst1|bze|7,xl|6,exnul||null string if syshs uncooperative|14413
||mov|8,wa|13,sclen(xl)||length|14414
||zer|8,wb|||zero offset|14415
|shst2|jsr|6,sbstr|||build copy of string|14419
||mov|11,-(xs)|7,xr||stack the result|14420
||lcw|7,xr|||load next code word|14421
||bri|9,(xr)|||execute it|14422
|shst3|zer|8,wb|||treat xl like an scblk ptr|14426
||sub|8,wb|18,=cfp_f||by creating a negative offset|14427
||brn|6,shst2|||join to copy string|14428
|shst4|mov|11,-(xs)|7,xr||stack results|14432
||jsr|6,copyb|||make copy of block|14433
||ppm|6,exits|||if not an aggregate structure|14434
||brn|6,exsid|||set current id value otherwise|14435
||ejc|||||14436
|s_idn|ent||||entry point|14440
||mov|7,xr|10,(xs)+||load second argument|14441
||mov|7,xl|10,(xs)+||load first argument|14442
||jsr|6,ident|||call ident comparison routine|14443
||ppm|6,exnul|||return null if ident|14444
||brn|6,exfal|||fail if differ|14445
||ejc|||||14446
|s_inp|ent||||entry point|14450
||zer|8,wb|||input flag|14451
||jsr|6,ioput|||call input/output assoc. routine|14452
||err|1,113|26,input third argument is not a string|||14453
||err|1,114|26,inappropriate second argument for input|||14454
||err|1,115|26,inappropriate first argument for input|||14455
||err|1,116|26,inappropriate file specification for input|||14456
||ppm|6,exfal|||fail if file does not exist|14457
||err|1,117|26,input file cannot be read|||14458
||err|1,289|26,input channel currently in use|||14459
||brn|6,exnul|||return null string|14460
||ejc|||||14461
|s_int|ent||||entry point|14494
||mov|7,xr|10,(xs)+||load argument|14495
||jsr|6,gtnum|||convert to numeric|14496
||ppm|6,exfal|||fail if non-numeric|14497
||beq|8,wa|22,=b_icl|6,exnul|return null if integer|14498
||brn|6,exfal|||fail if real|14499
||ejc|||||14500
|s_itm|ent||||entry point|14507
||bnz|8,wa|6,sitm1||jump if at least one arg|14511
||mov|11,-(xs)|21,=nulls||else supply garbage null arg|14512
||mov|8,wa|18,=num01||and fix argument count|14513
|sitm1|scp|7,xr|||get current code pointer|14517
||mov|7,xl|9,(xr)||load next code word|14518
||dcv|8,wa|||get number of subscripts|14519
||mov|7,xr|8,wa||copy for arref|14520
||beq|7,xl|21,=ofne_|6,sitm2|jump if called by name|14521
||zer|8,wb|||set code for call by value|14525
||brn|6,arref|||off to array reference routine|14526
|sitm2|mnz|8,wb|||set code for call by name|14530
||lcw|8,wa|||load and ignore ofne_ call|14531
||brn|6,arref|||off to array reference routine|14532
||ejc|||||14533
|s_lef|ent||||entry point|14537
||jsr|6,acomp|||call arithmetic comparison routine|14538
||err|1,118|26,le first argument is not numeric|||14539
||err|1,119|26,le second argument is not numeric|||14540
||ppm|6,exnul|||return null if lt|14541
||ppm|6,exnul|||return null if eq|14542
||ppm|6,exfal|||fail if gt|14543
||ejc|||||14544
|s_len|ent||||entry point|14548
||mov|8,wb|22,=p_len||set pcode for integer arg case|14549
||mov|8,wa|22,=p_lnd||set pcode for expr arg case|14550
||jsr|6,patin|||call common routine to build node|14551
||err|1,120|26,len argument is not integer or expression|||14552
||err|1,121|26,len argument is negative or too large|||14553
||mov|11,-(xs)|7,xr||stack result|14554
||lcw|7,xr|||get next code word|14555
||bri|9,(xr)|||execute it|14556
||ejc|||||14557
|s_leq|ent||||entry point|14561
||jsr|6,lcomp|||call string comparison routine|14562
||err|1,122|26,leq first argument is not a string|||14563
||err|1,123|26,leq second argument is not a string|||14564
||ppm|6,exfal|||fail if llt|14565
||ppm|6,exnul|||return null if leq|14566
||ppm|6,exfal|||fail if lgt|14567
||ejc|||||14568
|s_lge|ent||||entry point|14572
||jsr|6,lcomp|||call string comparison routine|14573
||err|1,124|26,lge first argument is not a string|||14574
||err|1,125|26,lge second argument is not a string|||14575
||ppm|6,exfal|||fail if llt|14576
||ppm|6,exnul|||return null if leq|14577
||ppm|6,exnul|||return null if lgt|14578
||ejc|||||14579
|s_lgt|ent||||entry point|14583
||jsr|6,lcomp|||call string comparison routine|14584
||err|1,126|26,lgt first argument is not a string|||14585
||err|1,127|26,lgt second argument is not a string|||14586
||ppm|6,exfal|||fail if llt|14587
||ppm|6,exfal|||fail if leq|14588
||ppm|6,exnul|||return null if lgt|14589
||ejc|||||14590
|s_lle|ent||||entry point|14594
||jsr|6,lcomp|||call string comparison routine|14595
||err|1,128|26,lle first argument is not a string|||14596
||err|1,129|26,lle second argument is not a string|||14597
||ppm|6,exnul|||return null if llt|14598
||ppm|6,exnul|||return null if leq|14599
||ppm|6,exfal|||fail if lgt|14600
||ejc|||||14601
|s_llt|ent||||entry point|14605
||jsr|6,lcomp|||call string comparison routine|14606
||err|1,130|26,llt first argument is not a string|||14607
||err|1,131|26,llt second argument is not a string|||14608
||ppm|6,exnul|||return null if llt|14609
||ppm|6,exfal|||fail if leq|14610
||ppm|6,exfal|||fail if lgt|14611
||ejc|||||14612
|s_lne|ent||||entry point|14616
||jsr|6,lcomp|||call string comparison routine|14617
||err|1,132|26,lne first argument is not a string|||14618
||err|1,133|26,lne second argument is not a string|||14619
||ppm|6,exnul|||return null if llt|14620
||ppm|6,exfal|||fail if leq|14621
||ppm|6,exnul|||return null if lgt|14622
||ejc|||||14623
|s_lnf|ent||||entry point|14628
||mov|7,xr|10,(xs)+||get argument|14629
||jsr|6,gtrea|||convert to real|14630
||err|1,306|26,ln argument not numeric|||14631
||ldr|13,rcval(xr)|||load accumulator with argument|14632
||req|6,slnf1|||overflow if argument is 0|14633
||rlt|6,slnf2|||error if argument less than 0|14634
||lnf||||take natural logarithm|14635
||rno|6,exrea|||if no overflow, return result in ra|14636
|slnf1|erb|1,307|26,ln produced real overflow|||14637
|slnf2|erb|1,315|26,ln argument negative|||14641
||ejc|||||14642
|s_loc|ent||||entry point|14647
||jsr|6,gtsmi|||get second argument (local number)|14648
||err|1,134|26,local second argument is not integer|||14649
||ppm|6,exfal|||fail if out of range|14650
||mov|8,wb|7,xr||save local number|14651
||mov|7,xr|10,(xs)+||load first argument|14652
||jsr|6,gtnvr|||point to vrblk|14653
||ppm|6,sloc1|||jump if not variable name|14654
||mov|7,xr|13,vrfnc(xr)||else load function pointer|14655
||bne|9,(xr)|22,=b_pfc|6,sloc1|jump if not program defined|14656
||bze|8,wb|6,exfal||fail if second arg is zero|14660
||bgt|8,wb|13,pfnlo(xr)|6,exfal|or too large|14661
||add|8,wb|13,fargs(xr)||else adjust offset to include args|14662
||wtb|8,wb|||convert to bytes|14663
||add|7,xr|8,wb||point to local pointer|14664
||mov|7,xr|13,pfagb(xr)||load vrblk pointer|14665
||brn|6,exvnm|||exit building nmblk|14666
|sloc1|erb|1,135|26,local first arg is not a program function name|||14670
||ejc|||||14673
|s_lod|ent||||entry point|14677
||jsr|6,gtstg|||load library name|14678
||err|1,136|26,load second argument is not a string|||14679
||mov|7,xl|7,xr||save library name|14680
||jsr|6,xscni|||prepare to scan first argument|14681
||err|1,137|26,load first argument is not a string|||14682
||err|1,138|26,load first argument is null|||14683
||mov|11,-(xs)|7,xl||stack library name|14684
||mov|8,wc|18,=ch_pp||set delimiter one = left paren|14685
||mov|7,xl|8,wc||set delimiter two = left paren|14686
||mnz|8,wa|||skip/trim blanks in prototype|14687
||jsr|6,xscan|||scan function name|14688
||mov|11,-(xs)|7,xr||save ptr to function name|14689
||bnz|8,wa|6,slod1||jump if left paren found|14690
||erb|1,139|26,load first argument is missing a left paren|||14691
|slod1|jsr|6,gtnvr|||locate vrblk|14695
||err|1,140|26,load first argument has null function name|||14696
||mov|3,lodfn|7,xr||save vrblk pointer|14697
||zer|3,lodna|||zero count of arguments|14698
|slod2|mov|8,wc|18,=ch_rp||delimiter one is right paren|14702
||mov|7,xl|18,=ch_cm||delimiter two is comma|14703
||mnz|8,wa|||skip/trim blanks in prototype|14704
||jsr|6,xscan|||scan next argument name|14705
||icv|3,lodna|||bump argument count|14706
||bnz|8,wa|6,slod3||jump if ok delimiter was found|14707
||erb|1,141|26,load first argument is missing a right paren|||14708
||ejc|||||14709
|slod3|mov|11,-(xs)|7,xr||stack datatype name pointer|14725
||mov|8,wb|18,=num01||set string code in case|14727
||mov|7,xl|21,=scstr||point to /string/|14728
||jsr|6,ident|||check for match|14729
||ppm|6,slod4|||jump if match|14730
||mov|7,xr|9,(xs)||else reload name|14731
||add|8,wb|8,wb||set code for integer (2)|14732
||mov|7,xl|21,=scint||point to /integer/|14733
||jsr|6,ident|||check for match|14734
||ppm|6,slod4|||jump if match|14735
||mov|7,xr|9,(xs)||else reload string pointer|14738
||icv|8,wb|||set code for real (3)|14739
||mov|7,xl|21,=screa||point to /real/|14740
||jsr|6,ident|||check for match|14741
||ppm|6,slod4|||jump if match|14742
||mov|7,xr|9,(xs)||reload string pointer|14745
||icv|8,wb|||code for file (4, or 3 if no reals)|14746
||mov|7,xl|21,=scfil||point to /file/|14747
||jsr|6,ident|||check for match|14748
||ppm|6,slod4|||jump if match|14749
||zer|8,wb|||else get code for no convert|14751
|slod4|mov|9,(xs)|8,wb||store code on stack|14755
||beq|8,wa|18,=num02|6,slod2|loop back if arg stopped by comma|14756
||bze|8,wa|6,slod5||jump if that was the result type|14757
||mov|8,wc|3,mxlen||set dummy (impossible) delimiter 1|14761
||mov|7,xl|8,wc||and delimiter two|14762
||mnz|8,wa|||skip/trim blanks in prototype|14763
||jsr|6,xscan|||scan result name|14764
||zer|8,wa|||set code for processing result|14765
||brn|6,slod3|||jump back to process result name|14766
||ejc|||||14767
|slod5|mov|8,wa|3,lodna||get number of arguments|14773
||mov|8,wc|8,wa||copy for later|14774
||wtb|8,wa|||convert length to bytes|14775
||add|8,wa|19,*efsi_||add space for standard fields|14776
||jsr|6,alloc|||allocate efblk|14777
||mov|9,(xr)|22,=b_efc||set type word|14778
||mov|13,fargs(xr)|8,wc||set number of arguments|14779
||zer|13,efuse(xr)|||set use count (dffnc will set to 1)|14780
||zer|13,efcod(xr)|||zero code pointer for now|14781
||mov|13,efrsl(xr)|10,(xs)+||store result type code|14782
||mov|13,efvar(xr)|3,lodfn||store function vrblk pointer|14783
||mov|13,eflen(xr)|8,wa||store efblk length|14784
||mov|8,wb|7,xr||save efblk pointer|14785
||add|7,xr|8,wa||point past end of efblk|14786
||lct|8,wc|8,wc||set number of arguments for loop|14787
|slod6|mov|11,-(xr)|10,(xs)+||store one type code from stack|14791
||bct|8,wc|6,slod6||loop till all stored|14792
||mov|7,xr|10,(xs)+||load function string name|14796
||mov|7,xl|9,(xs)||load library name|14801
||mov|9,(xs)|8,wb||store efblk pointer|14802
||jsr|6,sysld|||call function to load external func|14803
||err|1,142|26,load function does not exist|||14804
||err|1,143|26,load function caused input error during load|||14805
||err|1,328|26,load function - insufficient memory|||14806
||mov|7,xl|10,(xs)+||recall efblk pointer|14807
||mov|13,efcod(xl)|7,xr||store code pointer|14808
||mov|7,xr|3,lodfn||point to vrblk for function|14809
||jsr|6,dffnc|||perform function definition|14810
||brn|6,exnul|||return null result|14811
||ejc|||||14813
|s_lpd|ent||||entry point|14817
||jsr|6,gtstg|||get pad character|14818
||err|1,144|26,lpad third argument is not a string|||14819
||plc|7,xr|||point to character (null is blank)|14820
||lch|8,wb|9,(xr)||load pad character|14821
||jsr|6,gtsmi|||get pad length|14822
||err|1,145|26,lpad second argument is not integer|||14823
||ppm|6,slpd4|||skip if negative or large|14824
|slpd1|jsr|6,gtstg|||get first argument (string to pad)|14828
||err|1,146|26,lpad first argument is not a string|||14829
||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|14830
||mov|7,xl|7,xr||else move ptr to string to pad|14831
||mov|8,wa|8,wc||copy length|14839
||jsr|6,alocs|||allocate scblk for new string|14840
||mov|11,-(xs)|7,xr||save as result|14841
||mov|8,wa|13,sclen(xl)||load length of argument|14842
||sub|8,wc|8,wa||calculate number of pad characters|14843
||psc|7,xr|||point to chars in result string|14844
||lct|8,wc|8,wc||set counter for pad loop|14845
|slpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|14849
||bct|8,wc|6,slpd2||loop till all pad chars stored|14850
||csc|7,xr|||complete store characters|14851
||bze|8,wa|6,slpd3||exit if null string|14855
||plc|7,xl|||else point to chars in argument|14856
||mvc||||move characters to result string|14857
||zer|7,xl|||clear garbage xl|14858
|slpd3|lcw|7,xr|||load next code word|14862
||bri|9,(xr)|||execute it|14863
|slpd4|zer|8,wc|||zero pad count|14867
||brn|6,slpd1|||merge|14868
||ejc|||||14869
|s_ltf|ent||||entry point|14873
||jsr|6,acomp|||call arithmetic comparison routine|14874
||err|1,147|26,lt first argument is not numeric|||14875
||err|1,148|26,lt second argument is not numeric|||14876
||ppm|6,exnul|||return null if lt|14877
||ppm|6,exfal|||fail if eq|14878
||ppm|6,exfal|||fail if gt|14879
||ejc|||||14880
|s_nef|ent||||entry point|14884
||jsr|6,acomp|||call arithmetic comparison routine|14885
||err|1,149|26,ne first argument is not numeric|||14886
||err|1,150|26,ne second argument is not numeric|||14887
||ppm|6,exnul|||return null if lt|14888
||ppm|6,exfal|||fail if eq|14889
||ppm|6,exnul|||return null if gt|14890
||ejc|||||14891
|s_nay|ent||||entry point|14895
||mov|8,wb|22,=p_nas||set pcode for single char arg|14896
||mov|7,xl|22,=p_nay||pcode for multi-char arg|14897
||mov|8,wc|22,=p_nad||set pcode for expr arg|14898
||jsr|6,patst|||call common routine to build node|14899
||err|1,151|26,notany argument is not a string or expression|||14900
||mov|11,-(xs)|7,xr||stack result|14901
||lcw|7,xr|||get next code word|14902
||bri|9,(xr)|||execute it|14903
||ejc|||||14904
|s_ops|ent||||entry point|14908
||jsr|6,gtsmi|||load third argument|14909
||err|1,152|26,opsyn third argument is not integer|||14910
||err|1,153|26,opsyn third argument is negative or too large|||14911
||mov|8,wb|8,wc||if ok, save third argumnet|14912
||mov|7,xr|10,(xs)+||load second argument|14913
||jsr|6,gtnvr|||locate variable block|14914
||err|1,154|26,opsyn second arg is not natural variable name|||14915
||mov|7,xl|13,vrfnc(xr)||if ok, load function block pointer|14916
||bnz|8,wb|6,sops2||jump if operator opsyn case|14917
||mov|7,xr|10,(xs)+||load first argument|14921
||jsr|6,gtnvr|||get vrblk pointer|14922
||err|1,155|26,opsyn first arg is not natural variable name|||14923
|sops1|jsr|6,dffnc|||call function definer|14927
||brn|6,exnul|||exit with null result|14928
|sops2|jsr|6,gtstg|||get operator name|14932
||ppm|6,sops5|||jump if not string|14933
||bne|8,wa|18,=num01|6,sops5|error if not one char long|14934
||plc|7,xr|||else point to character|14935
||lch|8,wc|9,(xr)||load character name|14936
||ejc|||||14937
||mov|8,wa|20,=r_uub||point to unop pointers in case|14945
||mov|7,xr|21,=opnsu||point to names of unary operators|14946
||add|8,wb|18,=opbun||add no. of undefined binary ops|14947
||beq|8,wb|18,=opuun|6,sops3|jump if unop (third arg was 1)|14948
||mov|8,wa|20,=r_uba||else point to binary operator ptrs|14949
||mov|7,xr|21,=opsnb||point to names of binary operators|14950
||mov|8,wb|18,=opbun||set number of undefined binops|14951
|sops3|lct|8,wb|8,wb||set counter to control loop|14955
|sops4|beq|8,wc|9,(xr)|6,sops6|jump if names match|14959
||ica|8,wa|||else push pointer to function ptr|14960
||ica|7,xr|||bump pointer|14961
||bct|8,wb|6,sops4||loop back till all checked|14962
|sops5|erb|1,156|26,opsyn first arg is not correct operator name|||14966
|sops6|mov|7,xr|8,wa||copy pointer to function block ptr|14970
||sub|7,xr|19,*vrfnc||make it look like dummy vrblk|14971
||brn|6,sops1|||merge back to define operator|14972
||ejc|||||14973
|s_oup|ent||||entry point|14998
||mov|8,wb|18,=num03||output flag|14999
||jsr|6,ioput|||call input/output assoc. routine|15000
||err|1,157|26,output third argument is not a string|||15001
||err|1,158|26,inappropriate second argument for output|||15002
||err|1,159|26,inappropriate first argument for output|||15003
||err|1,160|26,inappropriate file specification for output|||15004
||ppm|6,exfal|||fail if file does not exist|15005
||err|1,161|26,output file cannot be written to|||15006
||err|1,290|26,output channel currently in use|||15007
||brn|6,exnul|||return null string|15008
||ejc|||||15009
|s_pos|ent||||entry point|15013
||mov|8,wb|22,=p_pos||set pcode for integer arg case|15014
||mov|8,wa|22,=p_psd||set pcode for expression arg case|15015
||jsr|6,patin|||call common routine to build node|15016
||err|1,162|26,pos argument is not integer or expression|||15017
||err|1,163|26,pos argument is negative or too large|||15018
||mov|11,-(xs)|7,xr||stack result|15019
||lcw|7,xr|||get next code word|15020
||bri|9,(xr)|||execute it|15021
||ejc|||||15022
|s_pro|ent||||entry point|15026
||mov|7,xr|10,(xs)+||load argument|15027
||mov|8,wb|13,tblen(xr)||length if table, vector (=vclen)|15028
||btw|8,wb|||convert to words|15029
||mov|8,wa|9,(xr)||load type word of argument block|15030
||beq|8,wa|22,=b_art|6,spro4|jump if array|15031
||beq|8,wa|22,=b_tbt|6,spro1|jump if table|15032
||beq|8,wa|22,=b_vct|6,spro3|jump if vector|15033
||erb|1,164|26,prototype argument is not valid object|||15038
|spro1|sub|8,wb|18,=tbsi_||subtract standard fields|15042
|spro2|mti|8,wb|||convert to integer|15046
||brn|6,exint|||exit with integer result|15047
|spro3|sub|8,wb|18,=vcsi_||subtract standard fields|15051
||brn|6,spro2|||merge|15052
|spro4|add|7,xr|13,arofs(xr)||point to prototype field|15056
||mov|7,xr|9,(xr)||load prototype|15057
||mov|11,-(xs)|7,xr||stack result|15058
||lcw|7,xr|||get next code word|15059
||bri|9,(xr)|||execute it|15060
||ejc|||||15070
|s_rmd|ent||||entry point|15074
||jsr|6,arith|||get two integers or two reals|15076
||err|1,166|26,remdr first argument is not numeric|||15077
||err|1,165|26,remdr second argument is not numeric|||15078
||ppm|6,srm06|||if real|15079
||zer|8,wb|||set positive flag|15096
||ldi|13,icval(xr)|||load left argument value|15097
||ige|6,srm01|||jump if positive|15098
||mnz|8,wb|||set negative flag|15099
|srm01|rmi|13,icval(xl)|||get remainder|15100
||iov|6,srm05|||error if overflow|15101
||bze|8,wb|6,srm03||if result should be positive|15105
||ile|6,exint|||if should be negative, and is|15106
|srm02|ngi||||adjust sign of result|15107
||brn|6,exint|||return result|15108
|srm03|ilt|6,srm02|||should be pos, and result negative|15109
||brn|6,exint|||should be positive, and is|15110
|srm04|erb|1,166|26,remdr first argument is not numeric|||15114
|srm05|erb|1,167|26,remdr caused integer overflow|||15118
|srm06|zer|8,wb|||set positive flag|15125
||ldr|13,rcval(xr)|||load left argument value|15126
||rge|6,srm07|||jump if positive|15127
||mnz|8,wb|||set negative flag|15128
|srm07|dvr|13,rcval(xl)|||compute n1/n2|15129
||rov|6,srm10|||jump if overflow|15130
||chp||||chop result|15131
||mlr|13,rcval(xl)|||times n2|15132
||sbr|13,rcval(xr)|||compute difference|15133
||bze|8,wb|6,srm09||if result should be positive|15138
||rle|6,exrea|||if should be negative, and is|15139
|srm08|ngr||||adjust sign of result|15140
||brn|6,exrea|||return result|15141
|srm09|rlt|6,srm08|||should be pos, and result negative|15142
||brn|6,exrea|||should be positive, and is|15143
|srm10|erb|1,312|26,remdr caused real overflow|||15147
||ejc|||||15149
|s_rpl|ent||||entry point|15163
||jsr|6,gtstg|||load third argument as string|15164
||err|1,168|26,replace third argument is not a string|||15165
||mov|7,xl|7,xr||save third arg ptr|15166
||jsr|6,gtstg|||get second argument|15167
||err|1,169|26,replace second argument is not a string|||15168
||bne|7,xr|3,r_ra2|6,srpl1|jump if 2nd argument different|15172
||beq|7,xl|3,r_ra3|6,srpl4|jump if args same as last time|15173
|srpl1|mov|8,wb|13,sclen(xl)||load 3rd argument length|15177
||bne|8,wa|8,wb|6,srpl6|jump if arguments not same length|15178
||beq|7,xr|3,kvalp|6,srpl5|jump if 2nd arg is alphabet string|15179
||bze|8,wb|6,srpl6||jump if null 2nd argument|15180
||mov|3,r_ra3|7,xl||save third arg for next time in|15181
||mov|3,r_ra2|7,xr||save second arg for next time in|15182
||mov|7,xl|3,kvalp||point to alphabet string|15183
||mov|8,wa|13,sclen(xl)||load alphabet scblk length|15184
||mov|7,xr|3,r_rpt||point to current table (if any)|15185
||bnz|7,xr|6,srpl2||jump if we already have a table|15186
||jsr|6,alocs|||allocate new table|15190
||mov|8,wa|8,wc||keep scblk length|15191
||mov|3,r_rpt|7,xr||save table pointer for next time|15192
|srpl2|ctb|8,wa|2,scsi_||compute length of scblk|15196
||mvw||||copy to get initial table values|15197
||ejc|||||15198
||mov|7,xl|3,r_ra2||point to second argument|15206
||lct|8,wb|8,wb||number of chars to plug|15207
||zer|8,wc|||zero char offset|15208
||mov|7,xr|3,r_ra3||point to 3rd arg|15209
||plc|7,xr|||get char ptr for 3rd arg|15210
|srpl3|mov|7,xl|3,r_ra2||point to 2nd arg|15214
||plc|7,xl|8,wc||point to next char|15215
||icv|8,wc|||increment offset|15216
||lch|8,wa|9,(xl)||get next char|15217
||mov|7,xl|3,r_rpt||point to translate table|15218
||psc|7,xl|8,wa||convert char to offset into table|15219
||lch|8,wa|10,(xr)+||get translated char|15220
||sch|8,wa|9,(xl)||store in table|15221
||csc|7,xl|||complete store characters|15222
||bct|8,wb|6,srpl3||loop till done|15223
||ejc|||||15224
|srpl4|mov|7,xl|3,r_rpt||replace table to use|15230
|srpl5|jsr|6,gtstg|||get first argument|15235
||err|1,170|26,replace first argument is not a string|||15236
||bze|8,wa|6,exnul||return null if null argument|15245
||mov|11,-(xs)|7,xl||stack replace table to use|15246
||mov|7,xl|7,xr||copy pointer|15247
||mov|8,wc|8,wa||save length|15248
||ctb|8,wa|2,schar||get scblk length|15249
||jsr|6,alloc|||allocate space for copy|15250
||mov|8,wb|7,xr||save address of copy|15251
||mvw||||move scblk contents to copy|15252
||mov|7,xr|10,(xs)+||unstack replace table|15253
||plc|7,xr|||point to chars of table|15254
||mov|7,xl|8,wb||point to string to translate|15255
||plc|7,xl|||point to chars of string|15256
||mov|8,wa|8,wc||set number of chars to translate|15257
||trc||||perform translation|15258
|srpl8|mov|11,-(xs)|8,wb||stack result|15259
||lcw|7,xr|||load next code word|15260
||bri|9,(xr)|||execute it|15261
|srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||15265
||ejc|||||15280
|s_rew|ent||||entry point|15284
||jsr|6,iofcb|||call fcblk routine|15285
||err|1,172|26,rewind argument is not a suitable name|||15286
||err|1,173|26,rewind argument is null|||15287
||err|1,174|26,rewind file does not exist|||15288
||jsr|6,sysrw|||call system rewind function|15289
||err|1,174|26,rewind file does not exist|||15290
||err|1,175|26,rewind file does not permit rewind|||15291
||err|1,176|26,rewind caused non-recoverable error|||15292
||brn|6,exnul|||exit with null result if no error|15293
||ejc|||||15294
|s_rvs|ent||||entry point|15298
||jsr|6,gtstg|||load string argument|15300
||err|1,177|26,reverse argument is not a string|||15301
||bze|8,wa|6,exixr||return argument if null|15307
||mov|7,xl|7,xr||else save pointer to string arg|15308
||jsr|6,alocs|||allocate space for new scblk|15309
||mov|11,-(xs)|7,xr||store scblk ptr on stack as result|15310
||psc|7,xr|||prepare to store in new scblk|15311
||plc|7,xl|8,wc||point past last char in argument|15312
||lct|8,wc|8,wc||set loop counter|15313
|srvs1|lch|8,wb|11,-(xl)||load next char from argument|15317
||sch|8,wb|10,(xr)+||store in result|15318
||bct|8,wc|6,srvs1||loop till all moved|15319
|srvs4|csc|7,xr|||complete store characters|15323
||zer|7,xl|||clear garbage xl|15324
|srvs2|lcw|7,xr|||load next code word|15325
||bri|9,(xr)|||execute it|15326
||ejc|||||15350
|s_rpd|ent||||entry point|15354
||jsr|6,gtstg|||get pad character|15355
||err|1,178|26,rpad third argument is not a string|||15356
||plc|7,xr|||point to character (null is blank)|15357
||lch|8,wb|9,(xr)||load pad character|15358
||jsr|6,gtsmi|||get pad length|15359
||err|1,179|26,rpad second argument is not integer|||15360
||ppm|6,srpd3|||skip if negative or large|15361
|srpd1|jsr|6,gtstg|||get first argument (string to pad)|15365
||err|1,180|26,rpad first argument is not a string|||15366
||bge|8,wa|8,wc|6,exixr|return 1st arg if too long to pad|15367
||mov|7,xl|7,xr||else move ptr to string to pad|15368
||mov|8,wa|8,wc||copy length|15376
||jsr|6,alocs|||allocate scblk for new string|15377
||mov|11,-(xs)|7,xr||save as result|15378
||mov|8,wa|13,sclen(xl)||load length of argument|15379
||sub|8,wc|8,wa||calculate number of pad characters|15380
||psc|7,xr|||point to chars in result string|15381
||lct|8,wc|8,wc||set counter for pad loop|15382
||bze|8,wa|6,srpd2||jump if argument is null|15386
||plc|7,xl|||else point to argument chars|15387
||mvc||||move characters to result string|15388
||zer|7,xl|||clear garbage xl|15389
|srpd2|sch|8,wb|10,(xr)+||store pad character, bump ptr|15393
||bct|8,wc|6,srpd2||loop till all pad chars stored|15394
||csc|7,xr|||complete character storing|15395
||lcw|7,xr|||load next code word|15396
||bri|9,(xr)|||execute it|15397
|srpd3|zer|8,wc|||zero pad count|15401
||brn|6,srpd1|||merge|15402
||ejc|||||15403
|s_rtb|ent||||entry point|15407
||mov|8,wb|22,=p_rtb||set pcode for integer arg case|15408
||mov|8,wa|22,=p_rtd||set pcode for expression arg case|15409
||jsr|6,patin|||call common routine to build node|15410
||err|1,181|26,rtab argument is not integer or expression|||15411
||err|1,182|26,rtab argument is negative or too large|||15412
||mov|11,-(xs)|7,xr||stack result|15413
||lcw|7,xr|||get next code word|15414
||bri|9,(xr)|||execute it|15415
||ejc|||||15416
|s_tab|ent||||entry point|15457
||mov|8,wb|22,=p_tab||set pcode for integer arg case|15458
||mov|8,wa|22,=p_tbd||set pcode for expression arg case|15459
||jsr|6,patin|||call common routine to build node|15460
||err|1,183|26,tab argument is not integer or expression|||15461
||err|1,184|26,tab argument is negative or too large|||15462
||mov|11,-(xs)|7,xr||stack result|15463
||lcw|7,xr|||get next code word|15464
||bri|9,(xr)|||execute it|15465
||ejc|||||15466
|s_rps|ent||||entry point|15470
||mov|8,wb|22,=p_rps||set pcode for integer arg case|15471
||mov|8,wa|22,=p_rpd||set pcode for expression arg case|15472
||jsr|6,patin|||call common routine to build node|15473
||err|1,185|26,rpos argument is not integer or expression|||15474
||err|1,186|26,rpos argument is negative or too large|||15475
||mov|11,-(xs)|7,xr||stack result|15476
||lcw|7,xr|||get next code word|15477
||bri|9,(xr)|||execute it|15478
||ejc|||||15481
|s_rsr|ent||||entry point|15485
||mnz|8,wa|||mark as rsort|15486
||jsr|6,sorta|||call sort routine|15487
||ppm|6,exfal|||if conversion fails, so shall we|15488
||brn|6,exsid|||return, setting idval|15489
||ejc|||||15491
|s_stx|ent||||entry point|15495
||mov|7,xr|10,(xs)+||load argument|15496
||mov|8,wa|3,stxvr||load old vrblk pointer|15497
||zer|7,xl|||load zero in case null arg|15498
||beq|7,xr|21,=nulls|6,sstx1|jump if null argument (reset call)|15499
||jsr|6,gtnvr|||else get specified vrblk|15500
||ppm|6,sstx2|||jump if not natural variable|15501
||mov|7,xl|13,vrlbl(xr)||else load label|15502
||beq|7,xl|21,=stndl|6,sstx2|jump if label is not defined|15503
||bne|9,(xl)|22,=b_trt|6,sstx1|jump if not trapped|15504
||mov|7,xl|13,trlbl(xl)||else load ptr to real label code|15505
|sstx1|mov|3,stxvr|7,xr||store new vrblk pointer (or null)|15509
||mov|3,r_sxc|7,xl||store new code ptr (or zero)|15510
||beq|8,wa|21,=nulls|6,exnul|return null if null result|15511
||mov|7,xr|8,wa||else copy vrblk pointer|15512
||brn|6,exvnm|||and return building nmblk|15513
|sstx2|erb|1,187|26,setexit argument is not label name or null|||15517
|s_sin|ent||||entry point|15522
||mov|7,xr|10,(xs)+||get argument|15523
||jsr|6,gtrea|||convert to real|15524
||err|1,308|26,sin argument not numeric|||15525
||ldr|13,rcval(xr)|||load accumulator with argument|15526
||sin||||take sine|15527
||rno|6,exrea|||if no overflow, return result in ra|15528
||erb|1,323|26,sin argument is out of range|||15529
||ejc|||||15530
|s_sqr|ent||||entry point|15536
||mov|7,xr|10,(xs)+||get argument|15537
||jsr|6,gtrea|||convert to real|15538
||err|1,313|26,sqrt argument not numeric|||15539
||ldr|13,rcval(xr)|||load accumulator with argument|15540
||rlt|6,ssqr1|||negative number|15541
||sqr||||take square root|15542
||brn|6,exrea|||no overflow possible, result in ra|15543
|ssqr1|erb|1,314|26,sqrt argument negative|||15547
||ejc|||||15548
||ejc|||||15552
|s_srt|ent||||entry point|15556
||zer|8,wa|||mark as sort|15557
||jsr|6,sorta|||call sort routine|15558
||ppm|6,exfal|||if conversion fails, so shall we|15559
||brn|6,exsid|||return, setting idval|15560
||ejc|||||15562
|s_spn|ent||||entry point|15566
||mov|8,wb|22,=p_sps||set pcode for single char arg|15567
||mov|7,xl|22,=p_spn||set pcode for multi-char arg|15568
||mov|8,wc|22,=p_spd||set pcode for expression arg|15569
||jsr|6,patst|||call common routine to build node|15570
||err|1,188|26,span argument is not a string or expression|||15571
||mov|11,-(xs)|7,xr||stack result|15572
||lcw|7,xr|||get next code word|15573
||bri|9,(xr)|||execute it|15574
||ejc|||||15575
|s_si_|ent||||entry point|15579
||jsr|6,gtstg|||load string argument|15581
||err|1,189|26,size argument is not a string|||15582
||mti|8,wa|||load length as integer|15590
||brn|6,exint|||exit with integer result|15591
||ejc|||||15592
|s_stt|ent||||entry point|15596
||zer|7,xl|||indicate stoptr case|15597
||jsr|6,trace|||call trace procedure|15598
||err|1,190|26,stoptr first argument is not appropriate name|||15599
||err|1,191|26,stoptr second argument is not trace type|||15600
||brn|6,exnul|||return null|15601
||ejc|||||15602
|s_sub|ent||||entry point|15606
||jsr|6,gtsmi|||load third argument|15607
||err|1,192|26,substr third argument is not integer|||15608
||ppm|6,exfal|||jump if negative or too large|15609
||mov|3,sbssv|7,xr||save third argument|15610
||jsr|6,gtsmi|||load second argument|15611
||err|1,193|26,substr second argument is not integer|||15612
||ppm|6,exfal|||jump if out of range|15613
||mov|8,wc|7,xr||save second argument|15614
||bze|8,wc|6,exfal||jump if second argument zero|15615
||dcv|8,wc|||else decrement for ones origin|15616
||jsr|6,gtstg|||load first argument|15618
||err|1,194|26,substr first argument is not a string|||15619
||mov|8,wb|8,wc||copy second arg to wb|15627
||mov|8,wc|3,sbssv||reload third argument|15628
||bnz|8,wc|6,ssub2||skip if third arg given|15629
||mov|8,wc|8,wa||else get string length|15630
||bgt|8,wb|8,wc|6,exfal|fail if improper|15631
||sub|8,wc|8,wb||reduce by offset to start|15632
|ssub2|mov|7,xl|8,wa||save string length|15636
||mov|8,wa|8,wc||set length of substring|15637
||add|8,wc|8,wb||add 2nd arg to 3rd arg|15638
||bgt|8,wc|7,xl|6,exfal|jump if improper substring|15639
||mov|7,xl|7,xr||copy pointer to first arg|15640
||jsr|6,sbstr|||build substring|15641
||mov|11,-(xs)|7,xr||stack result|15642
||lcw|7,xr|||get next code word|15643
||bri|9,(xr)|||execute it|15644
||ejc|||||15645
|s_tbl|ent||||entry point|15649
||mov|7,xl|10,(xs)+||get initial lookup value|15650
||ica|7,xs|||pop second argument|15651
||jsr|6,gtsmi|||load argument|15652
||err|1,195|26,table argument is not integer|||15653
||err|1,196|26,table argument is out of range|||15654
||bnz|8,wc|6,stbl1||jump if non-zero|15655
||mov|8,wc|18,=tbnbk||else supply default value|15656
|stbl1|jsr|6,tmake|||make table|15660
||brn|6,exsid|||exit setting idval|15661
||ejc|||||15662
|s_tan|ent||||entry point|15667
||mov|7,xr|10,(xs)+||get argument|15668
||jsr|6,gtrea|||convert to real|15669
||err|1,309|26,tan argument not numeric|||15670
||ldr|13,rcval(xr)|||load accumulator with argument|15671
||tan||||take tangent|15672
||rno|6,exrea|||if no overflow, return result in ra|15673
||erb|1,310|26,tan produced real overflow or argument is out of range|||15674
||ejc|||||15675
|s_tim|ent||||entry point|15680
||jsr|6,systm|||get timer value|15681
||sbi|3,timsx|||subtract starting time|15682
||brn|6,exint|||exit with integer value|15683
||ejc|||||15684
|s_tra|ent||||entry point|15688
||beq|13,num03(xs)|21,=nulls|6,str02|jump if first argument is null|15689
||mov|7,xr|10,(xs)+||load fourth argument|15690
||zer|7,xl|||tentatively set zero pointer|15691
||beq|7,xr|21,=nulls|6,str01|jump if 4th argument is null|15692
||jsr|6,gtnvr|||else point to vrblk|15693
||ppm|6,str03|||jump if not variable name|15694
||mov|7,xl|7,xr||else save vrblk in trfnc|15695
|str01|mov|7,xr|10,(xs)+||load third argument (tag)|15699
||zer|8,wb|||set zero as trtyp value for now|15700
||jsr|6,trbld|||build trblk for trace call|15701
||mov|7,xl|7,xr||move trblk pointer for trace|15702
||jsr|6,trace|||call trace procedure|15703
||err|1,198|26,trace first argument is not appropriate name|||15704
||err|1,199|26,trace second argument is not trace type|||15705
||brn|6,exnul|||return null|15706
|str02|jsr|6,systt|||call it|15710
||add|7,xs|19,*num04||pop trace arguments|15711
||brn|6,exnul|||return|15712
|str03|erb|1,197|26,trace fourth arg is not function name or null|||15716
||ejc|||||15717
|s_trm|ent||||entry point|15721
||jsr|6,gtstg|||load argument as string|15723
||err|1,200|26,trim argument is not a string|||15724
||bze|8,wa|6,exnul||return null if argument is null|15730
||mov|7,xl|7,xr||copy string pointer|15731
||ctb|8,wa|2,schar||get block length|15732
||jsr|6,alloc|||allocate copy same size|15733
||mov|8,wb|7,xr||save pointer to copy|15734
||mvw||||copy old string block to new|15735
||mov|7,xr|8,wb||restore ptr to new block|15736
||jsr|6,trimr|||trim blanks (wb is non-zero)|15737
||mov|11,-(xs)|7,xr||stack result|15738
||lcw|7,xr|||get next code word|15739
||bri|9,(xr)|||execute it|15740
||ejc|||||15783
|s_unl|ent||||entry point|15787
||mov|7,xr|10,(xs)+||load argument|15788
||jsr|6,gtnvr|||point to vrblk|15789
||err|1,201|26,unload argument is not natural variable name|||15790
||mov|7,xl|21,=stndf||get ptr to undefined function|15791
||jsr|6,dffnc|||undefine named function|15792
||brn|6,exnul|||return null as result|15793
||ttl|27,s p i t b o l -- utility routines||||15815
||ejc|||||15837
|arref|rtn|||||15853
||mov|8,wa|7,xr||copy number of subscripts|15854
||mov|7,xt|7,xs||point to stack front|15855
||wtb|7,xr|||convert to byte offset|15856
||add|7,xt|7,xr||point to array operand on stack|15857
||ica|7,xt|||final value for stack popping|15858
||mov|3,arfxs|7,xt||keep for later|15859
||mov|7,xr|11,-(xt)||load array operand pointer|15860
||mov|3,r_arf|7,xr||keep array pointer|15861
||mov|7,xr|7,xt||save pointer to subscripts|15862
||mov|7,xl|3,r_arf||point xl to possible vcblk or tbblk|15863
||mov|8,wc|9,(xl)||load first word|15864
||beq|8,wc|22,=b_art|6,arf01|jump if arblk|15865
||beq|8,wc|22,=b_vct|6,arf07|jump if vcblk|15866
||beq|8,wc|22,=b_tbt|6,arf10|jump if tbblk|15867
||erb|1,235|26,subscripted operand is not table or array|||15868
|arf01|bne|8,wa|13,arndm(xl)|6,arf09|jump if wrong number of dims|15872
||ldi|4,intv0|||get initial subscript of zero|15873
||mov|7,xt|7,xr||point before subscripts|15874
||zer|8,wa|||initial offset to bounds|15875
||brn|6,arf03|||jump into loop|15876
|arf02|mli|13,ardm2(xr)|||multiply total by next dimension|15880
|arf03|mov|7,xr|11,-(xt)||load next subscript|15884
||sti|3,arfsi|||save current subscript|15885
||ldi|13,icval(xr)|||load integer value in case|15886
||beq|9,(xr)|22,=b_icl|6,arf04|jump if it was an integer|15887
||ejc|||||15888
||jsr|6,gtint|||convert to integer|15893
||ppm|6,arf12|||jump if not integer|15894
||ldi|13,icval(xr)|||if ok, load integer value|15895
|arf04|mov|7,xr|3,r_arf||point to array|15899
||add|7,xr|8,wa||offset to next bounds|15900
||sbi|13,arlbd(xr)|||subtract low bound to compare|15901
||iov|6,arf13|||out of range fail if overflow|15902
||ilt|6,arf13|||out of range fail if too small|15903
||sbi|13,ardim(xr)|||subtract dimension|15904
||ige|6,arf13|||out of range fail if too large|15905
||adi|13,ardim(xr)|||else restore subscript offset|15906
||adi|3,arfsi|||add to current total|15907
||add|8,wa|19,*ardms||point to next bounds|15908
||bne|7,xt|7,xs|6,arf02|loop back if more to go|15909
||mfi|8,wa|||get as one word integer|15913
||wtb|8,wa|||convert to offset|15914
||mov|7,xl|3,r_arf||point to arblk|15915
||add|8,wa|13,arofs(xl)||add offset past bounds|15916
||ica|8,wa|||adjust for arpro field|15917
||bnz|8,wb|6,arf08||exit with name if name call|15918
|arf05|jsr|6,acess|||get value|15922
||ppm|6,arf13|||fail if acess fails|15923
|arf06|mov|7,xs|3,arfxs||pop stack entries|15927
||zer|3,r_arf|||finished with array pointer|15928
||mov|11,-(xs)|7,xr||stack result|15929
||lcw|7,xr|||get next code word|15930
||bri|9,(xr)|||execute it|15931
||ejc|||||15932
|arf07|bne|8,wa|18,=num01|6,arf09|error if more than 1 subscript|15938
||mov|7,xr|9,(xs)||else load subscript|15939
||jsr|6,gtint|||convert to integer|15940
||ppm|6,arf12|||error if not integer|15941
||ldi|13,icval(xr)|||else load integer value|15942
||sbi|4,intv1|||subtract for ones offset|15943
||mfi|8,wa|6,arf13||get subscript as one word|15944
||add|8,wa|18,=vcvls||add offset for standard fields|15945
||wtb|8,wa|||convert offset to bytes|15946
||bge|8,wa|13,vclen(xl)|6,arf13|fail if out of range subscript|15947
||bze|8,wb|6,arf05||back to get value if value call|15948
|arf08|mov|7,xs|3,arfxs||pop stack entries|15952
||zer|3,r_arf|||finished with array pointer|15953
||brn|6,exnam|||else exit with name|15954
|arf09|erb|1,236|26,array referenced with wrong number of subscripts|||15958
|arf10|bne|8,wa|18,=num01|6,arf11|error if more than 1 subscript|15962
||mov|7,xr|9,(xs)||else load subscript|15963
||jsr|6,tfind|||call table search routine|15964
||ppm|6,arf13|||fail if failed|15965
||bnz|8,wb|6,arf08||exit with name if name call|15966
||brn|6,arf06|||else exit with value|15967
|arf11|erb|1,237|26,table referenced with more than one subscript|||15971
|arf12|erb|1,238|26,array subscript is not integer|||15975
|arf13|zer|3,r_arf|||finished with array pointer|15979
||brn|6,exfal|||fail|15980
||ejc|||||15981
|cfunc|rtn|||||15998
||blt|8,wa|13,fargs(xl)|6,cfnc1|jump if too few arguments|15999
||beq|8,wa|13,fargs(xl)|6,cfnc3|jump if correct number of args|16000
||mov|8,wb|8,wa||copy actual number|16004
||sub|8,wb|13,fargs(xl)||get number of extra args|16005
||wtb|8,wb|||convert to bytes|16006
||add|7,xs|8,wb||pop off unwanted arguments|16007
||brn|6,cfnc3|||jump to go off to function|16008
|cfnc1|mov|8,wb|13,fargs(xl)||load required number of arguments|16012
||beq|8,wb|18,=nini9|6,cfnc3|jump if case of var num of args|16013
||sub|8,wb|8,wa||calculate number missing|16014
||lct|8,wb|8,wb||set counter to control loop|16015
|cfnc2|mov|11,-(xs)|21,=nulls||stack a null argument|16019
||bct|8,wb|6,cfnc2||loop till proper number stacked|16020
|cfnc3|bri|9,(xl)|||jump through fcode field|16024
||ejc|||||16025
|exfal|rtn|||||16034
||mov|7,xs|3,flptr||pop stack|16035
||mov|7,xr|9,(xs)||load failure offset|16036
||add|7,xr|3,r_cod||point to failure code location|16037
||lcp|7,xr|||set code pointer|16038
||lcw|7,xr|||load next code word|16039
||mov|7,xl|9,(xr)||load entry address|16040
||bri|7,xl|||jump to execute next code word|16041
||ejc|||||16042
|exint|rtn|||||16053
||zer|7,xl|||clear dud value|16054
||jsr|6,icbld|||build icblk|16055
||ejc|||||16056
|exixr|rtn|||||16065
||mov|11,-(xs)|7,xr||stack result|16067
|exits|rtn|||||16076
||lcw|7,xr|||load next code word|16077
||mov|7,xl|9,(xr)||load entry address|16078
||bri|7,xl|||jump to execute next code word|16079
||ejc|||||16080
|exnam|rtn|||||16091
||mov|11,-(xs)|7,xl||stack name base|16092
||mov|11,-(xs)|8,wa||stack name offset|16093
||lcw|7,xr|||load next code word|16094
||bri|9,(xr)|||execute it|16095
||ejc|||||16096
|exnul|rtn|||||16105
||mov|11,-(xs)|21,=nulls||stack null value|16106
||lcw|7,xr|||load next code word|16107
||mov|7,xl|9,(xr)||load entry address|16108
||bri|7,xl|||jump to execute next code word|16109
||ejc|||||16110
|exrea|rtn|||||16122
||zer|7,xl|||clear dud value|16123
||jsr|6,rcbld|||build rcblk|16124
||brn|6,exixr|||jump to exit with result in xr|16125
||ejc|||||16127
|exsid|rtn|||||16140
||mov|8,wa|3,curid||load current id value|16141
||bne|8,wa|3,mxint|6,exsi1|jump if no overflow|16142
||zer|8,wa|||else reset for wraparound|16143
|exsi1|icv|8,wa|||bump id value|16147
||mov|3,curid|8,wa||store for next time|16148
||mov|13,idval(xr)|8,wa||store id value|16149
||brn|6,exixr|||exit with result in (xr)|16150
||ejc|||||16151
|exvnm|rtn|||||16162
||mov|7,xl|7,xr||copy name base pointer|16163
||mov|8,wa|19,*nmsi_||set size of nmblk|16164
||jsr|6,alloc|||allocate nmblk|16165
||mov|9,(xr)|22,=b_nml||store type word|16166
||mov|13,nmbas(xr)|7,xl||store name base|16167
||mov|13,nmofs(xr)|19,*vrval||store name offset|16168
||brn|6,exixr|||exit with result in xr|16169
||ejc|||||16170
|flpop|rtn|||||16180
||add|7,xs|19,*num02||pop two entries off stack|16181
||ejc|||||16182
|failp|rtn|||||16194
||mov|7,xr|10,(xs)+||load alternative node pointer|16195
||mov|8,wb|10,(xs)+||restore old cursor|16196
||mov|7,xl|9,(xr)||load pcode entry pointer|16197
||bri|7,xl|||jump to execute code for node|16198
||ejc|||||16199
|indir|rtn|||||16208
||mov|7,xr|10,(xs)+||load argument|16209
||beq|9,(xr)|22,=b_nml|6,indr2|jump if a name|16210
||jsr|6,gtnvr|||else convert to variable|16211
||err|1,239|26,indirection operand is not name|||16212
||bze|8,wb|6,indr1||skip if by value|16213
||mov|11,-(xs)|7,xr||else stack vrblk ptr|16214
||mov|11,-(xs)|19,*vrval||stack name offset|16215
||lcw|7,xr|||load next code word|16216
||mov|7,xl|9,(xr)||load entry address|16217
||bri|7,xl|||jump to execute next code word|16218
|indr1|bri|9,(xr)|||jump through vrget field of vrblk|16222
|indr2|mov|7,xl|13,nmbas(xr)||load name base|16226
||mov|8,wa|13,nmofs(xr)||load name offset|16227
||bnz|8,wb|6,exnam||exit if called by name|16228
||jsr|6,acess|||else get value first|16229
||ppm|6,exfal|||fail if access fails|16230
||brn|6,exixr|||else return with value in xr|16231
||ejc|||||16232
|match|rtn|||||16242
||mov|7,xr|10,(xs)+||load pattern operand|16243
||jsr|6,gtpat|||convert to pattern|16244
||err|1,240|26,pattern match right operand is not pattern|||16245
||mov|7,xl|7,xr||if ok, save pattern pointer|16246
||bnz|8,wb|6,mtch1||jump if not match by name|16247
||mov|8,wa|9,(xs)||else load name offset|16248
||mov|11,-(xs)|7,xl||save pattern pointer|16249
||mov|7,xl|13,num02(xs)||load name base|16250
||jsr|6,acess|||access subject value|16251
||ppm|6,exfal|||fail if access fails|16252
||mov|7,xl|9,(xs)||restore pattern pointer|16253
||mov|9,(xs)|7,xr||stack subject string val for merge|16254
||zer|8,wb|||restore type code|16255
|mtch1|jsr|6,gtstg|||convert subject to string|16260
||err|1,241|26,pattern match left operand is not a string|||16261
||mov|11,-(xs)|8,wb||stack match type code|16262
||mov|3,r_pms|7,xr||if ok, store subject string pointer|16270
||mov|3,pmssl|8,wa||and length|16271
||zer|11,-(xs)|||stack initial cursor (zero)|16272
||zer|8,wb|||set initial cursor|16273
||mov|3,pmhbs|7,xs||set history stack base ptr|16274
||zer|3,pmdfl|||reset pattern assignment flag|16275
||mov|7,xr|7,xl||set initial node pointer|16276
||bnz|3,kvanc|6,mtch2||jump if anchored|16277
||mov|11,-(xs)|7,xr||stack initial node pointer|16281
||mov|11,-(xs)|21,=nduna||stack pointer to anchor move node|16282
||bri|9,(xr)|||start match of first node|16283
|mtch2|zer|11,-(xs)|||dummy cursor value|16287
||mov|11,-(xs)|21,=ndabo||stack pointer to abort node|16288
||bri|9,(xr)|||start match of first node|16289
||ejc|||||16290
|retrn|rtn|||||16303
||bnz|3,kvfnc|6,rtn01||jump if not level zero|16304
||erb|1,242|26,function return from level zero|||16305
|rtn01|mov|7,xs|3,flprt||pop stack|16309
||ica|7,xs|||remove failure offset|16310
||mov|7,xr|10,(xs)+||pop pfblk pointer|16311
||mov|3,flptr|10,(xs)+||pop failure pointer|16312
||mov|3,flprt|10,(xs)+||pop old flprt|16313
||mov|8,wb|10,(xs)+||pop code pointer offset|16314
||mov|8,wc|10,(xs)+||pop old code block pointer|16315
||add|8,wb|8,wc||make old code pointer absolute|16316
||lcp|8,wb|||restore old code pointer|16317
||mov|3,r_cod|8,wc||restore old code block pointer|16318
||dcv|3,kvfnc|||decrement function level|16319
||mov|8,wb|3,kvtra||load trace|16320
||add|8,wb|3,kvftr||add ftrace|16321
||bze|8,wb|6,rtn06||jump if no tracing possible|16322
||mov|11,-(xs)|8,wa||save function return type|16326
||mov|11,-(xs)|7,xr||save pfblk pointer|16327
||mov|3,kvrtn|8,wa||set rtntype for trace function|16328
||mov|7,xl|3,r_fnc||load fnclevel trblk ptr (if any)|16329
||jsr|6,ktrex|||execute possible fnclevel trace|16330
||mov|7,xl|13,pfvbl(xr)||load vrblk ptr (sgd13)|16331
||bze|3,kvtra|6,rtn02||jump if trace is off|16332
||mov|7,xr|13,pfrtr(xr)||else load return trace trblk ptr|16333
||bze|7,xr|6,rtn02||jump if not return traced|16334
||dcv|3,kvtra|||else decrement trace count|16335
||bze|13,trfnc(xr)|6,rtn03||jump if print trace|16336
||mov|8,wa|19,*vrval||else set name offset|16337
||mov|3,kvrtn|13,num01(xs)||make sure rtntype is set right|16338
||jsr|6,trxeq|||execute full trace|16339
||ejc|||||16340
|rtn02|bze|3,kvftr|6,rtn05||jump if ftrace is off|16346
||dcv|3,kvftr|||else decrement ftrace|16347
|rtn03|jsr|6,prtsn|||print statement number|16351
||mov|7,xr|13,num01(xs)||load return type|16352
||jsr|6,prtst|||print it|16353
||mov|8,wa|18,=ch_bl||load blank|16354
||jsr|6,prtch|||print it|16355
||mov|7,xl|12,0(xs)||load pfblk ptr|16356
||mov|7,xl|13,pfvbl(xl)||load function vrblk ptr|16357
||mov|8,wa|19,*vrval||set vrblk name offset|16358
||bne|7,xr|21,=scfrt|6,rtn04|jump if not freturn case|16359
||jsr|6,prtnm|||print name|16363
||jsr|6,prtnl|||terminate print line|16364
||brn|6,rtn05|||merge|16365
|rtn04|jsr|6,prtnv|||print name = value|16369
|rtn05|mov|7,xr|10,(xs)+||pop pfblk pointer|16373
||mov|8,wa|10,(xs)+||pop return type string|16374
|rtn06|mov|3,kvrtn|8,wa||set rtntype keyword|16378
||mov|7,xl|13,pfvbl(xr)||load pointer to fn vrblk|16379
||ejc|||||16380
|rtn07|mov|3,rtnbp|7,xl||save block pointer|16385
||mov|7,xl|13,vrval(xl)||load value|16386
||beq|9,(xl)|22,=b_trt|6,rtn07|loop back if trapped|16387
||mov|3,rtnfv|7,xl||else save function result value|16388
||mov|3,rtnsv|10,(xs)+||save original function value|16389
||mov|7,xl|10,(xs)+||pop saved pointer|16393
||bze|7,xl|6,rtn7c||no action if none|16394
||bze|3,kvpfl|6,rtn7c||jump if no profiling|16395
||jsr|6,prflu|||else profile last func stmt|16396
||beq|3,kvpfl|18,=num02|6,rtn7a|branch on value of profile keywd|16397
||ldi|3,pfstm|||load current time|16403
||sbi|13,icval(xl)|||frig by subtracting saved amount|16404
||brn|6,rtn7b|||and merge|16405
|rtn7a|ldi|13,icval(xl)|||load saved time|16409
|rtn7b|sti|3,pfstm|||store back correct start time|16413
|rtn7c|mov|8,wb|13,fargs(xr)||get number of args|16417
||add|8,wb|13,pfnlo(xr)||add number of locals|16419
||bze|8,wb|6,rtn10||jump if no args/locals|16420
||lct|8,wb|8,wb||else set loop counter|16421
||add|7,xr|13,pflen(xr)||and point to end of pfblk|16422
|rtn08|mov|7,xl|11,-(xr)||load next vrblk pointer|16426
|rtn09|mov|8,wa|7,xl||save block pointer|16430
||mov|7,xl|13,vrval(xl)||load pointer to next value|16431
||beq|9,(xl)|22,=b_trt|6,rtn09|loop back if trapped|16432
||mov|7,xl|8,wa||else restore last block pointer|16433
||mov|13,vrval(xl)|10,(xs)+||restore old variable value|16434
||bct|8,wb|6,rtn08||loop till all processed|16435
|rtn10|mov|7,xl|3,rtnbp||restore ptr to last function block|16439
||mov|13,vrval(xl)|3,rtnsv||restore old function value|16440
||mov|7,xr|3,rtnfv||reload function result|16441
||mov|7,xl|3,r_cod||point to new code block|16442
||mov|3,kvlst|3,kvstn||set lastno from stno|16443
||mov|3,kvstn|13,cdstm(xl)||reset proper stno value|16444
||mov|3,kvlln|3,kvlin||set lastline from line|16446
||mov|3,kvlin|13,cdsln(xl)||reset proper line value|16447
||mov|8,wa|3,kvrtn||load return type|16449
||beq|8,wa|21,=scrtn|6,exixr|exit with result in xr if return|16450
||beq|8,wa|21,=scfrt|6,exfal|fail if freturn|16451
||ejc|||||16452
||beq|9,(xr)|22,=b_nml|6,rtn11|jump if is a name|16458
||jsr|6,gtnvr|||else try convert to variable name|16459
||err|1,243|26,function result in nreturn is not name|||16460
||mov|7,xl|7,xr||if ok, copy vrblk (name base) ptr|16461
||mov|8,wa|19,*vrval||set name offset|16462
||brn|6,rtn12|||and merge|16463
|rtn11|mov|7,xl|13,nmbas(xr)||load name base|16467
||mov|8,wa|13,nmofs(xr)||load name offset|16468
|rtn12|mov|7,xr|7,xl||preserve xl|16472
||lcw|8,wb|||load next word|16473
||mov|7,xl|7,xr||restore xl|16474
||beq|8,wb|21,=ofne_|6,exnam|exit if called by name|16475
||mov|11,-(xs)|8,wb||else save code word|16476
||jsr|6,acess|||get value|16477
||ppm|6,exfal|||fail if access fails|16478
||mov|7,xl|7,xr||if ok, copy result|16479
||mov|7,xr|9,(xs)||reload next code word|16480
||mov|9,(xs)|7,xl||store result on stack|16481
||mov|7,xl|9,(xr)||load routine address|16482
||bri|7,xl|||jump to execute next code word|16483
||ejc|||||16484
|stcov|rtn|||||16494
||icv|3,errft|||fatal error|16495
||ldi|4,intvt|||get 10|16496
||adi|3,kvstl|||add to former limit|16497
||sti|3,kvstl|||store as new stlimit|16498
||ldi|4,intvt|||get 10|16499
||sti|3,kvstc|||set as new count|16500
||jsr|6,stgcc|||recompute countdown counters|16501
||erb|1,244|26,statement count exceeds value of stlimit keyword|||16502
||ejc|||||16503
|stmgo|rtn|||||16512
||mov|3,r_cod|7,xr||set new code block pointer|16513
||dcv|3,stmct|||see if time to check something|16514
||bze|3,stmct|6,stgo2||jump if so|16515
||mov|3,kvlst|3,kvstn||set lastno|16516
||mov|3,kvstn|13,cdstm(xr)||set stno|16517
||mov|3,kvlln|3,kvlin||set lastline|16519
||mov|3,kvlin|13,cdsln(xr)||set line|16520
||add|7,xr|19,*cdcod||point to first code word|16522
||lcp|7,xr|||set code pointer|16523
|stgo1|lcw|7,xr|||load next code word|16527
||zer|7,xl|||clear garbage xl|16528
||bri|9,(xr)|||execute it|16529
|stgo2|bze|3,kvpfl|6,stgo3||skip if no profiling|16533
||jsr|6,prflu|||else profile the statement in kvstn|16534
|stgo3|mov|3,kvlst|3,kvstn||set lastno|16538
||mov|3,kvstn|13,cdstm(xr)||set stno|16539
||mov|3,kvlln|3,kvlin||set lastline|16541
||mov|3,kvlin|13,cdsln(xr)||set line|16542
||add|7,xr|19,*cdcod||point to first code word|16544
||lcp|7,xr|||set code pointer|16545
||mov|11,-(xs)|3,stmcs||save present count start on stack|16550
||dcv|3,polct|||poll interval within stmct|16551
||bnz|3,polct|6,stgo4||jump if not poll time yet|16552
||zer|8,wa|||=0 for poll|16553
||mov|8,wb|3,kvstn||statement number|16554
||mov|7,xl|7,xr||make collectable|16555
||jsr|6,syspl|||allow interactive access|16556
||err|1,320|26,user interrupt|||16557
||ppm||||single step|16558
||ppm||||expression evaluation|16559
||mov|7,xr|7,xl||restore code block pointer|16560
||mov|3,polcs|8,wa||poll interval start value|16561
||jsr|6,stgcc|||recompute counter values|16562
|stgo4|ldi|3,kvstc|||get stmt count|16567
||ilt|6,stgo5|||omit counting if negative|16568
||mti|10,(xs)+|||reload start value of counter|16569
||ngi||||negate|16570
||adi|3,kvstc|||stmt count minus counter|16571
||sti|3,kvstc|||replace it|16572
||ile|6,stcov|||fail if stlimit reached|16573
||bze|3,r_stc|6,stgo5||jump if no statement trace|16574
||zer|7,xr|||clear garbage value in xr|16575
||mov|7,xl|3,r_stc||load pointer to stcount trblk|16576
||jsr|6,ktrex|||execute keyword trace|16577
|stgo5|mov|3,stmct|3,stmcs||reset counter|16581
||brn|6,stgo1|||fetch next code word|16582
||ejc|||||16583
|stopr|rtn|||||16593
||bze|7,xr|6,stpra||skip if sysax already called|16595
||jsr|6,sysax|||call after execution proc|16596
|stpra|add|3,dname|3,rsmem||use the reserve memory|16597
||bne|7,xr|21,=endms|6,stpr0|skip if not normal end message|16601
||bnz|3,exsts|6,stpr3||skip if exec stats suppressed|16602
||zer|3,erich|||clear errors to int.ch. flag|16603
|stpr0|jsr|6,prtpg|||eject printer|16607
||bze|7,xr|6,stpr1||skip if no message|16608
||jsr|6,prtst|||print message|16609
|stpr1|jsr|6,prtis|||print blank line|16613
||bnz|3,gbcfl|6,stpr5||if in garbage collection, skip|16615
||mov|7,xr|21,=stpm6||point to message /in file xxx/|16616
||jsr|6,prtst|||print it|16617
||mov|3,profs|18,=prtmf||set column offset|16618
||mov|8,wc|3,kvstn||get statement number|16619
||jsr|6,filnm|||get file name|16620
||mov|7,xr|7,xl||prepare to print|16621
||jsr|6,prtst|||print file name|16622
||jsr|6,prtis|||print to interactive channel|16623
||mov|7,xr|3,r_cod||get code pointer|16630
||mti|13,cdsln(xr)|||get source line number|16631
||mov|7,xr|21,=stpm4||point to message /in line xxx/|16632
||jsr|6,prtmx|||print it|16633
|stpr5|mti|3,kvstn|||get statement number|16635
||mov|7,xr|21,=stpm1||point to message /in statement xxx/|16636
||jsr|6,prtmx|||print it|16637
||ldi|3,kvstl|||get statement limit|16638
||ilt|6,stpr2|||skip if negative|16639
||sbi|3,kvstc|||minus counter = course count|16640
||sti|3,stpsi|||save|16641
||mov|8,wa|3,stmcs||refine with counter start value|16642
||sub|8,wa|3,stmct||minus current counter|16643
||mti|8,wa|||convert to integer|16644
||adi|3,stpsi|||add in course count|16645
||sti|3,stpsi|||save|16646
||mov|7,xr|21,=stpm2||point to message /stmts executed/|16647
||jsr|6,prtmx|||print it|16648
||jsr|6,systm|||get current time|16649
||sbi|3,timsx|||minus start time = elapsed exec tim in nanosec|16650
||sti|3,stpti|||save for later|16651
||dvi|4,intth|||divide by 1000 to convert to microseconds|16652
||iov|6,stpr2|||jump if we cannot compute|16653
||dvi|4,intth|||divide by 1000 to convert to milliseconds|16654
||iov|6,stpr2|||jump if we cannot compute|16655
||sti|3,stpti|||save elapsed time in milliseconds|16656
||mov|7,xr|21,=stpm3||point to msg /execution time msec /|16657
||jsr|6,prtmx|||print it|16658
||ldi|3,stpti|||reload execution time in milliseconds|16663
||ile|6,stpr2|||jump if exection time less than a millisecond|16664
||ldi|3,stpsi|||load statement count|16668
||dvi|3,stpti|||divide to get stmts per millisecond|16669
||iov|6,stpr2|||jump if we cannot compute|16670
||dvi|4,intth|||divide to get stmts per microsecond|16671
||iov|6,stpr2|||jump if we cannot compute|16672
||mov|7,xr|21,=stpm7||point to msg (stmt / microsec)|16673
||jsr|6,prtmx|||print it|16674
||ldi|3,stpsi|||reload statement count|16676
||dvi|3,stpti|||divide to get stmts per millisecond|16677
||iov|6,stpr2|||jump if we cannot compute|16678
||mov|7,xr|21,=stpm8||point to msg (stmt / millisec )|16679
||jsr|6,prtmx|||print it|16680
||ldi|3,stpsi|||reload statement count|16682
||dvi|3,stpti|||divide to get stmts per millisecond|16683
||iov|6,stpr2|||jump if we cannot compute|16684
||mli|4,intth|||multiply by 1000 to get stmts per microsecond|16685
||iov|6,stpr2|||jump if overflow|16686
||mov|7,xr|21,=stpm9||point to msg ( stmt / second )|16687
||jsr|6,prtmx|||print it|16688
||ejc|||||16690
|stpr2|mti|3,gbcnt|||load count of collections|16696
||mov|7,xr|21,=stpm4||point to message /regenerations /|16697
||jsr|6,prtmx|||print it|16698
||jsr|6,prtmm|||print memory usage|16699
||jsr|6,prtis|||one more blank for luck|16700
|stpr3|jsr|6,prflr|||print profile if wanted|16707
||mov|7,xr|3,kvdmp||load dump keyword|16709
||jsr|6,dumpr|||execute dump if requested|16711
||mov|7,xl|3,r_fcb||get fcblk chain head|16712
||mov|8,wa|3,kvabe||load abend value|16713
||mov|8,wb|3,kvcod||load code value|16714
||jsr|6,sysej|||exit to system|16715
|stpr4|rtn|||||16720
||add|3,dname|3,rsmem||use the reserve memory|16721
||bze|3,exsts|6,stpr1||if execution stats requested|16722
||brn|6,stpr3|||check if dump or profile needed|16723
||ejc|||||16726
|succp|rtn|||||16739
||mov|7,xr|13,pthen(xr)||load successor node|16740
||mov|7,xl|9,(xr)||load node code entry address|16741
||bri|7,xl|||jump to match successor node|16742
||ejc|||||16743
|sysab|rtn|||||16747
||mov|7,xr|21,=endab||point to message|16748
||mov|3,kvabe|18,=num01||set abend flag|16749
||jsr|6,prtnl|||skip to new line|16750
||brn|6,stopr|||jump to pack up|16751
||ejc|||||16752
|systu|rtn|||||16756
||mov|7,xr|21,=endtu||point to message|16757
||mov|8,wa|4,strtu||get chars /tu/|16758
||mov|3,kvcod|8,wa||put in kvcod|16759
||mov|8,wa|3,timup||check state of timeup switch|16760
||mnz|3,timup|||set switch|16761
||bnz|8,wa|6,stopr||stop run if already set|16762
||erb|1,245|26,translation/execution time expired|||16763
||ttl|27,s p i t b o l -- utility procedures||||16764
||ejc|||||16808
|acess|prc|25,r|1,1||entry point (recursive)|16828
||mov|7,xr|7,xl||copy name base|16829
||add|7,xr|8,wa||point to variable location|16830
||mov|7,xr|9,(xr)||load variable value|16831
|acs02|bne|9,(xr)|22,=b_trt|6,acs18|jump if not trapped|16835
||beq|7,xr|21,=trbkv|6,acs12|jump if keyword variable|16839
||bne|7,xr|21,=trbev|6,acs05|jump if not expression variable|16840
||mov|7,xr|13,evexp(xl)||load expression pointer|16844
||zer|8,wb|||evaluate by value|16845
||jsr|6,evalx|||evaluate expression|16846
||ppm|6,acs04|||jump if evaluation failure|16847
||brn|6,acs02|||check value for more trblks|16848
||ejc|||||16849
|acs03|add|7,xs|19,*num03||pop trblk ptr, name base and offset|16855
||mov|3,dnamp|7,xr||pop unused scblk|16856
|acs04|exi|1,1|||take alternate (failure) return|16860
|acs05|mov|8,wb|13,trtyp(xr)||load trap type code|16864
||bnz|8,wb|6,acs10||jump if not input association|16865
||bze|3,kvinp|6,acs09||ignore input assoc if input is off|16866
||mov|11,-(xs)|7,xl||stack name base|16870
||mov|11,-(xs)|8,wa||stack name offset|16871
||mov|11,-(xs)|7,xr||stack trblk pointer|16872
||mov|3,actrm|3,kvtrm||temp to hold trim keyword|16873
||mov|7,xl|13,trfpt(xr)||get file ctrl blk ptr or zero|16874
||bnz|7,xl|6,acs06||jump if not standard input file|16875
||beq|13,trter(xr)|21,=v_ter|6,acs21|jump if terminal|16876
||mov|8,wa|3,cswin||length for read buffer|16880
||jsr|6,alocs|||build string of appropriate length|16881
||jsr|6,sysrd|||read next standard input image|16882
||ppm|6,acs03|||jump to fail exit if end of file|16883
||brn|6,acs07|||else merge with other file case|16884
|acs06|mov|8,wa|7,xl||fcblk ptr|16888
||jsr|6,sysil|||get input record max length (to wa)|16889
||bnz|8,wc|6,acs6a||jump if not binary file|16890
||mov|3,actrm|8,wc||disable trim for binary file|16891
|acs6a|jsr|6,alocs|||allocate string of correct size|16892
||mov|8,wa|7,xl||fcblk ptr|16893
||jsr|6,sysin|||call system input routine|16894
||ppm|6,acs03|||jump to fail exit if end of file|16895
||ppm|6,acs22|||error|16896
||ppm|6,acs23|||error|16897
||ejc|||||16898
|acs07|mov|8,wb|3,actrm||load trim indicator|16904
||jsr|6,trimr|||trim record as required|16905
||mov|8,wb|7,xr||copy result pointer|16906
||mov|7,xr|9,(xs)||reload pointer to trblk|16907
|acs08|mov|7,xl|7,xr||save pointer to this trblk|16911
||mov|7,xr|13,trnxt(xr)||load forward pointer|16912
||beq|9,(xr)|22,=b_trt|6,acs08|loop if this is another trblk|16913
||mov|13,trnxt(xl)|8,wb||else store result at end of chain|16914
||mov|7,xr|10,(xs)+||restore initial trblk pointer|16915
||mov|8,wa|10,(xs)+||restore name offset|16916
||mov|7,xl|10,(xs)+||restore name base pointer|16917
|acs09|mov|7,xr|13,trnxt(xr)||load forward ptr to next value|16921
||brn|6,acs02|||back to check if trapped|16922
|acs10|bne|8,wb|18,=trtac|6,acs09|loop back if not access trace|16926
||bze|3,kvtra|6,acs09||ignore access trace if trace off|16927
||dcv|3,kvtra|||else decrement trace count|16928
||bze|13,trfnc(xr)|6,acs11||jump if print trace|16929
||ejc|||||16930
||jsr|6,trxeq|||call routine to execute trace|16936
||brn|6,acs09|||jump for next trblk|16937
|acs11|jsr|6,prtsn|||print statement number|16941
||jsr|6,prtnv|||print name = value|16942
||brn|6,acs09|||jump back for next trblk|16943
|acs12|mov|7,xr|13,kvnum(xl)||load keyword number|16947
||bge|7,xr|18,=k_v__|6,acs14|jump if not one word value|16948
||mti|15,kvabe(xr)|||else load value as integer|16949
|acs13|jsr|6,icbld|||build icblk|16953
||brn|6,acs18|||jump to exit|16954
|acs14|bge|7,xr|18,=k_s__|6,acs15|jump if special case|16958
||sub|7,xr|18,=k_v__||else get offset|16959
||wtb|7,xr|||convert to byte offset|16960
||add|7,xr|21,=ndabo||point to pattern value|16961
||brn|6,acs18|||jump to exit|16962
|acs15|mov|7,xl|3,kvrtn||load rtntype in case|16966
||ldi|3,kvstl|||load stlimit in case|16967
||sub|7,xr|18,=k_s__||get case number|16968
||bsw|7,xr|2,k__n_||switch on keyword number|16969
||iff|2,k__al|6,acs16||jump if alphabet|16983
||iff|2,k__rt|6,acs17||rtntype|16983
||iff|2,k__sc|6,acs19||stcount|16983
||iff|2,k__et|6,acs20||errtext|16983
||iff|2,k__fl|6,acs26||file|16983
||iff|2,k__lf|6,acs27||lastfile|16983
||iff|2,k__sl|6,acs13||stlimit|16983
||iff|2,k__lc|6,acs24||lcase|16983
||iff|2,k__uc|6,acs25||ucase|16983
||esw||||end switch on keyword number|16983
||ejc|||||16984
|acs24|mov|7,xr|21,=lcase||load pointer to lcase string|16991
||brn|6,acs18|||common return|16992
|acs25|mov|7,xr|21,=ucase||load pointer to ucase string|16996
||brn|6,acs18|||common return|16997
|acs26|mov|8,wc|3,kvstn||load current stmt number|17003
||brn|6,acs28|||merge to obtain file name|17004
|acs27|mov|8,wc|3,kvlst||load last stmt number|17008
|acs28|jsr|6,filnm|||obtain file name for this stmt|17012
||brn|6,acs17|||merge to return string in xl|17013
|acs16|mov|7,xl|3,kvalp||load pointer to alphabet string|17017
|acs17|mov|7,xr|7,xl||copy string ptr to proper reg|17021
|acs18|exi||||return to acess caller|17025
|acs19|ilt|6,acs29|||if counting suppressed|17029
||mov|8,wa|3,stmcs||refine with counter start value|17030
||sub|8,wa|3,stmct||minus current counter|17031
||mti|8,wa|||convert to integer|17032
||adi|3,kvstl|||add stlimit|17033
|acs29|sbi|3,kvstc|||stcount = limit - left|17034
||brn|6,acs13|||merge back with integer result|17035
|acs20|mov|7,xr|3,r_etx||get errtext string|17039
||brn|6,acs18|||merge with result|17040
|acs21|mov|8,wa|18,=rilen||buffer length|17044
||jsr|6,alocs|||allocate buffer|17045
||jsr|6,sysri|||read record|17046
||ppm|6,acs03|||endfile|17047
||brn|6,acs07|||merge with record read|17048
|acs22|mov|3,dnamp|7,xr||pop unused scblk|17052
||erb|1,202|26,input from file caused non-recoverable error|||17053
|acs23|mov|3,dnamp|7,xr||pop unused scblk|17055
||erb|1,203|26,input file record has incorrect format|||17056
||enp||||end procedure acess|17057
||ejc|||||17058
|acomp|prc|25,n|1,5||entry point|17074
||jsr|6,arith|||load arithmetic operands|17075
||ppm|6,acmp7|||jump if first arg non-numeric|17076
||ppm|6,acmp8|||jump if second arg non-numeric|17077
||ppm|6,acmp4|||jump if real arguments|17080
||sbi|13,icval(xl)|||subtract to compare|17085
||iov|6,acmp3|||jump if overflow|17086
||ilt|6,acmp5|||else jump if arg1 lt arg2|17087
||ieq|6,acmp2|||jump if arg1 eq arg2|17088
|acmp1|exi|1,5|||take gt exit|17092
|acmp2|exi|1,4|||take eq exit|17096
||ejc|||||17097
|acmp3|ldi|13,icval(xl)|||load second argument|17103
||ilt|6,acmp1|||gt if negative|17104
||brn|6,acmp5|||else lt|17105
|acmp4|sbr|13,rcval(xl)|||subtract to compare|17111
||rov|6,acmp6|||jump if overflow|17112
||rgt|6,acmp1|||else jump if arg1 gt|17113
||req|6,acmp2|||jump if arg1 eq arg2|17114
|acmp5|exi|1,3|||take lt exit|17119
|acmp6|ldr|13,rcval(xl)|||reload arg2|17125
||rlt|6,acmp1|||gt if negative|17126
||brn|6,acmp5|||else lt|17127
|acmp7|exi|1,1|||take error exit|17132
|acmp8|exi|1,2|||take error exit|17136
||enp||||end procedure acomp|17137
||ejc|||||17138
|alloc|prc|25,e|1,0||entry point|17150
|aloc1|mov|7,xr|3,dnamp||point to next available loc|17154
||aov|8,wa|7,xr|6,aloc2|point past allocated block|17155
||bgt|7,xr|3,dname|6,aloc2|jump if not enough room|17156
||mov|3,dnamp|7,xr||store new pointer|17157
||sub|7,xr|8,wa||point back to start of allocated bk|17158
||exi||||return to caller|17159
|aloc2|mov|3,allsv|8,wb||save wb|17163
|alc2a|zer|8,wb|||set no upward move for gbcol|17164
||jsr|6,gbcol|||garbage collect|17165
||mov|8,wb|7,xr||remember new sediment size|17167
|aloc3|mov|7,xr|3,dnamp||point to first available loc|17172
||aov|8,wa|7,xr|6,alc3a|point past new block|17173
||blo|7,xr|3,dname|6,aloc4|jump if there is room now|17174
|alc3a|jsr|6,sysmm|||try to get more memory|17178
||wtb|7,xr|||convert to baus (sgd05)|17179
||add|3,dname|7,xr||bump ptr by amount obtained|17180
||bnz|7,xr|6,aloc3||jump if got more core|17181
||bze|3,dnams|6,alc3b||jump if there was no sediment|17183
||zer|3,dnams|||try collecting the sediment|17184
||brn|6,alc2a||||17185
|alc3b|add|3,dname|3,rsmem||get the reserve memory|17189
||zer|3,rsmem|||only permissible once|17193
||icv|3,errft|||fatal error|17194
||erb|1,204|26,memory overflow|||17195
||ejc|||||17196
|aloc4|sti|3,allia|||save ia|17200
||mov|3,dnams|8,wb||record new sediment size|17202
||mov|8,wb|3,dname||get dynamic end adrs|17204
||sub|8,wb|3,dnamp||compute free store|17205
||btw|8,wb|||convert bytes to words|17206
||mti|8,wb|||put free store in ia|17207
||mli|3,alfsf|||multiply by free store factor|17208
||iov|6,aloc5|||jump if overflowed|17209
||mov|8,wb|3,dname||dynamic end adrs|17210
||sub|8,wb|3,dnamb||compute total amount of dynamic|17211
||btw|8,wb|||convert to words|17212
||mov|3,aldyn|8,wb||store it|17213
||sbi|3,aldyn|||subtract from scaled up free store|17214
||igt|6,aloc5|||jump if sufficient free store|17215
||jsr|6,sysmm|||try to get more store|17216
||wtb|7,xr|||convert to baus (sgd05)|17217
||add|3,dname|7,xr||adjust dynamic end adrs|17218
|aloc5|ldi|3,allia|||recover ia|17222
||mov|8,wb|3,allsv||restore wb|17223
||brn|6,aloc1|||jump back to exit|17224
||enp||||end procedure alloc|17225
||ejc|||||17226
|alocs|prc|25,e|1,0||entry point|17286
||bgt|8,wa|3,kvmxl|6,alcs2|jump if length exceeds maxlength|17287
||mov|8,wc|8,wa||else copy length|17288
||ctb|8,wa|2,scsi_||compute length of scblk in bytes|17289
||mov|7,xr|3,dnamp||point to next available location|17290
||aov|8,wa|7,xr|6,alcs0|point past block|17291
||blo|7,xr|3,dname|6,alcs1|jump if there is room|17292
|alcs0|zer|7,xr|||else clear garbage xr value|17296
||jsr|6,alloc|||and use standard allocator|17297
||add|7,xr|8,wa||point past end of block to merge|17298
|alcs1|mov|3,dnamp|7,xr||set updated storage pointer|17302
||zer|11,-(xr)|||store zero chars in last word|17303
||dca|8,wa|||decrement length|17304
||sub|7,xr|8,wa||point back to start of block|17305
||mov|9,(xr)|22,=b_scl||set type word|17306
||mov|13,sclen(xr)|8,wc||store length in chars|17307
||exi||||return to alocs caller|17308
|alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||17312
||enp||||end procedure alocs|17313
||ejc|||||17314
|alost|prc|25,e|1,0||entry point|17327
|alst1|mov|7,xr|3,state||point to current end of area|17331
||aov|8,wa|7,xr|6,alst2|point beyond proposed block|17332
||bge|7,xr|3,dnamb|6,alst2|jump if overlap with dynamic area|17333
||mov|3,state|7,xr||else store new pointer|17334
||sub|7,xr|8,wa||point back to start of block|17335
||exi||||return to alost caller|17336
|alst2|mov|3,alsta|8,wa||save wa|17340
||bge|8,wa|19,*e_sts|6,alst3|skip if requested chunk is large|17341
||mov|8,wa|19,*e_sts||else set to get large enough chunk|17342
|alst3|jsr|6,alloc|||allocate block to ensure room|17346
||mov|3,dnamp|7,xr||and delete it|17347
||mov|8,wb|8,wa||copy move up amount|17348
||jsr|6,gbcol|||call gbcol to move dynamic area up|17349
||mov|3,dnams|7,xr||remember new sediment size|17351
||mov|8,wa|3,alsta||restore wa|17353
||brn|6,alst1|||loop back to try again|17354
||enp||||end procedure alost|17355
||ejc|||||17356
||ejc|||||17430
|arith|prc|25,n|1,3||entry point|17439
||mov|7,xl|10,(xs)+||load right operand|17441
||mov|7,xr|10,(xs)+||load left operand|17442
||mov|8,wa|9,(xl)||get right operand type word|17443
||beq|8,wa|22,=b_icl|6,arth1|jump if integer|17444
||beq|8,wa|22,=b_rcl|6,arth4|jump if real|17447
||mov|11,-(xs)|7,xr||else replace left arg on stack|17449
||mov|7,xr|7,xl||copy left arg pointer|17450
||jsr|6,gtnum|||convert to numeric|17451
||ppm|6,arth6|||jump if unconvertible|17452
||mov|7,xl|7,xr||else copy converted result|17453
||mov|8,wa|9,(xl)||get right operand type word|17454
||mov|7,xr|10,(xs)+||reload left argument|17455
||beq|8,wa|22,=b_rcl|6,arth4|jump if right arg is real|17458
|arth1|bne|9,(xr)|22,=b_icl|6,arth3|jump if left arg not integer|17463
|arth2|ldi|13,icval(xr)|||load left operand value|17467
||exi||||return to arith caller|17468
|arth3|jsr|6,gtnum|||convert left arg to numeric|17472
||ppm|6,arth7|||jump if not convertible|17473
||beq|8,wa|22,=b_icl|6,arth2|jump back if integer-integer|17474
||mov|11,-(xs)|7,xr||put left arg back on stack|17480
||ldi|13,icval(xl)|||load right argument value|17481
||itr||||convert to real|17482
||jsr|6,rcbld|||get real block for right arg, merge|17483
||mov|7,xl|7,xr||copy right arg ptr|17484
||mov|7,xr|10,(xs)+||load left argument|17485
||brn|6,arth5|||merge for real-real case|17486
||ejc|||||17487
|arth4|beq|9,(xr)|22,=b_rcl|6,arth5|jump if left arg real|17493
||jsr|6,gtrea|||else convert to real|17494
||ppm|6,arth7|||error if unconvertible|17495
|arth5|ldr|13,rcval(xr)|||load left operand value|17499
||exi|1,3|||take real-real exit|17500
|arth6|ica|7,xs|||pop unwanted left arg|17505
||exi|1,2|||take appropriate error exit|17506
|arth7|exi|1,1|||take appropriate error return|17510
||enp||||end procedure arith|17511
||ejc|||||17512
|asign|prc|25,r|1,1||entry point (recursive)|17533
|asg01|add|7,xl|8,wa||point to variable value|17537
||mov|7,xr|9,(xl)||load variable value|17538
||beq|9,(xr)|22,=b_trt|6,asg02|jump if trapped|17539
||mov|9,(xl)|8,wb||else perform assignment|17540
||zer|7,xl|||clear garbage value in xl|17541
||exi||||and return to asign caller|17542
|asg02|sub|7,xl|8,wa||restore name base|17546
||beq|7,xr|21,=trbkv|6,asg14|jump if keyword variable|17547
||bne|7,xr|21,=trbev|6,asg04|jump if not expression variable|17548
||mov|7,xr|13,evexp(xl)||point to expression|17552
||mov|11,-(xs)|8,wb||store value to assign on stack|17553
||mov|8,wb|18,=num01||set for evaluation by name|17554
||jsr|6,evalx|||evaluate expression by name|17555
||ppm|6,asg03|||jump if evaluation fails|17556
||mov|8,wb|10,(xs)+||else reload value to assign|17557
||brn|6,asg01|||loop back to perform assignment|17558
||ejc|||||17559
|asg03|ica|7,xs|||remove stacked value entry|17565
||exi|1,1|||take failure exit|17566
|asg04|mov|11,-(xs)|7,xr||save ptr to first trblk|17570
|asg05|mov|8,wc|7,xr||save ptr to this trblk|17574
||mov|7,xr|13,trnxt(xr)||point to next trblk|17575
||beq|9,(xr)|22,=b_trt|6,asg05|loop back if another trblk|17576
||mov|7,xr|8,wc||else point back to last trblk|17577
||mov|13,trval(xr)|8,wb||store value at end of chain|17578
||mov|7,xr|10,(xs)+||restore ptr to first trblk|17579
|asg06|mov|8,wb|13,trtyp(xr)||load type code of trblk|17583
||beq|8,wb|18,=trtvl|6,asg08|jump if value trace|17584
||beq|8,wb|18,=trtou|6,asg10|jump if output association|17585
|asg07|mov|7,xr|13,trnxt(xr)||point to next trblk on chain|17589
||beq|9,(xr)|22,=b_trt|6,asg06|loop back if another trblk|17590
||exi||||else end of chain, return to caller|17591
|asg08|bze|3,kvtra|6,asg07||ignore value trace if trace off|17595
||dcv|3,kvtra|||else decrement trace count|17596
||bze|13,trfnc(xr)|6,asg09||jump if print trace|17597
||jsr|6,trxeq|||else execute function trace|17598
||brn|6,asg07|||and loop back|17599
||ejc|||||17600
|asg09|jsr|6,prtsn|||print statement number|17606
||jsr|6,prtnv|||print name = value|17607
||brn|6,asg07|||loop back for next trblk|17608
|asg10|bze|3,kvoup|6,asg07||ignore output assoc if output off|17612
|asg1b|mov|7,xl|7,xr||copy trblk pointer|17613
||mov|7,xr|13,trnxt(xr)||point to next trblk|17614
||beq|9,(xr)|22,=b_trt|6,asg1b|loop back if another trblk|17615
||mov|7,xr|7,xl||else point back to last trblk|17616
||mov|11,-(xs)|13,trval(xr)||stack value to output|17618
||jsr|6,gtstg|||convert to string|17624
||ppm|6,asg12|||get datatype name if unconvertible|17625
|asg11|mov|8,wa|13,trfpt(xl)||fcblk ptr|17629
||bze|8,wa|6,asg13||jump if standard output file|17630
|asg1a|jsr|6,sysou|||call system output routine|17634
||err|1,206|26,output caused file overflow|||17635
||err|1,207|26,output caused non-recoverable error|||17636
||exi||||else all done, return to caller|17637
|asg12|jsr|6,dtype|||call datatype routine|17641
||brn|6,asg11|||merge|17642
|asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|jump if terminal output|17647
||icv|8,wa|||signal standard output|17648
||brn|6,asg1a|||use sysou to perform output|17649
||ejc|||||17664
|asg14|mov|7,xl|13,kvnum(xl)||load keyword number|17670
||beq|7,xl|18,=k_etx|6,asg19|jump if errtext|17671
||mov|7,xr|8,wb||copy value to be assigned|17672
||jsr|6,gtint|||convert to integer|17673
||err|1,208|26,keyword value assigned is not integer|||17674
||ldi|13,icval(xr)|||else load value|17675
||beq|7,xl|18,=k_stl|6,asg16|jump if special case of stlimit|17676
||mfi|8,wa|6,asg18||else get addr integer, test ovflow|17677
||bgt|8,wa|3,mxlen|6,asg18|fail if too large|17678
||beq|7,xl|18,=k_ert|6,asg17|jump if special case of errtype|17679
||beq|7,xl|18,=k_pfl|6,asg21|jump if special case of profile|17682
||beq|7,xl|18,=k_mxl|6,asg24|jump if special case of maxlngth|17684
||beq|7,xl|18,=k_fls|6,asg26|jump if special case of fullscan|17685
||blt|7,xl|18,=k_p__|6,asg15|jump unless protected|17686
||erb|1,209|26,keyword in assignment is protected|||17687
|asg15|mov|15,kvabe(xl)|8,wa||store new value|17691
||exi||||return to asign caller|17692
|asg16|sbi|3,kvstl|||subtract old limit|17699
||adi|3,kvstc|||add old counter|17700
||sti|3,kvstc|||store course counter value|17701
||ldi|3,kvstl|||check if counting suppressed|17702
||ilt|6,asg25|||do not refine if so|17703
||mov|8,wa|3,stmcs||refine with counter breakout|17704
||sub|8,wa|3,stmct||values|17705
||mti|8,wa|||convert to integer|17706
||ngi||||current-start value|17707
||adi|3,kvstc|||add in course counter value|17708
||sti|3,kvstc|||save refined value|17709
|asg25|ldi|13,icval(xr)|||reload new limit value|17710
||sti|3,kvstl|||store new limit value|17711
||jsr|6,stgcc|||recompute countdown counters|17712
||exi||||return to asign caller|17713
|asg17|ble|8,wa|18,=nini9|6,error|ok to signal if in range|17717
|asg18|erb|1,210|26,keyword value assigned is negative or too large|||17721
|asg19|mov|11,-(xs)|8,wb||stack value|17725
||jsr|6,gtstg|||convert to string|17726
||err|1,211|26,value assigned to keyword errtext not a string|||17727
||mov|3,r_etx|7,xr||make assignment|17728
||exi||||return to caller|17729
|asg21|bgt|8,wa|18,=num02|6,asg18|moan if not 0,1, or 2|17743
||bze|8,wa|6,asg15||just assign if zero|17744
||bze|3,pfdmp|6,asg22||branch if first assignment|17745
||beq|8,wa|3,pfdmp|6,asg23|also if same value as before|17746
||erb|1,268|26,inconsistent value assigned to keyword profile|||17747
|asg22|mov|3,pfdmp|8,wa||note value on first assignment|17749
|asg23|mov|3,kvpfl|8,wa||store new value|17750
||jsr|6,stgcc|||recompute countdown counts|17751
||jsr|6,systm|||get the time|17752
||sti|3,pfstm|||fudge some kind of start time|17753
||exi||||return to asign caller|17754
|asg24|bge|8,wa|18,=mnlen|6,asg15|if acceptable value|17759
||erb|1,287|26,value assigned to keyword maxlngth is too small|||17760
|asg26|bnz|8,wa|6,asg15||if acceptable value|17764
||erb|1,274|26,value assigned to keyword fullscan is zero|||17765
||enp||||end procedure asign|17767
||ejc|||||17768
|asinp|prc|25,r|1,1||entry point, recursive|17784
||add|7,xl|8,wa||point to variable|17785
||mov|7,xr|9,(xl)||load current contents|17786
||beq|9,(xr)|22,=b_trt|6,asnp1|jump if trapped|17787
||mov|9,(xl)|8,wb||else perform assignment|17788
||zer|7,xl|||clear garbage value in xl|17789
||exi||||return to asinp caller|17790
|asnp1|sub|7,xl|8,wa||restore base pointer|17794
||mov|11,-(xs)|3,pmssl||stack subject string length|17795
||mov|11,-(xs)|3,pmhbs||stack history stack base ptr|17796
||mov|11,-(xs)|3,r_pms||stack subject string pointer|17797
||mov|11,-(xs)|3,pmdfl||stack dot flag|17798
||jsr|6,asign|||call full-blown assignment routine|17799
||ppm|6,asnp2|||jump if failure|17800
||mov|3,pmdfl|10,(xs)+||restore dot flag|17801
||mov|3,r_pms|10,(xs)+||restore subject string pointer|17802
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17803
||mov|3,pmssl|10,(xs)+||restore subject string length|17804
||exi||||return to asinp caller|17805
|asnp2|mov|3,pmdfl|10,(xs)+||restore dot flag|17809
||mov|3,r_pms|10,(xs)+||restore subject string pointer|17810
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|17811
||mov|3,pmssl|10,(xs)+||restore subject string length|17812
||exi|1,1|||take failure exit|17813
||enp||||end procedure asinp|17814
||ejc|||||17815
|blkln|prc|25,e|1,0||entry point|17833
||mov|7,xl|8,wa||copy first word|17834
||lei|7,xl|||get entry id (bl_xx)|17835
||bsw|7,xl|2,bl___|6,bln00|switch on block type|17836
||iff|2,bl_ar|6,bln01||arblk|17876
||iff|2,bl_cd|6,bln12||cdblk|17876
||iff|2,bl_ex|6,bln12||exblk|17876
||iff|2,bl_ic|6,bln07||icblk|17876
||iff|2,bl_nm|6,bln03||nmblk|17876
||iff|2,bl_p0|6,bln02||p0blk|17876
||iff|2,bl_p1|6,bln03||p1blk|17876
||iff|2,bl_p2|6,bln04||p2blk|17876
||iff|2,bl_rc|6,bln09||rcblk|17876
||iff|2,bl_sc|6,bln10||scblk|17876
||iff|2,bl_se|6,bln02||seblk|17876
||iff|2,bl_tb|6,bln01||tbblk|17876
||iff|2,bl_vc|6,bln01||vcblk|17876
||iff|1,13|6,bln00|||17876
||iff|1,14|6,bln00|||17876
||iff|1,15|6,bln00|||17876
||iff|2,bl_pd|6,bln08||pdblk|17876
||iff|2,bl_tr|6,bln05||trblk|17876
||iff|1,18|6,bln00|||17876
||iff|1,19|6,bln00|||17876
||iff|1,20|6,bln00|||17876
||iff|2,bl_ct|6,bln06||ctblk|17876
||iff|2,bl_df|6,bln01||dfblk|17876
||iff|2,bl_ef|6,bln01||efblk|17876
||iff|2,bl_ev|6,bln03||evblk|17876
||iff|2,bl_ff|6,bln05||ffblk|17876
||iff|2,bl_kv|6,bln03||kvblk|17876
||iff|2,bl_pf|6,bln01||pfblk|17876
||iff|2,bl_te|6,bln04||teblk|17876
||esw||||end of jump table on block type|17876
||ejc|||||17877
|bln00|mov|8,wa|13,num01(xr)||load length|17883
||exi||||return to blkln caller|17884
|bln01|mov|8,wa|13,num02(xr)||load length from third word|17888
||exi||||return to blkln caller|17889
|bln02|mov|8,wa|19,*num02||load length (two words)|17893
||exi||||return to blkln caller|17894
|bln03|mov|8,wa|19,*num03||load length (three words)|17898
||exi||||return to blkln caller|17899
|bln04|mov|8,wa|19,*num04||load length (four words)|17903
||exi||||return to blkln caller|17904
|bln05|mov|8,wa|19,*num05||load length|17908
||exi||||return to blkln caller|17909
||ejc|||||17910
|bln06|mov|8,wa|19,*ctsi_||set size of ctblk|17916
||exi||||return to blkln caller|17917
|bln07|mov|8,wa|19,*icsi_||set size of icblk|17921
||exi||||return to blkln caller|17922
|bln08|mov|7,xl|13,pddfp(xr)||point to dfblk|17926
||mov|8,wa|13,dfpdl(xl)||load pdblk length from dfblk|17927
||exi||||return to blkln caller|17928
|bln09|mov|8,wa|19,*rcsi_||set size of rcblk|17934
||exi||||return to blkln caller|17935
|bln10|mov|8,wa|13,sclen(xr)||load length in characters|17940
||ctb|8,wa|2,scsi_||calculate length in bytes|17941
||exi||||return to blkln caller|17942
|bln12|mov|8,wa|13,num03(xr)||load length from cdlen/exlen|17956
||exi||||return to blkln caller|17957
||enp||||end procedure blkln|17959
||ejc|||||17960
|copyb|prc|25,n|1,1||entry point|17972
||mov|7,xr|9,(xs)||load argument|17973
||beq|7,xr|21,=nulls|6,cop10|return argument if it is null|17974
||mov|8,wa|9,(xr)||else load type word|17975
||mov|8,wb|8,wa||copy type word|17976
||jsr|6,blkln|||get length of argument block|17977
||mov|7,xl|7,xr||copy pointer|17978
||jsr|6,alloc|||allocate block of same size|17979
||mov|9,(xs)|7,xr||store pointer to copy|17980
||mvw||||copy contents of old block to new|17981
||zer|7,xl|||clear garbage xl|17982
||mov|7,xr|9,(xs)||reload pointer to start of copy|17983
||beq|8,wb|22,=b_tbt|6,cop05|jump if table|17984
||beq|8,wb|22,=b_vct|6,cop01|jump if vector|17985
||beq|8,wb|22,=b_pdt|6,cop01|jump if program defined|17986
||bne|8,wb|22,=b_art|6,cop10|return copy if not array|17991
||add|7,xr|13,arofs(xr)||point to prototype field|17995
||brn|6,cop02|||jump to merge|17996
|cop01|add|7,xr|19,*pdfld||point to pdfld = vcvls|18000
|cop02|mov|7,xl|9,(xr)||load next pointer|18005
|cop03|bne|9,(xl)|22,=b_trt|6,cop04|jump if not trapped|18009
||mov|7,xl|13,trval(xl)||else point to next value|18010
||brn|6,cop03|||and loop back|18011
||ejc|||||18012
|cop04|mov|10,(xr)+|7,xl||store real value, bump pointer|18018
||bne|7,xr|3,dnamp|6,cop02|loop back if more to go|18019
||brn|6,cop09|||else jump to exit|18020
|cop05|zer|13,idval(xr)|||zero id to stop dump blowing up|18024
||mov|8,wa|19,*tesi_||set size of teblk|18025
||mov|8,wc|19,*tbbuk||set initial offset|18026
|cop06|mov|7,xr|9,(xs)||load table pointer|18030
||beq|8,wc|13,tblen(xr)|6,cop09|jump to exit if all done|18031
||mov|8,wb|8,wc||else copy offset|18032
||sub|8,wb|19,*tenxt||subtract link offset to merge|18033
||add|7,xr|8,wb||next bucket header less link offset|18034
||ica|8,wc|||bump offset|18035
|cop07|mov|7,xl|13,tenxt(xr)||load pointer to next teblk|18039
||mov|13,tenxt(xr)|9,(xs)||set end of chain pointer in case|18040
||beq|9,(xl)|22,=b_tbt|6,cop06|back for next bucket if chain end|18041
||sub|7,xr|8,wb||point to head of previous block|18042
||mov|11,-(xs)|7,xr||stack ptr to previous block|18043
||mov|8,wa|19,*tesi_||set size of teblk|18044
||jsr|6,alloc|||allocate new teblk|18045
||mov|11,-(xs)|7,xr||stack ptr to new teblk|18046
||mvw||||copy old teblk to new teblk|18047
||mov|7,xr|10,(xs)+||restore pointer to new teblk|18048
||mov|7,xl|10,(xs)+||restore pointer to previous block|18049
||add|7,xl|8,wb||add offset back in|18050
||mov|13,tenxt(xl)|7,xr||link new block to previous|18051
||mov|7,xl|7,xr||copy pointer to new block|18052
|cop08|mov|7,xl|13,teval(xl)||load value|18056
||beq|9,(xl)|22,=b_trt|6,cop08|loop back if trapped|18057
||mov|13,teval(xr)|7,xl||store untrapped value in teblk|18058
||zer|8,wb|||zero offset within teblk|18059
||brn|6,cop07|||back for next teblk|18060
|cop09|mov|7,xr|10,(xs)+||load pointer to block|18064
||exi||||return|18065
|cop10|exi|1,1|||return|18069
||ejc|||||18070
||enp||||end procedure copyb|18088
|cdgcg|prc|25,e|1,0||entry point|18099
||mov|7,xl|13,cmopn(xr)||get unary goto operator|18100
||mov|7,xr|13,cmrop(xr)||point to goto operand|18101
||beq|7,xl|21,=opdvd|6,cdgc2|jump if direct goto|18102
||jsr|6,cdgnm|||generate opnd by name if not direct|18103
|cdgc1|mov|8,wa|7,xl||goto operator|18107
||jsr|6,cdwrd|||generate it|18108
||exi||||return to caller|18109
|cdgc2|jsr|6,cdgvl|||generate operand by value|18113
||brn|6,cdgc1|||merge to return|18114
||enp||||end procedure cdgcg|18115
||ejc|||||18116
|cdgex|prc|25,r|1,0||entry point, recursive|18133
||blo|9,(xl)|22,=b_vr_|6,cdgx1|jump if not variable|18134
||mov|8,wa|19,*sesi_||set size of seblk|18138
||jsr|6,alloc|||allocate space for seblk|18139
||mov|9,(xr)|22,=b_sel||set type word|18140
||mov|13,sevar(xr)|7,xl||store vrblk pointer|18141
||exi||||return to cdgex caller|18142
|cdgx1|mov|7,xr|7,xl||copy tree pointer|18146
||mov|11,-(xs)|8,wc||save wc|18147
||mov|7,xl|3,cwcof||save current offset|18148
||bze|8,wa|6,cdgx2||jump if by value|18150
||mov|8,wa|9,(xr)||get type word|18152
||bne|8,wa|22,=b_cmt|6,cdgx2|call by value if not cmblk|18153
||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|jump if cmblk only by value|18154
||ejc|||||18155
||jsr|6,cdgnm|||generate code by name|18161
||mov|8,wa|21,=ornm_||load return by name word|18162
||brn|6,cdgx3|||merge with value case|18163
|cdgx2|jsr|6,cdgvl|||generate code by value|18167
||mov|8,wa|21,=orvl_||load return by value word|18168
|cdgx3|jsr|6,cdwrd|||generate return word|18172
||jsr|6,exbld|||build exblk|18173
||mov|8,wc|10,(xs)+||restore wc|18174
||exi||||return to cdgex caller|18175
||enp||||end procedure cdgex|18176
||ejc|||||18177
|cdgnm|prc|25,r|1,0||entry point, recursive|18202
||mov|11,-(xs)|7,xl||save entry xl|18203
||mov|11,-(xs)|8,wb||save entry wb|18204
||chk||||check for stack overflow|18205
||mov|8,wa|9,(xr)||load type word|18206
||beq|8,wa|22,=b_cmt|6,cgn04|jump if cmblk|18207
||bhi|8,wa|22,=b_vr_|6,cgn02|jump if simple variable|18208
|cgn01|erb|1,212|26,syntax error: value used where name is required|||18212
|cgn02|mov|8,wa|21,=olvn_||load variable load call|18216
||jsr|6,cdwrd|||generate it|18217
||mov|8,wa|7,xr||copy vrblk pointer|18218
||jsr|6,cdwrd|||generate vrblk pointer|18219
||ejc|||||18220
|cgn03|mov|8,wb|10,(xs)+||restore entry wb|18226
||mov|7,xl|10,(xs)+||restore entry xl|18227
||exi||||return to cdgnm caller|18228
|cgn04|mov|7,xl|7,xr||copy cmblk pointer|18232
||mov|7,xr|13,cmtyp(xr)||load cmblk type|18233
||bge|7,xr|18,=c__nm|6,cgn01|error if not name operand|18234
||bsw|7,xr|2,c__nm||else switch on type|18235
||iff|2,c_arr|6,cgn05||array reference|18243
||iff|2,c_fnc|6,cgn08||function call|18243
||iff|2,c_def|6,cgn09||deferred expression|18243
||iff|2,c_ind|6,cgn10||indirect reference|18243
||iff|2,c_key|6,cgn11||keyword reference|18243
||iff|2,c_ubo|6,cgn08||undefined binary op|18243
||iff|2,c_uuo|6,cgn08||undefined unary op|18243
||esw||||end switch on cmblk type|18243
|cgn05|mov|8,wb|19,*cmopn||point to array operand|18247
|cgn06|jsr|6,cmgen|||generate code for next operand|18251
||mov|8,wc|13,cmlen(xl)||load length of cmblk|18252
||blt|8,wb|8,wc|6,cgn06|loop till all generated|18253
||mov|8,wa|21,=oaon_||load one-subscript case call|18257
||beq|8,wc|19,*cmar1|6,cgn07|jump to exit if one subscript case|18258
||mov|8,wa|21,=oamn_||else load multi-subscript case call|18259
||jsr|6,cdwrd|||generate call|18260
||mov|8,wa|8,wc||copy cmblk length|18261
||btw|8,wa|||convert to words|18262
||sub|8,wa|18,=cmvls||calculate number of subscripts|18263
||ejc|||||18264
|cgn07|mnz|8,wc|||set result non-constant|18270
||jsr|6,cdwrd|||generate word|18271
||brn|6,cgn03|||back to exit|18272
|cgn08|mov|7,xr|7,xl||copy cmblk pointer|18276
||jsr|6,cdgvl|||gen code by value for call|18277
||mov|8,wa|21,=ofne_||get extra call for by name|18278
||brn|6,cgn07|||back to generate and exit|18279
|cgn09|mov|7,xr|13,cmrop(xl)||check if variable|18283
||bhi|9,(xr)|22,=b_vr_|6,cgn02|treat *variable as simple var|18284
||mov|7,xl|7,xr||copy ptr to expression tree|18285
||mov|8,wa|18,=num01||return name|18287
||jsr|6,cdgex|||else build exblk|18289
||mov|8,wa|21,=olex_||set call to load expr by name|18290
||jsr|6,cdwrd|||generate it|18291
||mov|8,wa|7,xr||copy exblk pointer|18292
||jsr|6,cdwrd|||generate exblk pointer|18293
||brn|6,cgn03|||back to exit|18294
|cgn10|mov|7,xr|13,cmrop(xl)||get operand|18298
||jsr|6,cdgvl|||generate code by value for it|18299
||mov|8,wa|21,=oinn_||load call for indirect by name|18300
||brn|6,cgn12|||merge|18301
|cgn11|mov|7,xr|13,cmrop(xl)||get operand|18305
||jsr|6,cdgnm|||generate code by name for it|18306
||mov|8,wa|21,=okwn_||load call for keyword by name|18307
|cgn12|jsr|6,cdwrd|||generate code for operator|18311
||brn|6,cgn03|||exit|18312
||enp||||end procedure cdgnm|18313
||ejc|||||18314
|cdgvl|prc|25,r|1,0||entry point, recursive|18342
||mov|8,wa|9,(xr)||load type word|18343
||beq|8,wa|22,=b_cmt|6,cgv01|jump if cmblk|18344
||blt|8,wa|22,=b_vra|6,cgv00|jump if icblk, rcblk, scblk|18345
||bnz|13,vrlen(xr)|6,cgvl0||jump if not system variable|18346
||mov|11,-(xs)|7,xr||stack xr|18347
||mov|7,xr|13,vrsvp(xr)||point to svblk|18348
||mov|8,wa|13,svbit(xr)||get svblk property bits|18349
||mov|7,xr|10,(xs)+||recover xr|18350
||anb|8,wa|4,btkwv||check if constant keyword value|18351
||beq|8,wa|4,btkwv|6,cgv00|jump if constant keyword value|18352
|cgvl0|mnz|8,wc|||indicate non-constant value|18356
|cgv00|mov|8,wa|7,xr||copy ptr to var or constant|18361
||jsr|6,cdwrd|||generate as code word|18362
||exi||||return to caller|18363
||ejc|||||18364
|cgv01|mov|11,-(xs)|8,wb||save entry wb|18370
||mov|11,-(xs)|7,xl||save entry xl|18371
||mov|11,-(xs)|8,wc||save entry constant flag|18372
||mov|11,-(xs)|3,cwcof||save initial code offset|18373
||chk||||check for stack overflow|18374
||mov|7,xl|7,xr||copy cmblk pointer|18382
||mov|7,xr|13,cmtyp(xr)||load cmblk type|18383
||mov|8,wc|3,cswno||reset constant flag|18384
||ble|7,xr|18,=c_pr_|6,cgv02|jump if not predicate value|18385
||mnz|8,wc|||else force non-constant case|18386
|cgv02|bsw|7,xr|2,c__nv||switch to appropriate generator|18390
||iff|2,c_arr|6,cgv03||array reference|18410
||iff|2,c_fnc|6,cgv05||function call|18410
||iff|2,c_def|6,cgv14||deferred expression|18410
||iff|2,c_ind|6,cgv31||indirect reference|18410
||iff|2,c_key|6,cgv27||keyword reference|18410
||iff|2,c_ubo|6,cgv29||undefined binop|18410
||iff|2,c_uuo|6,cgv30||undefined unop|18410
||iff|2,c_bvl|6,cgv18||binops with val opds|18410
||iff|2,c_uvl|6,cgv19||unops with valu opnd|18410
||iff|2,c_alt|6,cgv18||alternation|18410
||iff|2,c_cnc|6,cgv24||concatenation|18410
||iff|2,c_cnp|6,cgv24||concatenation (not pattern match)|18410
||iff|2,c_unm|6,cgv27||unops with name opnd|18410
||iff|2,c_bvn|6,cgv26||binary _ and .|18410
||iff|2,c_ass|6,cgv21||assignment|18410
||iff|2,c_int|6,cgv31||interrogation|18410
||iff|2,c_neg|6,cgv28||negation|18410
||iff|2,c_sel|6,cgv15||selection|18410
||iff|2,c_pmt|6,cgv18||pattern match|18410
||esw||||end switch on cmblk type|18410
||ejc|||||18411
|cgv03|mov|8,wb|19,*cmopn||set offset to array operand|18417
|cgv04|jsr|6,cmgen|||gen value code for next operand|18421
||mov|8,wc|13,cmlen(xl)||load cmblk length|18422
||blt|8,wb|8,wc|6,cgv04|loop back if more to go|18423
||mov|8,wa|21,=oaov_||set one subscript call in case|18427
||beq|8,wc|19,*cmar1|6,cgv32|jump to exit if 1-sub case|18428
||mov|8,wa|21,=oamv_||else set call for multi-subscripts|18429
||jsr|6,cdwrd|||generate call|18430
||mov|8,wa|8,wc||copy length of cmblk|18431
||sub|8,wa|19,*cmvls||subtract standard length|18432
||btw|8,wa|||get number of words|18433
||brn|6,cgv32|||jump to generate subscript count|18434
|cgv05|mov|8,wb|19,*cmvls||set offset to first argument|18438
|cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|jump if all generated|18442
||jsr|6,cmgen|||else gen value code for next arg|18443
||brn|6,cgv06|||back to generate next argument|18444
|cgv07|sub|8,wb|19,*cmvls||get number of arg ptrs (bytes)|18448
||btw|8,wb|||convert bytes to words|18449
||mov|7,xr|13,cmopn(xl)||load function vrblk pointer|18450
||bnz|13,vrlen(xr)|6,cgv12||jump if not system function|18451
||mov|7,xl|13,vrsvp(xr)||load svblk ptr if system var|18452
||mov|8,wa|13,svbit(xl)||load bit mask|18453
||anb|8,wa|4,btffc||test for fast function call allowed|18454
||zrb|8,wa|6,cgv12||jump if not|18455
||ejc|||||18456
||mov|8,wa|13,svbit(xl)||reload bit indicators|18462
||anb|8,wa|4,btpre||test for preevaluation ok|18463
||nzb|8,wa|6,cgv08||jump if preevaluation permitted|18464
||mnz|8,wc|||else set result non-constant|18465
|cgv08|mov|7,xl|13,vrfnc(xr)||load ptr to svfnc field|18469
||mov|8,wa|13,fargs(xl)||load svnar field value|18470
||beq|8,wa|8,wb|6,cgv11|jump if argument count is correct|18471
||bhi|8,wa|8,wb|6,cgv09|jump if too few arguments given|18472
||sub|8,wb|8,wa||get number of extra args|18476
||lct|8,wb|8,wb||set as count to control loop|18477
||mov|8,wa|21,=opop_||set pop call|18478
||brn|6,cgv10|||jump to common loop|18479
|cgv09|sub|8,wa|8,wb||get number of missing arguments|18483
||lct|8,wb|8,wa||load as count to control loop|18484
||mov|8,wa|21,=nulls||load ptr to null constant|18485
|cgv10|jsr|6,cdwrd|||generate one call|18489
||bct|8,wb|6,cgv10||loop till all generated|18490
|cgv11|mov|8,wa|7,xl||copy pointer to svfnc field|18494
||brn|6,cgv36|||jump to generate call|18495
||ejc|||||18496
|cgv12|mov|8,wa|21,=ofns_||set one arg call in case|18502
||beq|8,wb|18,=num01|6,cgv13|jump if one arg case|18503
||mov|8,wa|21,=ofnc_||else load call for more than 1 arg|18504
||jsr|6,cdwrd|||generate it|18505
||mov|8,wa|8,wb||copy argument count|18506
|cgv13|jsr|6,cdwrd|||generate =o_fns or arg count|18510
||mov|8,wa|7,xr||copy vrblk pointer|18511
||brn|6,cgv32|||jump to generate vrblk ptr|18512
|cgv14|mov|7,xl|13,cmrop(xl)||point to expression tree|18516
||zer|8,wa|||return value|18518
||jsr|6,cdgex|||build exblk or seblk|18520
||mov|8,wa|7,xr||copy block ptr|18521
||jsr|6,cdwrd|||generate ptr to exblk or seblk|18522
||brn|6,cgv34|||jump to exit, constant test|18523
|cgv15|zer|11,-(xs)|||zero ptr to chain of forward jumps|18527
||zer|11,-(xs)|||zero ptr to prev o_slc forward ptr|18528
||mov|8,wb|19,*cmvls||point to first alternative|18529
||mov|8,wa|21,=osla_||set initial code word|18530
|cgv16|jsr|6,cdwrd|||generate o_slc (o_sla first time)|18541
||mov|9,(xs)|3,cwcof||set current loc as ptr to fill in|18542
||jsr|6,cdwrd|||generate garbage word there for now|18543
||jsr|6,cmgen|||gen value code for alternative|18544
||mov|8,wa|21,=oslb_||load o_slb pointer|18545
||jsr|6,cdwrd|||generate o_slb call|18546
||mov|8,wa|13,num01(xs)||load old chain ptr|18547
||mov|13,num01(xs)|3,cwcof||set current loc as new chain head|18548
||jsr|6,cdwrd|||generate forward chain link|18549
||ejc|||||18550
||mov|7,xr|9,(xs)||load offset to word to plug|18556
||add|7,xr|3,r_ccb||point to actual location to plug|18557
||mov|9,(xr)|3,cwcof||plug proper offset in|18558
||mov|8,wa|21,=oslc_||load o_slc ptr for next alternative|18559
||mov|7,xr|8,wb||copy offset (destroy garbage xr)|18560
||ica|7,xr|||bump extra time for test|18561
||blt|7,xr|13,cmlen(xl)|6,cgv16|loop back if not last alternative|18562
||mov|8,wa|21,=osld_||get header call|18566
||jsr|6,cdwrd|||generate o_sld call|18567
||jsr|6,cmgen|||generate code for last alternative|18568
||ica|7,xs|||pop offset ptr|18569
||mov|7,xr|10,(xs)+||load chain ptr|18570
|cgv17|add|7,xr|3,r_ccb||make next ptr absolute|18574
||mov|8,wa|9,(xr)||load forward ptr|18575
||mov|9,(xr)|3,cwcof||plug required offset|18576
||mov|7,xr|8,wa||copy forward ptr|18577
||bnz|8,wa|6,cgv17||loop back if more to go|18578
||brn|6,cgv33|||else jump to exit (not constant)|18579
|cgv18|mov|7,xr|13,cmlop(xl)||load left operand pointer|18583
||jsr|6,cdgvl|||gen value code for left operand|18584
|cgv19|mov|7,xr|13,cmrop(xl)||load right (only) operand ptr|18588
||jsr|6,cdgvl|||gen code by value|18589
||ejc|||||18590
|cgv20|mov|8,wa|13,cmopn(xl)||load operator call pointer|18596
||brn|6,cgv36|||jump to generate it with cons test|18597
|cgv21|mov|7,xr|13,cmlop(xl)||load left operand pointer|18601
||blo|9,(xr)|22,=b_vr_|6,cgv22|jump if not variable|18602
||mov|7,xr|13,cmrop(xl)||load right operand ptr|18606
||jsr|6,cdgvl|||generate code by value|18607
||mov|8,wa|13,cmlop(xl)||reload left operand vrblk ptr|18608
||add|8,wa|19,*vrsto||point to vrsto field|18609
||brn|6,cgv32|||jump to generate store ptr|18610
|cgv22|jsr|6,expap|||test for pattern match on left side|18614
||ppm|6,cgv23|||jump if not pattern match|18615
||mov|13,cmlop(xl)|13,cmrop(xr)||save pattern ptr in safe place|18619
||mov|7,xr|13,cmlop(xr)||load subject ptr|18620
||jsr|6,cdgnm|||gen code by name for subject|18621
||mov|7,xr|13,cmlop(xl)||load pattern ptr|18622
||jsr|6,cdgvl|||gen code by value for pattern|18623
||mov|8,wa|21,=opmn_||load match by name call|18624
||jsr|6,cdwrd|||generate it|18625
||mov|7,xr|13,cmrop(xl)||load replacement value ptr|18626
||jsr|6,cdgvl|||gen code by value|18627
||mov|8,wa|21,=orpl_||load replace call|18628
||brn|6,cgv32|||jump to gen and exit (not constant)|18629
|cgv23|mnz|8,wc|||inhibit pre-evaluation|18633
||jsr|6,cdgnm|||gen code by name for left side|18634
||brn|6,cgv31|||merge with unop circuit|18635
||ejc|||||18636
|cgv24|mov|7,xr|13,cmlop(xl)||load left operand ptr|18642
||bne|9,(xr)|22,=b_cmt|6,cgv18|ordinary binop if not cmblk|18643
||mov|8,wb|13,cmtyp(xr)||load cmblk type code|18644
||beq|8,wb|18,=c_int|6,cgv25|special case if interrogation|18645
||beq|8,wb|18,=c_neg|6,cgv25|or negation|18646
||bne|8,wb|18,=c_fnc|6,cgv18|else ordinary binop if not function|18647
||mov|7,xr|13,cmopn(xr)||else load function vrblk ptr|18648
||bnz|13,vrlen(xr)|6,cgv18||ordinary binop if not system var|18649
||mov|7,xr|13,vrsvp(xr)||else point to svblk|18650
||mov|8,wa|13,svbit(xr)||load bit indicators|18651
||anb|8,wa|4,btprd||test for predicate function|18652
||zrb|8,wa|6,cgv18||ordinary binop if not|18653
|cgv25|mov|7,xr|13,cmlop(xl)||reload left arg|18657
||jsr|6,cdgvl|||gen code by value|18658
||mov|8,wa|21,=opop_||load pop call|18659
||jsr|6,cdwrd|||generate it|18660
||mov|7,xr|13,cmrop(xl)||load right operand|18661
||jsr|6,cdgvl|||gen code by value as result code|18662
||brn|6,cgv33|||exit (not constant)|18663
|cgv26|mov|7,xr|13,cmlop(xl)||load left operand|18667
||jsr|6,cdgvl|||gen code by value, merge|18668
|cgv27|mov|7,xr|13,cmrop(xl)||load right operand ptr|18672
||jsr|6,cdgnm|||gen code by name for right arg|18673
||mov|7,xr|13,cmopn(xl)||get operator code word|18674
||bne|9,(xr)|22,=o_kwv|6,cgv20|gen call unless keyword value|18675
||ejc|||||18676
||bnz|8,wc|6,cgv20||gen call if non-constant (not var)|18685
||mnz|8,wc|||else set non-constant in case|18686
||mov|7,xr|13,cmrop(xl)||load ptr to operand vrblk|18687
||bnz|13,vrlen(xr)|6,cgv20||gen (non-constant) if not sys var|18688
||mov|7,xr|13,vrsvp(xr)||else load ptr to svblk|18689
||mov|8,wa|13,svbit(xr)||load bit mask|18690
||anb|8,wa|4,btckw||test for constant keyword|18691
||zrb|8,wa|6,cgv20||go gen if not constant|18692
||zer|8,wc|||else set result constant|18693
||brn|6,cgv20|||and jump back to generate call|18694
|cgv28|mov|8,wa|21,=onta_||get initial word|18698
||jsr|6,cdwrd|||generate it|18699
||mov|8,wb|3,cwcof||save next offset|18700
||jsr|6,cdwrd|||generate gunk word for now|18701
||mov|7,xr|13,cmrop(xl)||load right operand ptr|18702
||jsr|6,cdgvl|||gen code by value|18703
||mov|8,wa|21,=ontb_||load end of evaluation call|18704
||jsr|6,cdwrd|||generate it|18705
||mov|7,xr|8,wb||copy offset to word to plug|18706
||add|7,xr|3,r_ccb||point to actual word to plug|18707
||mov|9,(xr)|3,cwcof||plug word with current offset|18708
||mov|8,wa|21,=ontc_||load final call|18709
||brn|6,cgv32|||jump to generate it (not constant)|18710
|cgv29|mov|7,xr|13,cmlop(xl)||load left operand ptr|18714
||jsr|6,cdgvl|||generate code by value|18715
||ejc|||||18716
|cgv30|mov|8,wb|18,=c_uo_||set unop code + 1|18722
||sub|8,wb|13,cmtyp(xl)||set number of args (1 or 2)|18723
||mov|7,xr|13,cmrop(xl)||load right (only) operand pointer|18727
||jsr|6,cdgvl|||gen value code for right operand|18728
||mov|7,xr|13,cmopn(xl)||load pointer to operator dv|18729
||mov|7,xr|13,dvopn(xr)||load pointer offset|18730
||wtb|7,xr|||convert word offset to bytes|18731
||add|7,xr|20,=r_uba||point to proper function ptr|18732
||sub|7,xr|19,*vrfnc||set standard function offset|18733
||brn|6,cgv12|||merge with function call circuit|18734
|cgv31|mnz|8,wc|||set non constant|18738
||brn|6,cgv19|||merge|18739
|cgv32|jsr|6,cdwrd|||generate word, merge|18743
|cgv33|mnz|8,wc|||indicate result is not constant|18747
|cgv34|ica|7,xs|||pop initial code offset|18751
||mov|8,wa|10,(xs)+||restore old constant flag|18752
||mov|7,xl|10,(xs)+||restore entry xl|18753
||mov|8,wb|10,(xs)+||restore entry wb|18754
||bnz|8,wc|6,cgv35||jump if not constant|18755
||mov|8,wc|8,wa||else restore entry constant flag|18756
|cgv35|exi||||return to cdgvl caller|18760
|cgv36|jsr|6,cdwrd|||generate word|18764
||bnz|8,wc|6,cgv34||jump to exit if not constant|18765
||ejc|||||18766
||mov|8,wa|21,=orvl_||load call to return value|18772
||jsr|6,cdwrd|||generate it|18773
||mov|7,xl|9,(xs)||load initial code offset|18774
||jsr|6,exbld|||build exblk for expression|18775
||zer|8,wb|||set to evaluate by value|18776
||jsr|6,evalx|||evaluate expression|18777
||ppm||||should not fail|18778
||mov|8,wa|9,(xr)||load type word of result|18779
||blo|8,wa|22,=p_aaa|6,cgv37|jump if not pattern|18780
||mov|8,wa|21,=olpt_||else load special pattern load call|18781
||jsr|6,cdwrd|||generate it|18782
|cgv37|mov|8,wa|7,xr||copy constant pointer|18786
||jsr|6,cdwrd|||generate ptr|18787
||zer|8,wc|||set result constant|18788
||brn|6,cgv34|||jump back to exit|18789
||enp||||end procedure cdgvl|18790
||ejc|||||18791
|cdwrd|prc|25,e|1,0||entry point|18809
||mov|11,-(xs)|7,xr||save entry xr|18810
||mov|11,-(xs)|8,wa||save code word to be generated|18811
|cdwd1|mov|7,xr|3,r_ccb||load ptr to ccblk being built|18815
||bnz|7,xr|6,cdwd2||jump if block allocated|18816
||mov|8,wa|19,*e_cbs||load initial length|18820
||jsr|6,alloc|||allocate ccblk|18821
||mov|9,(xr)|22,=b_cct||store type word|18822
||mov|3,cwcof|19,*cccod||set initial offset|18823
||mov|13,cclen(xr)|8,wa||store block length|18824
||zer|13,ccsln(xr)|||zero line number|18826
||mov|3,r_ccb|7,xr||store ptr to new block|18828
|cdwd2|mov|8,wa|3,cwcof||load current offset|18832
||add|8,wa|19,*num05||adjust for test (five words)|18834
||blo|8,wa|13,cclen(xr)|6,cdwd4|jump if room in this block|18838
||bge|8,wa|3,mxlen|6,cdwd5|jump if already at max size|18842
||add|8,wa|19,*e_cbs||else get new size|18843
||mov|11,-(xs)|7,xl||save entry xl|18844
||mov|7,xl|7,xr||copy pointer|18845
||blt|8,wa|3,mxlen|6,cdwd3|jump if not too large|18846
||mov|8,wa|3,mxlen||else reset to max allowed size|18847
||ejc|||||18848
|cdwd3|jsr|6,alloc|||allocate new block|18854
||mov|3,r_ccb|7,xr||store pointer to new block|18855
||mov|10,(xr)+|22,=b_cct||store type word in new block|18856
||mov|10,(xr)+|8,wa||store block length|18857
||mov|10,(xr)+|13,ccsln(xl)||copy source line number word|18859
||add|7,xl|19,*ccuse||point to ccuse,cccod fields in old|18861
||mov|8,wa|9,(xl)||load ccuse value|18862
||mvw||||copy useful words from old block|18863
||mov|7,xl|10,(xs)+||restore xl|18864
||brn|6,cdwd1|||merge back to try again|18865
|cdwd4|mov|8,wa|3,cwcof||load current offset|18869
||ica|8,wa|||get new offset|18870
||mov|3,cwcof|8,wa||store new offset|18871
||mov|13,ccuse(xr)|8,wa||store in ccblk for gbcol|18872
||dca|8,wa|||restore ptr to this word|18873
||add|7,xr|8,wa||point to current entry|18874
||mov|8,wa|10,(xs)+||reload word to generate|18875
||mov|9,(xr)|8,wa||store word in block|18876
||mov|7,xr|10,(xs)+||restore entry xr|18877
||exi||||return to caller|18878
|cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||18882
||enp||||end procedure cdwrd|18883
||ejc|||||18884
|cmgen|prc|25,r|1,0||entry point, recursive|18897
||mov|7,xr|7,xl||copy cmblk pointer|18898
||add|7,xr|8,wb||point to cmblk pointer|18899
||mov|7,xr|9,(xr)||load cmblk pointer|18900
||jsr|6,cdgvl|||generate code by value|18901
||ica|8,wb|||bump offset|18902
||exi||||return to caller|18903
||enp||||end procedure cmgen|18904
||ejc|||||18905
||ejc|||||18962
||ejc|||||19010
|cmpil|prc|25,e|1,0||entry point|19016
||lct|8,wb|18,=cmnen||set number of stack work locations|19017
|cmp00|zer|11,-(xs)|||store a zero, make one entry|19021
||bct|8,wb|6,cmp00||loop back until all set|19022
||mov|3,cmpxs|7,xs||save stack pointer for error sec|19023
||sss|3,cmpss|||save s-r stack pointer if any|19024
|cmp01|mov|8,wb|3,scnpt||set scan pointer offset|19028
||mov|3,scnse|8,wb||set start of element location|19029
||mov|8,wa|21,=ocer_||point to compile error call|19030
||jsr|6,cdwrd|||generate as temporary cdfal|19031
||blt|8,wb|3,scnil|6,cmp04|jump if chars left on this image|19032
|cmpce|zer|7,xr|||clear possible garbage xr value|19037
||bnz|3,cnind|6,cmpc2||if within include file|19039
||bne|3,stage|18,=stgic|6,cmp02|skip unless initial compile|19041
|cmpc2|jsr|6,readr|||read next input image|19042
||bze|7,xr|6,cmp09||jump if no input available|19043
||jsr|6,nexts|||acquire next source image|19044
||mov|3,lstsn|3,cmpsn||store stmt no for use by listr|19045
||mov|3,cmpln|3,rdcln||store line number at start of stmt|19046
||zer|3,scnpt|||reset scan pointer|19047
||brn|6,cmp04|||go process image|19048
|cmp02|mov|7,xr|3,r_cim||get current image|19053
||mov|8,wb|3,scnpt||get current offset|19054
||plc|7,xr|8,wb||prepare to get chars|19055
|cmp03|bge|3,scnpt|3,scnil|6,cmp09|end loop if end of image|19059
||lch|8,wc|10,(xr)+||get char|19060
||icv|3,scnpt|||advance offset|19061
||bne|8,wc|18,=ch_sm|6,cmp03|loop if not semi-colon|19062
||ejc|||||19063
|cmp04|mov|7,xr|3,r_cim||point to current image|19071
||mov|8,wb|3,scnpt||load current offset|19072
||mov|8,wa|8,wb||copy for label scan|19073
||plc|7,xr|8,wb||point to first character|19074
||lch|8,wc|10,(xr)+||load first character|19075
||beq|8,wc|18,=ch_sm|6,cmp12|no label if semicolon|19076
||beq|8,wc|18,=ch_as|6,cmpce|loop back if comment card|19077
||beq|8,wc|18,=ch_mn|6,cmp32|jump if control card|19078
||mov|3,r_cmp|3,r_cim||about to destroy r_cim|19079
||mov|7,xl|20,=cmlab||point to label work string|19080
||mov|3,r_cim|7,xl||scane is to scan work string|19081
||psc|7,xl|||point to first character position|19082
||sch|8,wc|10,(xl)+||store char just loaded|19083
||mov|8,wc|18,=ch_sm||get a semicolon|19084
||sch|8,wc|9,(xl)||store after first char|19085
||csc|7,xl|||finished character storing|19086
||zer|7,xl|||clear pointer|19087
||zer|3,scnpt|||start at first character|19088
||mov|11,-(xs)|3,scnil||preserve image length|19089
||mov|3,scnil|18,=num02||read 2 chars at most|19090
||jsr|6,scane|||scan first char for type|19091
||mov|3,scnil|10,(xs)+||restore image length|19092
||mov|8,wc|7,xl||note return code|19093
||mov|7,xl|3,r_cmp||get old r_cim|19094
||mov|3,r_cim|7,xl||put it back|19095
||mov|3,scnpt|8,wb||reinstate offset|19096
||bnz|3,scnbl|6,cmp12||blank seen - cant be label|19097
||mov|7,xr|7,xl||point to current image|19098
||plc|7,xr|8,wb||point to first char again|19099
||beq|8,wc|18,=t_var|6,cmp06|ok if letter|19100
||beq|8,wc|18,=t_con|6,cmp06|ok if digit|19101
|cmple|mov|3,r_cim|3,r_cmp||point to bad line|19105
||erb|1,214|26,bad label or misplaced continuation line|||19106
|cmp05|beq|8,wc|18,=ch_sm|6,cmp07|skip if semicolon|19110
||icv|8,wa|||bump offset|19111
||beq|8,wa|3,scnil|6,cmp07|jump if end of image (label end)|19112
||ejc|||||19113
|cmp06|lch|8,wc|10,(xr)+||else load next character|19119
||beq|8,wc|18,=ch_ht|6,cmp07|jump if horizontal tab|19121
||bne|8,wc|18,=ch_bl|6,cmp05|loop back if non-blank|19126
|cmp07|mov|3,scnpt|8,wa||save updated scan offset|19130
||sub|8,wa|8,wb||get length of label|19131
||bze|8,wa|6,cmp12||skip if label length zero|19132
||zer|7,xr|||clear garbage xr value|19133
||jsr|6,sbstr|||build scblk for label name|19134
||jsr|6,gtnvr|||locate/contruct vrblk|19135
||ppm||||dummy (impossible) error return|19136
||mov|13,cmlbl(xs)|7,xr||store label pointer|19137
||bnz|13,vrlen(xr)|6,cmp11||jump if not system label|19138
||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|jump if not end label|19139
||add|3,stage|18,=stgnd||adjust stage appropriately|19143
||jsr|6,scane|||scan out next element|19144
||beq|7,xl|18,=t_smc|6,cmp10|jump if end of image|19145
||bne|7,xl|18,=t_var|6,cmp08|else error if not variable|19146
||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|jump if not defined (error)|19150
||mov|13,cmtra(xs)|13,vrlbl(xr)||else set initial entry pointer|19151
||jsr|6,scane|||scan next element|19152
||beq|7,xl|18,=t_smc|6,cmp10|jump if ok (end of image)|19153
|cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||19157
|cmp09|zer|7,xr|||clear garbage xr value|19161
||add|3,stage|18,=stgnd||adjust stage appropriately|19162
||beq|3,stage|18,=stgxe|6,cmp10|jump if code call (ok)|19163
||erb|1,216|26,syntax error: missing end line|||19164
|cmp10|mov|8,wa|21,=ostp_||set stop call pointer|19168
||jsr|6,cdwrd|||generate as statement call|19169
||brn|6,cmpse|||jump to generate as failure|19170
||ejc|||||19171
|cmp11|bne|3,stage|18,=stgic|6,cmp12|jump if code call - redef. ok|19177
||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|else check for redefinition|19178
||zer|13,cmlbl(xs)|||leave first label decln undisturbed|19179
||erb|1,217|26,syntax error: duplicate label|||19180
|cmp12|zer|8,wb|||set flag for statement body|19187
||jsr|6,expan|||get tree for statement body|19188
||mov|13,cmstm(xs)|7,xr||store for later use|19189
||zer|13,cmsgo(xs)|||clear success goto pointer|19190
||zer|13,cmfgo(xs)|||clear failure goto pointer|19191
||zer|13,cmcgo(xs)|||clear conditional goto flag|19192
||jsr|6,scane|||scan next element|19193
||beq|7,xl|18,=t_col|6,cmp13|jump if colon (goto)|19194
||bnz|3,cswno|6,cmp18||jump if not optimizing|19195
||bnz|13,cmlbl(xs)|6,cmp18||jump if label present|19196
||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19197
||mov|8,wa|9,(xr)||load type word|19198
||beq|8,wa|22,=b_cmt|6,cmp18|jump if cmblk|19199
||bge|8,wa|22,=b_vra|6,cmp18|jump if not icblk, scblk, or rcblk|19200
||mov|7,xl|3,r_ccb||load ptr to ccblk|19201
||mov|13,ccuse(xl)|19,*cccod||reset use offset in ccblk|19202
||mov|3,cwcof|19,*cccod||and in global|19203
||icv|3,cmpsn|||bump statement number|19204
||brn|6,cmp01|||generate no code for statement|19205
|cmp13|mnz|3,scngo|||set goto flag|19209
||jsr|6,scane|||scan next element|19210
||beq|7,xl|18,=t_smc|6,cmp31|jump if no fields left|19211
||beq|7,xl|18,=t_sgo|6,cmp14|jump if s for success goto|19212
||beq|7,xl|18,=t_fgo|6,cmp16|jump if f for failure goto|19213
||mnz|3,scnrs|||set to rescan element not f,s|19217
||jsr|6,scngf|||scan out goto field|19218
||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already|19219
||mov|13,cmfgo(xs)|7,xr||else set as fgoto|19220
||brn|6,cmp15|||merge with sgoto circuit|19221
|cmp14|jsr|6,scngf|||scan success goto field|19225
||mov|13,cmcgo(xs)|18,=num01||set conditional goto flag|19226
|cmp15|bnz|13,cmsgo(xs)|6,cmp17||error if sgoto already given|19230
||mov|13,cmsgo(xs)|7,xr||else set sgoto|19231
||brn|6,cmp13|||loop back for next goto field|19232
|cmp16|jsr|6,scngf|||scan goto field|19236
||mov|13,cmcgo(xs)|18,=num01||set conditonal goto flag|19237
||bnz|13,cmfgo(xs)|6,cmp17||error if fgoto already given|19238
||mov|13,cmfgo(xs)|7,xr||else store fgoto pointer|19239
||brn|6,cmp13|||loop back for next field|19240
||ejc|||||19241
|cmp17|erb|1,218|26,syntax error: duplicated goto field|||19247
|cmp18|zer|3,scnse|||stop positional error flags|19251
||mov|7,xr|13,cmstm(xs)||load tree ptr for statement body|19252
||zer|8,wb|||collectable value for wb for cdgvl|19253
||zer|8,wc|||reset constant flag for cdgvl|19254
||jsr|6,expap|||test for pattern match|19255
||ppm|6,cmp19|||jump if not pattern match|19256
||mov|13,cmopn(xr)|21,=opms_||else set pattern match pointer|19257
||mov|13,cmtyp(xr)|18,=c_pmt|||19258
|cmp19|jsr|6,cdgvl|||generate code for body of statement|19262
||mov|7,xr|13,cmsgo(xs)||load sgoto pointer|19263
||mov|8,wa|7,xr||copy it|19264
||bze|7,xr|6,cmp21||jump if no success goto|19265
||zer|13,cmsoc(xs)|||clear success offset fillin ptr|19266
||bhi|7,xr|3,state|6,cmp20|jump if complex goto|19267
||add|8,wa|19,*vrtra||point to vrtra field as required|19271
||jsr|6,cdwrd|||generate success goto|19272
||brn|6,cmp22|||jump to deal with fgoto|19273
|cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|no code if same as fgoto|19277
||zer|8,wb|||else set ok value for cdgvl in wb|19278
||jsr|6,cdgcg|||generate code for success goto|19279
||brn|6,cmp22|||jump to deal with fgoto|19280
|cmp21|mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|19284
||mov|8,wa|21,=ocer_||point to compile error call|19285
||jsr|6,cdwrd|||generate as temporary value|19286
||ejc|||||19287
|cmp22|mov|7,xr|13,cmfgo(xs)||load failure goto pointer|19293
||mov|8,wa|7,xr||copy it|19294
||zer|13,cmffc(xs)|||set no fill in required yet|19295
||bze|7,xr|6,cmp23||jump if no failure goto given|19296
||add|8,wa|19,*vrtra||point to vrtra field in case|19297
||blo|7,xr|3,state|6,cmpse|jump to gen if simple fgoto|19298
||mov|8,wb|3,cwcof||save offset to o_gof call|19302
||mov|8,wa|21,=ogof_||point to failure goto call|19303
||jsr|6,cdwrd|||generate|19304
||mov|8,wa|21,=ofif_||point to fail in fail word|19305
||jsr|6,cdwrd|||generate|19306
||jsr|6,cdgcg|||generate code for failure goto|19307
||mov|8,wa|8,wb||copy offset to o_gof for cdfal|19308
||mov|8,wb|22,=b_cdc||set complex case cdtyp|19309
||brn|6,cmp25|||jump to build cdblk|19310
|cmp23|mov|8,wa|21,=ounf_||load unexpected failure call in cas|19314
||mov|8,wc|3,cswfl||get -nofail flag|19315
||orb|8,wc|13,cmcgo(xs)||check if conditional goto|19316
||zrb|8,wc|6,cmpse||jump if -nofail and no cond. goto|19317
||mnz|13,cmffc(xs)|||else set fill in flag|19318
||mov|8,wa|21,=ocer_||and set compile error for temporary|19319
|cmpse|mov|8,wb|22,=b_cds||set cdtyp for simple case|19324
||ejc|||||19325
|cmp25|mov|7,xr|3,r_ccb||point to ccblk|19338
||mov|7,xl|13,cmlbl(xs)||get possible label pointer|19339
||bze|7,xl|6,cmp26||skip if no label|19340
||zer|13,cmlbl(xs)|||clear flag for next statement|19341
||mov|13,vrlbl(xl)|7,xr||put cdblk ptr in vrblk label field|19342
|cmp26|mov|9,(xr)|8,wb||set type word for new cdblk|19346
||mov|13,cdfal(xr)|8,wa||set failure word|19347
||mov|7,xl|7,xr||copy pointer to ccblk|19348
||mov|8,wb|13,ccuse(xr)||load length gen (= new cdlen)|19349
||mov|8,wc|13,cclen(xr)||load total ccblk length|19350
||add|7,xl|8,wb||point past cdblk|19351
||sub|8,wc|8,wb||get length left for chop off|19352
||mov|9,(xl)|22,=b_cct||set type code for new ccblk at end|19353
||mov|13,ccuse(xl)|19,*cccod||set initial code offset|19354
||mov|3,cwcof|19,*cccod||reinitialise cwcof|19355
||mov|13,cclen(xl)|8,wc||set new length|19356
||mov|3,r_ccb|7,xl||set new ccblk pointer|19357
||zer|13,ccsln(xl)|||initialize new line number|19359
||mov|13,cdsln(xr)|3,cmpln||set line number in old block|19360
||mov|13,cdstm(xr)|3,cmpsn||set statement number|19362
||icv|3,cmpsn|||bump statement number|19363
||mov|7,xl|13,cmpcd(xs)||load ptr to previous cdblk|19367
||bze|13,cmffp(xs)|6,cmp27||jump if no failure fill in required|19368
||mov|13,cdfal(xl)|7,xr||else set failure ptr in previous|19369
|cmp27|mov|8,wa|13,cmsop(xs)||load success offset|19373
||bze|8,wa|6,cmp28||jump if no fill in required|19374
||add|7,xl|8,wa||else point to fill in location|19375
||mov|9,(xl)|7,xr||store forward pointer|19376
||zer|7,xl|||clear garbage xl value|19377
||ejc|||||19378
|cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||copy failure fill in flag|19384
||mov|13,cmsop(xs)|13,cmsoc(xs)||copy success fill in offset|19385
||mov|13,cmpcd(xs)|7,xr||save ptr to this cdblk|19386
||bnz|13,cmtra(xs)|6,cmp29||jump if initial entry already set|19387
||mov|13,cmtra(xs)|7,xr||else set ptr here as default|19388
|cmp29|blt|3,stage|18,=stgce|6,cmp01|jump if not end line just done|19392
||bze|3,cswls|6,cmp30||skip if -nolist|19393
||jsr|6,listr|||list last line|19394
|cmp30|mov|7,xr|13,cmtra(xs)||load initial entry cdblk pointer|19398
||add|7,xs|19,*cmnen||pop work locations off stack|19399
||exi||||and return to cmpil caller|19400
|cmp31|mov|8,wb|13,cmfgo(xs)||get fail goto|19404
||orb|8,wb|13,cmsgo(xs)||or in success goto|19405
||bnz|8,wb|6,cmp18||ok if non-null field|19406
||erb|1,219|26,syntax error: empty goto field|||19407
|cmp32|icv|8,wb|||point past ch_mn|19411
||jsr|6,cncrd|||process control card|19412
||zer|3,scnse|||clear start of element loc.|19413
||brn|6,cmpce|||loop for next statement|19414
||enp||||end procedure cmpil|19415
||ejc|||||19416
|cncrd|prc|25,e|1,0||entry point|19427
||mov|3,scnpt|8,wb||offset for control card scan|19428
||mov|8,wa|18,=ccnoc||number of chars for comparison|19429
||ctw|8,wa|1,0||convert to word count|19430
||mov|3,cnswc|8,wa||save word count|19431
|cnc01|bge|3,scnpt|3,scnil|6,cnc09|return if end of image|19435
||mov|7,xr|3,r_cim||point to image|19436
||plc|7,xr|3,scnpt||char ptr for first char|19437
||lch|8,wa|10,(xr)+||get first char|19438
||beq|8,wa|18,=ch_li|6,cnc07|special case of -inxxx|19442
|cnc0a|mnz|3,scncc|||set flag for scane|19443
||jsr|6,scane|||scan card name|19444
||zer|3,scncc|||clear scane flag|19445
||bnz|7,xl|6,cnc06||fail unless control card name|19446
||mov|8,wa|18,=ccnoc||no. of chars to be compared|19447
||blt|13,sclen(xr)|8,wa|6,cnc08|fail if too few chars|19449
||mov|7,xl|7,xr||point to control card name|19453
||zer|8,wb|||zero offset for substring|19454
||jsr|6,sbstr|||extract substring for comparison|19455
||mov|3,cnscc|7,xr||keep control card substring ptr|19460
||mov|7,xr|21,=ccnms||point to list of standard names|19461
||zer|8,wb|||initialise name offset|19462
||lct|8,wc|18,=cc_nc||number of standard names|19463
|cnc02|mov|7,xl|3,cnscc||point to name|19467
||lct|8,wa|3,cnswc||counter for inner loop|19468
||brn|6,cnc04|||jump into loop|19469
|cnc03|ica|7,xr|||bump standard names ptr|19473
||ica|7,xl|||bump name pointer|19474
|cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|comp. up to cfp_c chars at once|19478
||bct|8,wa|6,cnc03||loop if more words to compare|19479
||ejc|||||19480
||mov|7,xl|8,wb||get name offset|19486
||bsw|7,xl|2,cc_nc|6,cnc08|switch|19488
||iff|2,cc_do|6,cnc10||-double|19527
||iff|1,1|6,cnc08|||19527
||iff|2,cc_du|6,cnc11||-dump|19527
||iff|2,cc_cp|6,cnc41||-copy|19527
||iff|2,cc_ej|6,cnc12||-eject|19527
||iff|2,cc_er|6,cnc13||-errors|19527
||iff|2,cc_ex|6,cnc14||-execute|19527
||iff|2,cc_fa|6,cnc15||-fail|19527
||iff|2,cc_in|6,cnc41||-include|19527
||iff|2,cc_ln|6,cnc44||-line|19527
||iff|2,cc_li|6,cnc16||-list|19527
||iff|2,cc_nr|6,cnc17||-noerrors|19527
||iff|2,cc_nx|6,cnc18||-noexecute|19527
||iff|2,cc_nf|6,cnc19||-nofail|19527
||iff|2,cc_nl|6,cnc20||-nolist|19527
||iff|2,cc_no|6,cnc21||-noopt|19527
||iff|2,cc_np|6,cnc22||-noprint|19527
||iff|2,cc_op|6,cnc24||-optimise|19527
||iff|2,cc_pr|6,cnc25||-print|19527
||iff|2,cc_si|6,cnc27||-single|19527
||iff|2,cc_sp|6,cnc28||-space|19527
||iff|2,cc_st|6,cnc31||-stitle|19527
||iff|2,cc_ti|6,cnc32||-title|19527
||iff|2,cc_tr|6,cnc36||-trace|19527
||esw||||end switch|19527
|cnc05|ica|7,xr|||bump standard names ptr|19531
||bct|8,wa|6,cnc05||loop|19532
||icv|8,wb|||bump names offset|19533
||bct|8,wc|6,cnc02||continue if more names|19534
||brn|6,cnc08|||ignore unrecognized control card|19536
|cnc06|erb|1,247|26,invalid control statement|||19541
|cnc07|lch|8,wa|10,(xr)+||get next char|19545
||bne|8,wa|18,=ch_ln|6,cnc0a|if not letter n|19549
||lch|8,wa|9,(xr)||get third char|19550
||blt|8,wa|18,=ch_d0|6,cnc0a|if not digit|19551
||bgt|8,wa|18,=ch_d9|6,cnc0a|if not digit|19552
||add|3,scnpt|18,=num02||bump offset past -in|19553
||jsr|6,scane|||scan integer after -in|19554
||mov|11,-(xs)|7,xr||stack scanned item|19555
||jsr|6,gtsmi|||check if integer|19556
||ppm|6,cnc06|||fail if not integer|19557
||ppm|6,cnc06|||fail if negative or large|19558
||mov|3,cswin|7,xr||keep integer|19559
||ejc|||||19560
|cnc08|mov|8,wa|3,scnpt||preserve in case xeq time compile|19566
||jsr|6,scane|||look for comma|19567
||beq|7,xl|18,=t_cma|6,cnc01|loop if comma found|19568
||mov|3,scnpt|8,wa||restore scnpt in case xeq time|19569
|cnc09|exi||||return|19573
|cnc10|mnz|3,cswdb|||set switch|19577
||brn|6,cnc08|||merge|19578
|cnc11|jsr|6,sysdm|||call dumper|19584
||brn|6,cnc09|||finished|19585
|cnc12|bze|3,cswls|6,cnc09||return if -nolist|19589
||jsr|6,prtps|||eject|19590
||jsr|6,listt|||list title|19591
||brn|6,cnc09|||finished|19592
|cnc13|zer|3,cswer|||clear switch|19596
||brn|6,cnc08|||merge|19597
|cnc14|zer|3,cswex|||clear switch|19601
||brn|6,cnc08|||merge|19602
|cnc15|mnz|3,cswfl|||set switch|19606
||brn|6,cnc08|||merge|19607
|cnc16|mnz|3,cswls|||set switch|19611
||beq|3,stage|18,=stgic|6,cnc08|done if compile time|19612
||zer|3,lstpf|||permit listing|19616
||jsr|6,listr|||list line|19617
||brn|6,cnc08|||merge|19618
||ejc|||||19619
|cnc17|mnz|3,cswer|||set switch|19625
||brn|6,cnc08|||merge|19626
|cnc18|mnz|3,cswex|||set switch|19630
||brn|6,cnc08|||merge|19631
|cnc19|zer|3,cswfl|||clear switch|19635
||brn|6,cnc08|||merge|19636
|cnc20|zer|3,cswls|||clear switch|19640
||brn|6,cnc08|||merge|19641
|cnc21|mnz|3,cswno|||set switch|19645
||brn|6,cnc08|||merge|19646
|cnc22|zer|3,cswpr|||clear switch|19650
||brn|6,cnc08|||merge|19651
|cnc24|zer|3,cswno|||clear switch|19655
||brn|6,cnc08|||merge|19656
|cnc25|mnz|3,cswpr|||set switch|19660
||brn|6,cnc08|||merge|19661
||ejc|||||19662
|cnc27|zer|3,cswdb|||clear switch|19668
||brn|6,cnc08|||merge|19669
|cnc28|bze|3,cswls|6,cnc09||return if -nolist|19673
||jsr|6,scane|||scan integer after -space|19674
||mov|8,wc|18,=num01||1 space in case|19675
||beq|7,xr|18,=t_smc|6,cnc29|jump if no integer|19676
||mov|11,-(xs)|7,xr||stack it|19677
||jsr|6,gtsmi|||check integer|19678
||ppm|6,cnc06|||fail if not integer|19679
||ppm|6,cnc06|||fail if negative or large|19680
||bnz|8,wc|6,cnc29||jump if non zero|19681
||mov|8,wc|18,=num01||else 1 space|19682
|cnc29|add|3,lstlc|8,wc||bump line count|19686
||lct|8,wc|8,wc||convert to loop counter|19687
||blt|3,lstlc|3,lstnp|6,cnc30|jump if fits on page|19688
||jsr|6,prtps|||eject|19689
||jsr|6,listt|||list title|19690
||brn|6,cnc09|||merge|19691
|cnc30|jsr|6,prtnl|||print a blank|19695
||bct|8,wc|6,cnc30||loop|19696
||brn|6,cnc09|||merge|19697
||ejc|||||19698
|cnc31|mov|3,cnr_t|20,=r_stl||ptr to r_stl|19704
||brn|6,cnc33|||merge|19705
|cnc32|mov|3,r_stl|21,=nulls||clear subtitle|19709
||mov|3,cnr_t|20,=r_ttl||ptr to r_ttl|19710
|cnc33|mov|7,xr|21,=nulls||null in case needed|19714
||mnz|3,cnttl|||set flag for next listr call|19715
||mov|8,wb|18,=ccofs||offset to title/subtitle|19716
||mov|8,wa|3,scnil||input image length|19717
||blo|8,wa|8,wb|6,cnc34|jump if no chars left|19718
||sub|8,wa|8,wb||no of chars to extract|19719
||mov|7,xl|3,r_cim||point to image|19720
||jsr|6,sbstr|||get title/subtitle|19721
|cnc34|mov|7,xl|3,cnr_t||point to storage location|19725
||mov|9,(xl)|7,xr||store title/subtitle|19726
||beq|7,xl|20,=r_stl|6,cnc09|return if stitl|19727
||bnz|3,precl|6,cnc09||return if extended listing|19728
||bze|3,prich|6,cnc09||return if regular printer|19729
||mov|7,xl|13,sclen(xr)||get length of title|19730
||mov|8,wa|7,xl||copy it|19731
||bze|7,xl|6,cnc35||jump if null|19732
||add|7,xl|18,=num10||increment|19733
||bhi|7,xl|3,prlen|6,cnc09|use default lstp0 val if too long|19734
||add|8,wa|18,=num04||point just past title|19735
|cnc35|mov|3,lstpo|8,wa||store offset|19739
||brn|6,cnc09|||return|19740
|cnc36|jsr|6,systt|||toggle switch|19746
||brn|6,cnc08|||merge|19747
|cnc41|mnz|3,scncc|||set flag for scane|19785
||jsr|6,scane|||scan quoted file name|19786
||zer|3,scncc|||clear scane flag|19787
||bne|7,xl|18,=t_con|6,cnc06|if not constant|19788
||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19789
||mov|3,r_ifn|7,xr||save file name|19790
||mov|7,xl|3,r_inc||examine include file name table|19791
||zer|8,wb|||lookup by value|19792
||jsr|6,tfind|||do lookup|19793
||ppm||||never fails|19794
||beq|7,xr|21,=inton|6,cnc09|ignore if already in table|19795
||mnz|8,wb|||set for trim|19796
||mov|7,xr|3,r_ifn||file name|19797
||jsr|6,trimr|||remove trailing blanks|19798
||mov|7,xl|3,r_inc||include file name table|19799
||mnz|8,wb|||lookup by name this time|19800
||jsr|6,tfind|||do lookup|19801
||ppm||||never fails|19802
||mov|13,teval(xl)|21,=inton||make table value integer 1|19803
||icv|3,cnind|||increase nesting level|19804
||mov|8,wa|3,cnind||load new nest level|19805
||bgt|8,wa|18,=ccinm|6,cnc42|fail if excessive nesting|19806
||mov|7,xl|3,r_ifa||array of nested file names|19811
||add|8,wa|18,=vcvlb||compute offset in words|19812
||wtb|8,wa|||convert to bytes|19813
||add|7,xl|8,wa||point to element|19814
||mov|9,(xl)|3,r_sfc||record current file name|19815
||mov|7,xl|8,wa||preserve nesting byte offset|19816
||mti|3,rdnln|||fetch source line number as integer|19817
||jsr|6,icbld|||convert to icblk|19818
||add|7,xl|3,r_ifl||entry in nested line number array|19819
||mov|9,(xl)|7,xr||record in array|19820
||mov|8,wa|3,cswin||max read length|19825
||mov|7,xl|3,r_ifn||include file name|19826
||jsr|6,alocs|||get buffer for complete file name|19827
||jsr|6,sysif|||open include file|19828
||ppm|6,cnc43|||could not open|19829
||zer|8,wb|||do not trim trailing blanks|19834
||jsr|6,trimr|||adjust scblk for actual length|19835
||mov|3,r_sfc|7,xr||save ptr to file name|19836
||mti|3,cmpsn|||current statement as integer|19837
||jsr|6,icbld|||build icblk for stmt number|19838
||mov|7,xl|3,r_sfn||file name table|19839
||mnz|8,wb|||lookup statement number by name|19840
||jsr|6,tfind|||allocate new teblk|19841
||ppm||||always possible to allocate block|19842
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|19843
||zer|3,rdnln|||restart line counter for new file|19847
||beq|3,stage|18,=stgic|6,cnc09|if initial compile|19848
||bne|3,cnind|18,=num01|6,cnc09|if not first execute-time nesting|19849
||mov|3,r_ici|3,r_cim||remember code argument string|19853
||mov|3,cnspt|3,scnpt||save position in string|19854
||mov|3,cnsil|3,scnil||and length of string|19855
||brn|6,cnc09|||all done, merge|19856
|cnc42|erb|1,284|26,excessively nested include files|||19860
|cnc43|mov|3,dnamp|7,xr||release allocated scblk|19864
||erb|1,285|26,include file cannot be opened|||19865
|cnc44|jsr|6,scane|||scan integer after -line|19872
||bne|7,xl|18,=t_con|6,cnc06|jump if no line number|19873
||bne|9,(xr)|22,=b_icl|6,cnc06|jump if not integer|19874
||ldi|13,icval(xr)|||fetch integer line number|19875
||ile|6,cnc06|||error if negative or zero|19876
||beq|3,stage|18,=stgic|6,cnc45|skip if initial compile|19877
||mfi|3,cmpln|||set directly for other compiles|19878
||brn|6,cnc46|||no need to set rdnln|19879
|cnc45|sbi|4,intv1|||adjust number by one|19880
||mfi|3,rdnln|||save line number|19881
|cnc46|mnz|3,scncc|||set flag for scane|19883
||jsr|6,scane|||scan quoted file name|19884
||zer|3,scncc|||clear scane flag|19885
||beq|7,xl|18,=t_smc|6,cnc47|done if no file name|19886
||bne|7,xl|18,=t_con|6,cnc06|error if not constant|19887
||bne|9,(xr)|22,=b_scl|6,cnc06|if not string constant|19888
||jsr|6,newfn|||record new file name|19889
||brn|6,cnc09|||merge|19890
|cnc47|dcv|3,scnpt|||set to rescan the terminator|19894
||brn|6,cnc09|||merge|19895
||enp||||end procedure cncrd|19900
||ejc|||||19901
|dffnc|prc|25,e|1,0||entry point|19983
||bne|9,(xl)|22,=b_efc|6,dffn1|skip if new function not external|19986
||icv|13,efuse(xl)|||else increment its use count|19987
|dffn1|mov|8,wa|7,xr||save vrblk pointer|19991
||mov|7,xr|13,vrfnc(xr)||load old function pointer|19992
||bne|9,(xr)|22,=b_efc|6,dffn2|jump if old function not external|19993
||mov|8,wb|13,efuse(xr)||else get use count|19994
||dcv|8,wb|||decrement|19995
||mov|13,efuse(xr)|8,wb||store decremented value|19996
||bnz|8,wb|6,dffn2||jump if use count still non-zero|19997
||jsr|6,sysul|||else call system unload function|19998
|dffn2|mov|7,xr|8,wa||restore vrblk pointer|20002
||mov|8,wa|7,xl||copy function block ptr|20004
||blt|7,xr|20,=r_yyy|6,dffn3|skip checks if opsyn op definition|20005
||bnz|13,vrlen(xr)|6,dffn3||jump if not system variable|20006
||mov|7,xl|13,vrsvp(xr)||point to svblk|20010
||mov|8,wb|13,svbit(xl)||load bit indicators|20011
||anb|8,wb|4,btfnc||is it a system function|20012
||zrb|8,wb|6,dffn3||redef ok if not|20013
||erb|1,248|26,attempted redefinition of system function|||20014
|dffn3|mov|13,vrfnc(xr)|8,wa||store new function pointer|20018
||mov|7,xl|8,wa||restore function block pointer|20019
||exi||||return to dffnc caller|20020
||enp||||end procedure dffnc|20021
||ejc|||||20022
|dtach|prc|25,e|1,0||entry point|20036
||mov|3,dtcnb|7,xl||store name base (gbcol not called)|20037
||add|7,xl|8,wa||point to name location|20038
||mov|3,dtcnm|7,xl||store it|20039
|dtch1|mov|7,xr|7,xl||copy name pointer|20043
|dtch2|mov|7,xl|9,(xl)||point to next value|20047
||bne|9,(xl)|22,=b_trt|6,dtch6|jump at chain end|20048
||mov|8,wa|13,trtyp(xl)||get trap block type|20049
||beq|8,wa|18,=trtin|6,dtch3|jump if input|20050
||beq|8,wa|18,=trtou|6,dtch3|jump if output|20051
||add|7,xl|19,*trnxt||point to next link|20052
||brn|6,dtch1|||loop|20053
|dtch3|mov|9,(xr)|13,trval(xl)||delete trblk|20057
||mov|8,wa|7,xl||dump xl ...|20058
||mov|8,wb|7,xr||... and xr|20059
||mov|7,xl|13,trtrf(xl)||point to trtrf trap block|20060
||bze|7,xl|6,dtch5||jump if no iochn|20061
||bne|9,(xl)|22,=b_trt|6,dtch5|jump if input, output, terminal|20062
|dtch4|mov|7,xr|7,xl||remember link ptr|20066
||mov|7,xl|13,trtrf(xl)||point to next link|20067
||bze|7,xl|6,dtch5||jump if end of chain|20068
||mov|8,wc|13,ionmb(xl)||get name base|20069
||add|8,wc|13,ionmo(xl)||add offset|20070
||bne|8,wc|3,dtcnm|6,dtch4|loop if no match|20071
||mov|13,trtrf(xr)|13,trtrf(xl)||remove name from chain|20072
||ejc|||||20073
|dtch5|mov|7,xl|8,wa||recover xl ...|20079
||mov|7,xr|8,wb||... and xr|20080
||add|7,xl|19,*trval||point to value field|20081
||brn|6,dtch2|||continue|20082
|dtch6|mov|7,xr|3,dtcnb||possible vrblk ptr|20086
||jsr|6,setvr|||reset vrblk if necessary|20087
||exi||||return|20088
||enp||||end procedure dtach|20089
||ejc|||||20090
|dtype|prc|25,e|1,0||entry point|20098
||beq|9,(xr)|22,=b_pdt|6,dtyp1|jump if prog.defined|20099
||mov|7,xr|9,(xr)||load type word|20100
||lei|7,xr|||get entry point id (block code)|20101
||wtb|7,xr|||convert to byte offset|20102
||mov|7,xr|14,scnmt(xr)||load table entry|20103
||exi||||exit to dtype caller|20104
|dtyp1|mov|7,xr|13,pddfp(xr)||point to dfblk|20108
||mov|7,xr|13,dfnam(xr)||get datatype name from dfblk|20109
||exi||||return to dtype caller|20110
||enp||||end procedure dtype|20111
||ejc|||||20112
|dumpr|prc|25,e|1,0||entry point|20133
||bze|7,xr|6,dmp28||skip dump if argument is zero|20134
||bgt|7,xr|18,=num03|6,dmp29|jump if core dump required|20135
||zer|7,xl|||clear xl|20136
||zer|8,wb|||zero move offset|20137
||mov|3,dmarg|7,xr||save dump argument|20138
||zer|3,dnams|||collect sediment too|20140
||jsr|6,gbcol|||collect garbage|20142
||jsr|6,prtpg|||eject printer|20143
||mov|7,xr|21,=dmhdv||point to heading for variables|20144
||jsr|6,prtst|||print it|20145
||jsr|6,prtnl|||terminate print line|20146
||jsr|6,prtnl|||and print a blank line|20147
||zer|3,dmvch|||set null chain to start|20160
||mov|8,wa|3,hshtb||point to hash table|20161
|dmp00|mov|7,xr|8,wa||copy hash bucket pointer|20165
||ica|8,wa|||bump pointer|20166
||sub|7,xr|19,*vrnxt||set offset to merge|20167
|dmp01|mov|7,xr|13,vrnxt(xr)||point to next vrblk on chain|20171
||bze|7,xr|6,dmp09||jump if end of this hash chain|20172
||mov|7,xl|7,xr||else copy vrblk pointer|20173
||ejc|||||20174
|dmp02|mov|7,xl|13,vrval(xl)||load value|20180
||beq|3,dmarg|18,=num03|6,dmp2a|skip null value check if dump(3)|20181
||beq|7,xl|21,=nulls|6,dmp01|loop for next vrblk if null value|20182
|dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|loop back if value is trapped|20183
||mov|8,wc|7,xr||save vrblk pointer|20187
||add|7,xr|19,*vrsof||adjust ptr to be like scblk ptr|20188
||bnz|13,sclen(xr)|6,dmp03||jump if non-system variable|20189
||mov|7,xr|13,vrsvo(xr)||else load ptr to name in svblk|20190
|dmp03|mov|8,wb|7,xr||save pointer to chars|20194
||mov|3,dmpsv|8,wa||save hash bucket pointer|20195
||mov|8,wa|20,=dmvch||point to chain head|20196
|dmp04|mov|3,dmpch|8,wa||save chain pointer|20200
||mov|7,xl|8,wa||copy it|20201
||mov|7,xr|9,(xl)||load pointer to next entry|20202
||bze|7,xr|6,dmp08||jump if end of chain to insert|20203
||add|7,xr|19,*vrsof||else get name ptr for chained vrblk|20204
||bnz|13,sclen(xr)|6,dmp05||jump if not system variable|20205
||mov|7,xr|13,vrsvo(xr)||else point to name in svblk|20206
|dmp05|mov|7,xl|8,wb||point to entering vrblk string|20216
||mov|8,wa|13,sclen(xl)||load its length|20217
||plc|7,xl|||point to chars of entering string|20218
||bhi|8,wa|13,sclen(xr)|6,dmp06|jump if entering length high|20241
||plc|7,xr|||else point to chars of old string|20242
||cmc|6,dmp08|6,dmp07||compare, insert if new is llt old|20243
||brn|6,dmp08|||or if leq (we had shorter length)|20244
|dmp06|mov|8,wa|13,sclen(xr)||load shorter length|20248
||plc|7,xr|||point to chars of old string|20249
||cmc|6,dmp08|6,dmp07||compare, insert if new one low|20250
||ejc|||||20251
|dmp07|mov|7,xl|3,dmpch||copy chain pointer|20257
||mov|8,wa|9,(xl)||move to next entry on chain|20259
||brn|6,dmp04|||loop back|20260
|dmp08|mov|7,xl|3,dmpch||copy chain pointer|20264
||mov|8,wa|3,dmpsv||restore hash bucket pointer|20265
||mov|7,xr|8,wc||restore vrblk pointer|20266
||mov|13,vrget(xr)|9,(xl)||link vrblk to rest of chain|20267
||mov|9,(xl)|7,xr||link vrblk into current chain loc|20268
||brn|6,dmp01|||loop back for next vrblk|20269
|dmp09|bne|8,wa|3,hshte|6,dmp00|loop back if more buckets to go|20273
|dmp10|mov|7,xr|3,dmvch||load pointer to next entry on chain|20277
||bze|7,xr|6,dmp11||jump if end of chain|20278
||mov|3,dmvch|9,(xr)||else update chain ptr to next entry|20279
||jsr|6,setvr|||restore vrget field|20280
||mov|7,xl|7,xr||copy vrblk pointer (name base)|20281
||mov|8,wa|19,*vrval||set offset for vrblk name|20282
||jsr|6,prtnv|||print name = value|20283
||brn|6,dmp10|||loop back till all printed|20284
|dmp11|jsr|6,prtnl|||print blank line|20288
||jsr|6,prtnl|||and another|20289
||mov|7,xr|21,=dmhdk||point to keyword heading|20290
||jsr|6,prtst|||print heading|20291
||jsr|6,prtnl|||end line|20292
||jsr|6,prtnl|||print one blank line|20293
||mov|7,xl|21,=vdmkw||point to list of keyword svblk ptrs|20294
||ejc|||||20295
|dmp12|mov|7,xr|10,(xl)+||load next svblk ptr from table|20301
||bze|7,xr|6,dmp13||jump if end of list|20302
||beq|7,xr|18,=num01|6,dmp12|&compare ignored if not implemented|20304
||mov|8,wa|18,=ch_am||load ampersand|20306
||jsr|6,prtch|||print ampersand|20307
||jsr|6,prtst|||print keyword name|20308
||mov|8,wa|13,svlen(xr)||load name length from svblk|20309
||ctb|8,wa|2,svchs||get length of name|20310
||add|7,xr|8,wa||point to svknm field|20311
||mov|3,dmpkn|9,(xr)||store in dummy kvblk|20312
||mov|7,xr|21,=tmbeb||point to blank-equal-blank|20313
||jsr|6,prtst|||print it|20314
||mov|3,dmpsv|7,xl||save table pointer|20315
||mov|7,xl|20,=dmpkb||point to dummy kvblk|20316
||mov|9,(xl)|22,=b_kvt||build type word|20317
||mov|13,kvvar(xl)|21,=trbkv||build ptr to dummy trace block|20318
||mov|8,wa|19,*kvvar||set zero offset|20319
||jsr|6,acess|||get keyword value|20320
||ppm||||failure is impossible|20321
||jsr|6,prtvl|||print keyword value|20322
||jsr|6,prtnl|||terminate print line|20323
||mov|7,xl|3,dmpsv||restore table pointer|20324
||brn|6,dmp12|||loop back till all printed|20325
|dmp13|beq|3,dmarg|18,=num01|6,dmp27|exit if partial dump complete|20329
||mov|7,xr|3,dnamb||else point to first dynamic block|20330
|dmp14|beq|7,xr|3,dnamp|6,dmp27|jump if end of used region|20334
||mov|8,wa|9,(xr)||else load first word of block|20335
||beq|8,wa|22,=b_vct|6,dmp16|jump if vector|20336
||beq|8,wa|22,=b_art|6,dmp17|jump if array|20337
||beq|8,wa|22,=b_pdt|6,dmp18|jump if program defined|20338
||beq|8,wa|22,=b_tbt|6,dmp19|jump if table|20339
|dmp15|jsr|6,blkln|||get length of block|20347
||add|7,xr|8,wa||point past this block|20348
||brn|6,dmp14|||loop back for next block|20349
||ejc|||||20350
|dmp16|mov|8,wb|19,*vcvls||set offset to first value|20356
||brn|6,dmp19|||jump to merge|20357
|dmp17|mov|8,wb|13,arofs(xr)||set offset to arpro field|20361
||ica|8,wb|||bump to get offset to values|20362
||brn|6,dmp19|||jump to merge|20363
|dmp18|mov|8,wb|19,*pdfld||point to values, merge|20367
|dmp19|bze|13,idval(xr)|6,dmp15||ignore block if zero id value|20371
||jsr|6,blkln|||else get block length|20372
||mov|7,xl|7,xr||copy block pointer|20373
||mov|3,dmpsv|8,wa||save length|20374
||mov|8,wa|8,wb||copy offset to first value|20375
||jsr|6,prtnl|||print blank line|20376
||mov|3,dmpsa|8,wa||preserve offset|20377
||jsr|6,prtvl|||print block value (for title)|20378
||mov|8,wa|3,dmpsa||recover offset|20379
||jsr|6,prtnl|||end print line|20380
||beq|9,(xr)|22,=b_tbt|6,dmp22|jump if table|20381
||dca|8,wa|||point before first word|20382
|dmp20|mov|7,xr|7,xl||copy block pointer|20386
||ica|8,wa|||bump offset|20387
||add|7,xr|8,wa||point to next value|20388
||beq|8,wa|3,dmpsv|6,dmp14|exit if end (xr past block)|20389
||sub|7,xr|19,*vrval||subtract offset to merge into loop|20390
|dmp21|mov|7,xr|13,vrval(xr)||load next value|20394
||beq|3,dmarg|18,=num03|6,dmp2b|skip null value check if dump(3)|20395
||beq|7,xr|21,=nulls|6,dmp20|loop back if null value|20396
|dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|loop back if trapped|20397
||jsr|6,prtnv|||else print name = value|20398
||brn|6,dmp20|||loop back for next field|20399
||ejc|||||20400
|dmp22|mov|8,wc|19,*tbbuk||set offset to first bucket|20406
||mov|8,wa|19,*teval||set name offset for all teblks|20407
|dmp23|mov|11,-(xs)|7,xl||save tbblk pointer|20411
||add|7,xl|8,wc||point to next bucket header|20412
||ica|8,wc|||bump bucket offset|20413
||sub|7,xl|19,*tenxt||subtract offset to merge into loop|20414
|dmp24|mov|7,xl|13,tenxt(xl)||point to next teblk|20418
||beq|7,xl|9,(xs)|6,dmp26|jump if end of chain|20419
||mov|7,xr|7,xl||else copy teblk pointer|20420
|dmp25|mov|7,xr|13,teval(xr)||load next value|20424
||beq|7,xr|21,=nulls|6,dmp24|ignore if null value|20425
||beq|9,(xr)|22,=b_trt|6,dmp25|loop back if trapped|20426
||mov|3,dmpsv|8,wc||else save offset pointer|20427
||jsr|6,prtnv|||print name = value|20428
||mov|8,wc|3,dmpsv||reload offset|20429
||brn|6,dmp24|||loop back for next teblk|20430
|dmp26|mov|7,xl|10,(xs)+||restore tbblk pointer|20434
||bne|8,wc|13,tblen(xl)|6,dmp23|loop back if more buckets to go|20435
||mov|7,xr|7,xl||else copy table pointer|20436
||add|7,xr|8,wc||point to following block|20437
||brn|6,dmp14|||loop back to process next block|20438
|dmp27|jsr|6,prtpg|||eject printer|20442
|dmp28|exi||||return to dump caller|20446
|dmp29|jsr|6,sysdm|||call it|20450
||brn|6,dmp28|||return|20451
||enp||||end procedure dumpr|20487
||ejc|||||20488
|ermsg|prc|25,e|1,0||entry point|20496
||mov|8,wa|3,kvert||load error code|20497
||mov|7,xr|21,=ermms||point to error message /error/|20498
||jsr|6,prtst|||print it|20499
||jsr|6,ertex|||get error message text|20500
||add|8,wa|18,=thsnd||bump error code for print|20501
||mti|8,wa|||fail code in int acc|20502
||mov|8,wb|3,profs||save current buffer position|20503
||jsr|6,prtin|||print code (now have error1xxx)|20504
||mov|7,xl|3,prbuf||point to print buffer|20505
||psc|7,xl|8,wb||point to the 1|20506
||mov|8,wa|18,=ch_bl||load a blank|20507
||sch|8,wa|9,(xl)||store blank over 1 (error xxx)|20508
||csc|7,xl|||complete store characters|20509
||zer|7,xl|||clear garbage pointer in xl|20510
||mov|8,wa|7,xr||keep error text|20511
||mov|7,xr|21,=ermns||point to / -- /|20512
||jsr|6,prtst|||print it|20513
||mov|7,xr|8,wa||get error text again|20514
||jsr|6,prtst|||print error message text|20515
||jsr|6,prtis|||print line|20516
||jsr|6,prtis|||print blank line|20517
||exi||||return to ermsg caller|20518
||enp||||end procedure ermsg|20519
||ejc|||||20520
|ertex|prc|25,e|1,0||entry point|20530
||mov|3,ertwa|8,wa||save wa|20531
||mov|3,ertwb|8,wb||save wb|20532
||jsr|6,sysem|||get failure message text|20533
||mov|7,xl|7,xr||copy pointer to it|20534
||mov|8,wa|13,sclen(xr)||get length of string|20535
||bze|8,wa|6,ert02||jump if null|20536
||zer|8,wb|||offset of zero|20537
||jsr|6,sbstr|||copy into dynamic store|20538
||mov|3,r_etx|7,xr||store for relocation|20539
|ert01|mov|8,wb|3,ertwb||restore wb|20543
||mov|8,wa|3,ertwa||restore wa|20544
||exi||||return to caller|20545
|ert02|mov|7,xr|3,r_etx||get errtext|20549
||brn|6,ert01|||return|20550
||enp|||||20551
||ejc|||||20552
|evali|prc|25,r|1,4||entry point (recursive)|20574
||jsr|6,evalp|||evaluate expression|20575
||ppm|6,evli1|||jump on failure|20576
||mov|11,-(xs)|7,xl||stack result for gtsmi|20577
||mov|7,xl|13,pthen(xr)||load successor pointer|20578
||mov|3,evlio|7,xr||save original node pointer|20579
||mov|3,evlif|8,wc||zero if simple argument|20580
||jsr|6,gtsmi|||convert arg to small integer|20581
||ppm|6,evli2|||jump if not integer|20582
||ppm|6,evli3|||jump if out of range|20583
||mov|3,evliv|7,xr||store result in special dummy node|20584
||mov|7,xr|20,=evlin||point to dummy node with result|20585
||mov|9,(xr)|22,=p_len||dummy pattern block pcode|20586
||mov|13,pthen(xr)|7,xl||store successor pointer|20587
||exi|1,4|||take successful exit|20588
|evli1|exi|1,3|||take failure return|20592
|evli2|exi|1,1|||take non-integer error exit|20596
|evli3|exi|1,2|||take out-of-range error exit|20600
||enp||||end procedure evali|20601
||ejc|||||20602
|evalp|prc|25,r|1,1||entry point (recursive)|20633
||mov|7,xl|13,parm1(xr)||load expression pointer|20634
||beq|9,(xl)|22,=b_exl|6,evlp1|jump if exblk case|20635
||mov|7,xl|13,sevar(xl)||load vrblk pointer|20642
||mov|7,xl|13,vrval(xl)||load value of vrblk|20643
||mov|8,wa|9,(xl)||load first word of value|20644
||bhi|8,wa|22,=b_t__|6,evlp3|jump if not seblk, trblk or exblk|20645
|evlp1|chk||||check for stack space|20649
||mov|11,-(xs)|7,xr||stack node pointer|20650
||mov|11,-(xs)|8,wb||stack cursor|20651
||mov|11,-(xs)|3,r_pms||stack subject string pointer|20652
||mov|11,-(xs)|3,pmssl||stack subject string length|20653
||mov|11,-(xs)|3,pmdfl||stack dot flag|20654
||mov|11,-(xs)|3,pmhbs||stack history stack base pointer|20655
||mov|7,xr|13,parm1(xr)||load expression pointer|20656
||ejc|||||20657
|evlp2|zer|8,wb|||set flag for by value|20663
||jsr|6,evalx|||evaluate expression|20664
||ppm|6,evlp4|||jump on failure|20665
||mov|8,wa|9,(xr)||else load first word of value|20666
||blo|8,wa|22,=b_e__|6,evlp2|loop back to reevaluate expression|20667
||mov|7,xl|7,xr||copy result pointer|20671
||mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20672
||mov|3,pmdfl|10,(xs)+||restore dot flag|20673
||mov|3,pmssl|10,(xs)+||restore subject string length|20674
||mov|3,r_pms|10,(xs)+||restore subject string pointer|20675
||mov|8,wb|10,(xs)+||restore cursor|20676
||mov|7,xr|10,(xs)+||restore node pointer|20677
||mov|8,wc|7,xr||non-zero for simple vrblk|20678
||exi||||return to evalp caller|20679
|evlp3|zer|8,wc|||simple vrblk, no side effects|20683
||exi||||return to evalp caller|20684
|evlp4|mov|3,pmhbs|10,(xs)+||restore history stack base pointer|20688
||mov|3,pmdfl|10,(xs)+||restore dot flag|20689
||mov|3,pmssl|10,(xs)+||restore subject string length|20690
||mov|3,r_pms|10,(xs)+||restore subject string pointer|20691
||add|7,xs|19,*num02||remove node ptr, cursor|20692
||exi|1,1|||take failure exit|20693
||enp||||end procedure evalp|20694
||ejc|||||20695
|evals|prc|25,r|1,3||entry point (recursive)|20717
||jsr|6,evalp|||evaluate expression|20718
||ppm|6,evls1|||jump if evaluation fails|20719
||mov|11,-(xs)|13,pthen(xr)||save successor pointer|20720
||mov|11,-(xs)|8,wb||save cursor|20721
||mov|11,-(xs)|7,xl||stack result ptr for patst|20722
||zer|8,wb|||dummy pcode for one char string|20723
||zer|8,wc|||dummy pcode for expression arg|20724
||mov|7,xl|22,=p_brk||appropriate pcode for our use|20725
||jsr|6,patst|||call routine to build node|20726
||ppm|6,evls2|||jump if not string|20727
||mov|8,wb|10,(xs)+||restore cursor|20728
||mov|13,pthen(xr)|10,(xs)+||store successor pointer|20729
||exi|1,3|||take success return|20730
|evls1|exi|1,2|||take failure return|20734
|evls2|add|7,xs|19,*num02||pop successor and cursor|20738
||exi|1,1|||take non-string error exit|20739
||enp||||end procedure evals|20740
||ejc|||||20741
|evalx|prc|25,r|1,1||entry point, recursive|20757
||beq|9,(xr)|22,=b_exl|6,evlx2|jump if exblk case|20758
||mov|7,xl|13,sevar(xr)||load vrblk pointer (name base)|20762
||mov|8,wa|19,*vrval||set name offset|20763
||bnz|8,wb|6,evlx1||jump if called by name|20764
||jsr|6,acess|||call routine to access value|20765
||ppm|6,evlx9|||jump if failure on access|20766
|evlx1|exi||||return to evalx caller|20770
||ejc|||||20771
|evlx2|scp|8,wc|||get code pointer|20790
||mov|8,wa|3,r_cod||load code block pointer|20791
||sub|8,wc|8,wa||get code pointer as offset|20792
||mov|11,-(xs)|8,wa||stack old code block pointer|20793
||mov|11,-(xs)|8,wc||stack relative code offset|20794
||mov|11,-(xs)|3,flptr||stack old failure pointer|20795
||mov|11,-(xs)|8,wb||stack name/value indicator|20796
||mov|11,-(xs)|19,*exflc||stack new fail offset|20797
||mov|3,gtcef|3,flptr||keep in case of error|20798
||mov|3,r_gtc|3,r_cod||keep code block pointer similarly|20799
||mov|3,flptr|7,xs||set new failure pointer|20800
||mov|3,r_cod|7,xr||set new code block pointer|20801
||mov|13,exstm(xr)|3,kvstn||remember stmnt number|20802
||add|7,xr|19,*excod||point to first code word|20803
||lcp|7,xr|||set code pointer|20804
||bne|3,stage|18,=stgxt|6,evlx0|jump if not execution time|20805
||mov|3,stage|18,=stgee||evaluating expression|20806
|evlx0|zer|7,xl|||clear garbage xl|20810
||lcw|7,xr|||load first code word|20811
||bri|9,(xr)|||execute it|20812
||ejc|||||20813
|evlx3|mov|7,xr|10,(xs)+||load value|20819
||bze|13,num01(xs)|6,evlx5||jump if called by value|20820
||erb|1,249|26,expression evaluated by name returned value|||20821
|evlx4|mov|8,wa|10,(xs)+||load name offset|20825
||mov|7,xl|10,(xs)+||load name base|20826
||bnz|13,num01(xs)|6,evlx5||jump if called by name|20827
||jsr|6,acess|||else access value first|20828
||ppm|6,evlx6|||jump if failure during access|20829
|evlx5|zer|8,wb|||note successful|20833
||brn|6,evlx7|||merge|20834
|evlx6|mnz|8,wb|||note unsuccessful|20838
|evlx7|bne|3,stage|18,=stgee|6,evlx8|skip if was not previously xt|20842
||mov|3,stage|18,=stgxt||execute time|20843
|evlx8|add|7,xs|19,*num02||pop name/value indicator, *exfal|20847
||mov|3,flptr|10,(xs)+||restore old failure pointer|20848
||mov|8,wc|10,(xs)+||load code offset|20849
||add|8,wc|9,(xs)||make code pointer absolute|20850
||mov|3,r_cod|10,(xs)+||restore old code block pointer|20851
||lcp|8,wc|||restore old code pointer|20852
||bze|8,wb|6,evlx1||jump for successful return|20853
|evlx9|exi|1,1|||take failure exit|20857
||enp||||end of procedure evalx|20858
||ejc|||||20859
|exbld|prc|25,e|1,0||entry point|20872
||mov|8,wa|7,xl||copy offset to start of code|20873
||sub|8,wa|19,*excod||calc reduction in offset in exblk|20874
||mov|11,-(xs)|8,wa||stack for later|20875
||mov|8,wa|3,cwcof||load final offset|20876
||sub|8,wa|7,xl||compute length of code|20877
||add|8,wa|19,*exsi_||add space for standard fields|20878
||jsr|6,alloc|||allocate space for exblk|20879
||mov|11,-(xs)|7,xr||save pointer to exblk|20880
||mov|13,extyp(xr)|22,=b_exl||store type word|20881
||zer|13,exstm(xr)|||zeroise stmnt number field|20882
||mov|13,exsln(xr)|3,cmpln||set line number field|20884
||mov|13,exlen(xr)|8,wa||store length|20886
||mov|13,exflc(xr)|21,=ofex_||store failure word|20887
||add|7,xr|19,*exsi_||set xr for mvw|20888
||mov|3,cwcof|7,xl||reset offset to start of code|20889
||add|7,xl|3,r_ccb||point to start of code|20890
||sub|8,wa|19,*exsi_||length of code to move|20891
||mov|11,-(xs)|8,wa||stack length of code|20892
||mvw||||move code to exblk|20893
||mov|8,wa|10,(xs)+||get length of code|20894
||btw|8,wa|||convert byte count to word count|20895
||lct|8,wa|8,wa||prepare counter for loop|20896
||mov|7,xl|9,(xs)||copy exblk ptr, dont unstack|20897
||add|7,xl|19,*excod||point to code itself|20898
||mov|8,wb|13,num01(xs)||get reduction in offset|20899
|exbl1|mov|7,xr|10,(xl)+||get next code word|20906
||beq|7,xr|21,=osla_|6,exbl3|jump if selection found|20907
||beq|7,xr|21,=onta_|6,exbl3|jump if negation found|20908
||bct|8,wa|6,exbl1||loop to end of code|20909
|exbl2|mov|7,xr|10,(xs)+||pop exblk ptr into xr|20913
||mov|7,xl|10,(xs)+||pop reduction constant|20914
||exi||||return to caller|20915
||ejc|||||20916
|exbl3|sub|10,(xl)+|8,wb||adjust offset|20925
||bct|8,wa|6,exbl4||decrement count|20926
|exbl4|bct|8,wa|6,exbl5||decrement count|20928
|exbl5|mov|7,xr|10,(xl)+||get next code word|20932
||beq|7,xr|21,=osla_|6,exbl3|jump if offset found|20933
||beq|7,xr|21,=oslb_|6,exbl3|jump if offset found|20934
||beq|7,xr|21,=oslc_|6,exbl3|jump if offset found|20935
||beq|7,xr|21,=onta_|6,exbl3|jump if offset found|20936
||bct|8,wa|6,exbl5||loop|20937
||brn|6,exbl2|||merge to return|20938
||enp||||end procedure exbld|20939
||ejc|||||20940
||ejc|||||20993
|expan|prc|25,e|1,0||entry point|20999
||zer|11,-(xs)|||set top of stack indicator|21000
||zer|8,wa|||set initial state to zero|21001
||zer|8,wc|||zero counter value|21002
|exp01|jsr|6,scane|||scan next element|21006
||add|7,xl|8,wa||add state to syntax code|21007
||bsw|7,xl|2,t_nes||switch on element type/state|21008
||iff|2,t_uo0|6,exp27||unop, s=0|21045
||iff|2,t_uo1|6,exp27||unop, s=1|21045
||iff|2,t_uo2|6,exp04||unop, s=2|21045
||iff|2,t_lp0|6,exp06||left paren, s=0|21045
||iff|2,t_lp1|6,exp06||left paren, s=1|21045
||iff|2,t_lp2|6,exp04||left paren, s=2|21045
||iff|2,t_lb0|6,exp08||left brkt, s=0|21045
||iff|2,t_lb1|6,exp08||left brkt, s=1|21045
||iff|2,t_lb2|6,exp09||left brkt, s=2|21045
||iff|2,t_cm0|6,exp02||comma, s=0|21045
||iff|2,t_cm1|6,exp05||comma, s=1|21045
||iff|2,t_cm2|6,exp11||comma, s=2|21045
||iff|2,t_fn0|6,exp10||function, s=0|21045
||iff|2,t_fn1|6,exp10||function, s=1|21045
||iff|2,t_fn2|6,exp04||function, s=2|21045
||iff|2,t_va0|6,exp03||variable, s=0|21045
||iff|2,t_va1|6,exp03||variable, state one|21045
||iff|2,t_va2|6,exp04||variable, s=2|21045
||iff|2,t_co0|6,exp03||constant, s=0|21045
||iff|2,t_co1|6,exp03||constant, s=1|21045
||iff|2,t_co2|6,exp04||constant, s=2|21045
||iff|2,t_bo0|6,exp05||binop, s=0|21045
||iff|2,t_bo1|6,exp05||binop, s=1|21045
||iff|2,t_bo2|6,exp26||binop, s=2|21045
||iff|2,t_rp0|6,exp02||right paren, s=0|21045
||iff|2,t_rp1|6,exp05||right paren, s=1|21045
||iff|2,t_rp2|6,exp12||right paren, s=2|21045
||iff|2,t_rb0|6,exp02||right brkt, s=0|21045
||iff|2,t_rb1|6,exp05||right brkt, s=1|21045
||iff|2,t_rb2|6,exp18||right brkt, s=2|21045
||iff|2,t_cl0|6,exp02||colon, s=0|21045
||iff|2,t_cl1|6,exp05||colon, s=1|21045
||iff|2,t_cl2|6,exp19||colon, s=2|21045
||iff|2,t_sm0|6,exp02||semicolon, s=0|21045
||iff|2,t_sm1|6,exp05||semicolon, s=1|21045
||iff|2,t_sm2|6,exp19||semicolon, s=2|21045
||esw||||end switch on element type/state|21045
||ejc|||||21046
|exp02|mnz|3,scnrs|||set to rescan element|21055
||mov|7,xr|21,=nulls||point to null, merge|21056
|exp03|mov|11,-(xs)|7,xr||stack pointer to operand|21062
||mov|8,wa|18,=num02||set state 2|21063
||brn|6,exp01|||jump for next element|21064
|exp04|mnz|3,scnrs|||set to rescan element|21071
||mov|7,xr|21,=opdvc||point to concat operator dv|21072
||bze|8,wb|6,exp4a||ok if at top level|21073
||mov|7,xr|21,=opdvp||else point to unmistakable concat.|21074
|exp4a|bnz|3,scnbl|6,exp26||merge bop if blanks, else error|21078
||erb|1,220|26,syntax error: missing operator|||21080
|exp05|erb|1,221|26,syntax error: missing operand|||21088
|exp06|mov|7,xl|18,=num04||set new level indicator|21092
||zer|7,xr|||set zero value for cmopn|21093
||ejc|||||21094
|exp07|mov|11,-(xs)|7,xr||stack cmopn value|21100
||mov|11,-(xs)|8,wc||stack old counter|21101
||mov|11,-(xs)|8,wb||stack old level indicator|21102
||chk||||check for stack overflow|21103
||zer|8,wa|||set new state to zero|21104
||mov|8,wb|7,xl||set new level indicator|21105
||mov|8,wc|18,=num01||initialize new counter|21106
||brn|6,exp01|||jump to scan next element|21107
|exp08|erb|1,222|26,syntax error: invalid use of left bracket|||21113
|exp09|mov|7,xr|10,(xs)+||load array ptr for cmopn|21119
||mov|7,xl|18,=num03||set new level indicator|21120
||brn|6,exp07|||jump to stack old and start new|21121
|exp10|mov|7,xl|18,=num05||set new lev indic (xr=vrblk=cmopn)|21127
||brn|6,exp07|||jump to stack old and start new|21128
|exp11|icv|8,wc|||increment counter|21134
||jsr|6,expdm|||dump operators at this level|21135
||zer|11,-(xs)|||set new level for parameter|21136
||zer|8,wa|||set new state|21137
||bgt|8,wb|18,=num02|6,exp01|loop back unless outer level|21138
||erb|1,223|26,syntax error: invalid use of comma|||21139
||ejc|||||21140
|exp12|beq|8,wb|18,=num01|6,exp20|end of normal goto|21149
||beq|8,wb|18,=num05|6,exp13|end of function arguments|21150
||beq|8,wb|18,=num04|6,exp14|end of grouping / selection|21151
||erb|1,224|26,syntax error: unbalanced right parenthesis|||21152
|exp13|mov|7,xl|18,=c_fnc||set cmtyp value for function|21156
||brn|6,exp15|||jump to build cmblk|21157
|exp14|beq|8,wc|18,=num01|6,exp17|jump if end of grouping|21161
||mov|7,xl|18,=c_sel||else set cmtyp for selection|21162
|exp15|jsr|6,expdm|||dump operators at this level|21167
||mov|8,wa|8,wc||copy count|21168
||add|8,wa|18,=cmvls||add for standard fields at start|21169
||wtb|8,wa|||convert length to bytes|21170
||jsr|6,alloc|||allocate space for cmblk|21171
||mov|9,(xr)|22,=b_cmt||store type code for cmblk|21172
||mov|13,cmtyp(xr)|7,xl||store cmblk node type indicator|21173
||mov|13,cmlen(xr)|8,wa||store length|21174
||add|7,xr|8,wa||point past end of block|21175
||lct|8,wc|8,wc||set loop counter|21176
|exp16|mov|11,-(xr)|10,(xs)+||move one operand ptr from stack|21180
||mov|8,wb|10,(xs)+||pop to old level indicator|21181
||bct|8,wc|6,exp16||loop till all moved|21182
||ejc|||||21183
||sub|7,xr|19,*cmvls||point back to start of block|21189
||mov|8,wc|10,(xs)+||restore old counter|21190
||mov|13,cmopn(xr)|9,(xs)||store operand ptr in cmblk|21191
||mov|9,(xs)|7,xr||stack cmblk pointer|21192
||mov|8,wa|18,=num02||set new state|21193
||brn|6,exp01|||back for next element|21194
|exp17|jsr|6,expdm|||dump operators at this level|21198
||mov|7,xr|10,(xs)+||restore xr|21199
||mov|8,wb|10,(xs)+||restore outer level|21200
||mov|8,wc|10,(xs)+||restore outer count|21201
||mov|9,(xs)|7,xr||store opnd over unused cmopn val|21202
||mov|8,wa|18,=num02||set new state|21203
||brn|6,exp01|||back for next ele8ent|21204
|exp18|mov|7,xl|18,=c_arr||set cmtyp for array reference|21211
||beq|8,wb|18,=num03|6,exp15|jump to build cmblk if end arrayref|21212
||beq|8,wb|18,=num02|6,exp20|jump if end of direct goto|21213
||erb|1,225|26,syntax error: unbalanced right bracket|||21214
||ejc|||||21215
|exp19|mnz|3,scnrs|||rescan terminator|21223
||mov|7,xl|8,wb||copy level indicator|21224
||bsw|7,xl|1,6||switch on level indicator|21225
||iff|1,0|6,exp20||normal outer level|21232
||iff|1,1|6,exp22||fail if normal goto|21232
||iff|1,2|6,exp23||fail if direct goto|21232
||iff|1,3|6,exp24||fail array brackets|21232
||iff|1,4|6,exp21||fail if in grouping|21232
||iff|1,5|6,exp21||fail function args|21232
||esw||||end switch on level|21232
|exp20|jsr|6,expdm|||dump remaining operators|21236
||mov|7,xr|10,(xs)+||load tree pointer|21237
||ica|7,xs|||pop off bottom of stack marker|21238
||exi||||return to expan caller|21239
|exp21|erb|1,226|26,syntax error: missing right paren|||21243
|exp22|erb|1,227|26,syntax error: right paren missing from goto|||21247
|exp23|erb|1,228|26,syntax error: right bracket missing from goto|||21251
|exp24|erb|1,229|26,syntax error: missing right array bracket|||21255
||ejc|||||21256
|exp25|mov|3,expsv|7,xr|||21262
||jsr|6,expop|||pop one operator|21263
||mov|7,xr|3,expsv||restore op dv pointer and merge|21264
|exp26|mov|7,xl|13,num01(xs)||load operator dvptr from stack|21272
||ble|7,xl|18,=num05|6,exp27|jump if bottom of stack level|21273
||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|else pop if new prec is lo|21274
|exp27|mov|11,-(xs)|7,xr||stack operator dvptr on stack|21283
||chk||||check for stack overflow|21284
||mov|8,wa|18,=num01||set new state|21285
||bne|7,xr|21,=opdvs|6,exp01|back for next element unless =|21286
||zer|8,wa|||set state zero|21293
||brn|6,exp01|||jump for next element|21294
||enp||||end procedure expan|21295
||ejc|||||21296
|expap|prc|25,e|1,1||entry point|21315
||mov|11,-(xs)|7,xl||save xl|21316
||bne|9,(xr)|22,=b_cmt|6,expp2|no match if not complex|21317
||mov|8,wa|13,cmtyp(xr)||else load type code|21318
||beq|8,wa|18,=c_cnc|6,expp1|concatenation is a match|21319
||beq|8,wa|18,=c_pmt|6,expp1|binary question mark is a match|21320
||bne|8,wa|18,=c_alt|6,expp2|else not match unless alternation|21321
||mov|7,xl|13,cmlop(xr)||load left operand pointer|21325
||bne|9,(xl)|22,=b_cmt|6,expp2|not match if left opnd not complex|21326
||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|not match if left op not conc|21327
||mov|13,cmlop(xr)|13,cmrop(xl)||xr points to (b / c)|21328
||mov|13,cmrop(xl)|7,xr||set xl opnds to a, (b / c)|21329
||mov|7,xr|7,xl||point to this altered node|21330
|expp1|mov|7,xl|10,(xs)+||restore entry xl|21334
||exi||||give pattern match return|21335
|expp2|mov|7,xl|10,(xs)+||restore entry xl|21339
||exi|1,1|||give non-match return|21340
||enp||||end procedure expap|21341
||ejc|||||21342
|expdm|prc|25,n|1,0||entry point|21354
||mov|3,r_exs|7,xl||save xl value|21355
|exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|jump if stack bottom (saved level|21359
||jsr|6,expop|||else pop one operator|21360
||brn|6,exdm1|||and loop back|21361
|exdm2|mov|7,xl|3,r_exs||restore xl|21365
||zer|3,r_exs|||release save location|21366
||exi||||return to expdm caller|21367
||enp||||end procedure expdm|21368
||ejc|||||21369
|expop|prc|25,n|1,0||entry point|21384
||mov|7,xr|13,num01(xs)||load operator dv pointer|21385
||beq|13,dvlpr(xr)|18,=lluno|6,expo2|jump if unary|21386
||mov|8,wa|19,*cmbs_||set size of binary operator cmblk|21390
||jsr|6,alloc|||allocate space for cmblk|21391
||mov|13,cmrop(xr)|10,(xs)+||pop and store right operand ptr|21392
||mov|7,xl|10,(xs)+||pop and load operator dv ptr|21393
||mov|13,cmlop(xr)|9,(xs)||store left operand pointer|21394
|expo1|mov|9,(xr)|22,=b_cmt||store type code for cmblk|21398
||mov|13,cmtyp(xr)|13,dvtyp(xl)||store cmblk node type code|21399
||mov|13,cmopn(xr)|7,xl||store dvptr (=ptr to dac o_xxx)|21400
||mov|13,cmlen(xr)|8,wa||store cmblk length|21401
||mov|9,(xs)|7,xr||store resulting node ptr on stack|21402
||exi||||return to expop caller|21403
|expo2|mov|8,wa|19,*cmus_||set size of unary operator cmblk|21407
||jsr|6,alloc|||allocate space for cmblk|21408
||mov|13,cmrop(xr)|10,(xs)+||pop and store operand pointer|21409
||mov|7,xl|9,(xs)||load operator dv pointer|21410
||brn|6,expo1|||merge back to exit|21411
||enp||||end procedure expop|21412
||ejc|||||21413
|filnm|prc|25,e|1,0||entry point|21438
||mov|11,-(xs)|8,wb||preserve wb|21439
||bze|8,wc|6,filn3||return nulls if stno is zero|21440
||mov|7,xl|3,r_sfn||file name table|21441
||bze|7,xl|6,filn3||if no table|21442
||mov|8,wb|13,tbbuk(xl)||get bucket entry|21443
||beq|8,wb|3,r_sfn|6,filn3|jump if no teblks on chain|21444
||mov|11,-(xs)|7,xr||preserve xr|21445
||mov|7,xr|8,wb||previous block pointer|21446
||mov|11,-(xs)|8,wc||preserve stmt number|21447
|filn1|mov|7,xl|7,xr||next element to examine|21451
||mov|7,xr|13,tesub(xl)||load subscript value (an icblk)|21452
||ldi|13,icval(xr)|||load the statement number|21453
||mfi|8,wc|||convert to address constant|21454
||blt|9,(xs)|8,wc|6,filn2|compare arg with teblk stmt number|21455
||mov|8,wb|7,xl||save previous entry pointer|21459
||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|21460
||bne|7,xr|3,r_sfn|6,filn1|jump if there is one|21461
|filn2|mov|7,xl|8,wb||previous teblk|21465
||mov|7,xl|13,teval(xl)||get ptr to file name scblk|21466
||mov|8,wc|10,(xs)+||restore stmt number|21467
||mov|7,xr|10,(xs)+||restore xr|21468
||mov|8,wb|10,(xs)+||restore wb|21469
||exi|||||21470
|filn3|mov|8,wb|10,(xs)+||restore wb|21474
||mov|7,xl|21,=nulls||return null string|21475
||exi|||||21476
||enp|||||21477
||ejc|||||21478
||ejc|||||21580
||ejc|||||21634
||ejc|||||21678
||ejc|||||21716
|gbcol|prc|25,e|1,0||entry point|21720
||bnz|3,dmvch|6,gbc14||fail if in mid-dump|21722
||mnz|3,gbcfl|||note gbcol entered|21723
||mov|3,gbsva|8,wa||save entry wa|21724
||mov|3,gbsvb|8,wb||save entry wb|21725
||mov|3,gbsvc|8,wc||save entry wc|21726
||mov|11,-(xs)|7,xl||save entry xl|21727
||scp|8,wa|||get code pointer value|21728
||sub|8,wa|3,r_cod||make relative|21729
||lcp|8,wa|||and restore|21730
||bze|8,wb|6,gbc0a||check there is no move offset|21732
||zer|3,dnams|||collect sediment if must move it|21733
|gbc0a|mov|8,wa|3,dnamb||start of dynamic area|21734
||add|8,wa|3,dnams||size of sediment|21735
||mov|3,gbcsd|8,wa||first location past sediment|21736
||mnz|7,xr|||non-zero flags start of collection|21749
||mov|8,wa|3,dnamb||start of dynamic area|21750
||mov|8,wb|3,dnamp||next available location|21751
||mov|8,wc|3,dname||last available location + 1|21752
||jsr|6,sysgc|||inform of collection|21753
||mov|7,xr|7,xs||point to stack front|21758
||mov|7,xl|3,stbas||point past end of stack|21759
||bge|7,xl|7,xr|6,gbc00|ok if d-stack|21760
||mov|7,xr|7,xl||reverse if ...|21761
||mov|7,xl|7,xs||... u-stack|21762
|gbc00|jsr|6,gbcpf|||process pointers on stack|21766
||mov|7,xr|20,=r_aaa||point to start of relocatable locs|21770
||mov|7,xl|20,=r_yyy||point past end of relocatable locs|21771
||jsr|6,gbcpf|||process work fields|21772
||mov|8,wa|3,hshtb||point to first hash slot pointer|21776
|gbc01|mov|7,xl|8,wa||point to next slot|21780
||ica|8,wa|||bump bucket pointer|21781
||mov|3,gbcnm|8,wa||save bucket pointer|21782
||ejc|||||21783
|gbc02|mov|7,xr|9,(xl)||load ptr to next vrblk|21789
||bze|7,xr|6,gbc03||jump if end of chain|21790
||mov|7,xl|7,xr||else copy vrblk pointer|21791
||add|7,xr|19,*vrval||point to first reloc fld|21792
||add|7,xl|19,*vrnxt||point past last (and to link ptr)|21793
||jsr|6,gbcpf|||process reloc fields in vrblk|21794
||brn|6,gbc02|||loop back for next block|21795
|gbc03|mov|8,wa|3,gbcnm||restore bucket pointer|21799
||bne|8,wa|3,hshte|6,gbc01|loop back if more buckets to go|21800
||ejc|||||21801
||mov|7,xr|3,dnamb||point to first block|21830
||zer|8,wb|||accumulate size of dead blocks|21831
|gbc04|beq|7,xr|3,gbcsd|6,gbc4c|jump if end of sediment|21832
||mov|8,wa|9,(xr)||else get first word|21833
||bod|8,wa|6,gbc4b||jump if entry pointer (unused)|21835
||dcv|8,wa|||restore entry pointer|21836
||mov|9,(xr)|8,wa||restore first word|21842
||jsr|6,blkln|||get length of this block|21843
||add|7,xr|8,wa||bump actual pointer|21844
||brn|6,gbc04|||continue scan through sediment|21845
|gbc4b|jsr|6,blkln|||get length of this block|21849
||add|7,xr|8,wa||bump actual pointer|21850
||add|8,wb|8,wa||count size of unused blocks|21851
||brn|6,gbc04|||continue scan through sediment|21852
|gbc4c|mov|3,gbcsf|8,wb||size of sediment free space|21863
||mov|8,wc|7,xr||set as first eventual location|21867
||add|8,wc|3,gbsvb||add offset for eventual move up|21868
||zer|3,gbcnm|||clear initial forward pointer|21869
||mov|3,gbclm|20,=gbcnm||initialize ptr to last move block|21870
||mov|3,gbcns|7,xr||initialize first address|21871
|gbc05|beq|7,xr|3,dnamp|6,gbc07|jump if end of used region|21875
||mov|8,wa|9,(xr)||else get first word|21876
||bod|8,wa|6,gbc07||jump if entry pointer (unused)|21878
|gbc06|mov|7,xl|8,wa||copy pointer|21886
||mov|8,wa|9,(xl)||load forward pointer|21887
||mov|9,(xl)|8,wc||relocate reference|21888
||bev|8,wa|6,gbc06||loop back if not end of chain|21890
||ejc|||||21895
||mov|9,(xr)|8,wa||restore first word|21901
||jsr|6,blkln|||get length of this block|21902
||add|7,xr|8,wa||bump actual pointer|21903
||add|8,wc|8,wa||bump eventual pointer|21904
||brn|6,gbc05|||loop back for next block|21905
|gbc07|mov|8,wa|7,xr||copy pointer past last block|21909
||mov|7,xl|3,gbclm||point to previous move block|21910
||sub|8,wa|13,num01(xl)||subtract starting address|21911
||mov|13,num01(xl)|8,wa||store length of block to be moved|21912
|gbc08|beq|7,xr|3,dnamp|6,gbc10|jump if end of used region|21916
||mov|8,wa|9,(xr)||else load first word of next block|21917
||bev|8,wa|6,gbc09||jump if in use|21919
||jsr|6,blkln|||else get length of next block|21924
||add|7,xr|8,wa||push pointer|21925
||brn|6,gbc08|||and loop back|21926
|gbc09|sub|7,xr|19,*num02||point 2 words behind for move block|21931
||mov|7,xl|3,gbclm||point to previous move block|21932
||mov|9,(xl)|7,xr||set forward ptr in previous block|21933
||zer|9,(xr)|||zero forward ptr of new block|21934
||mov|3,gbclm|7,xr||remember address of this block|21935
||mov|7,xl|7,xr||copy ptr to move block|21936
||add|7,xr|19,*num02||point back to block in use|21937
||mov|13,num01(xl)|7,xr||store starting address|21938
||brn|6,gbc06|||jump to process block in use|21939
||ejc|||||21940
|gbc10|mov|7,xr|3,gbcsd||point to storage above sediment|21950
||add|7,xr|3,gbcns||bump past unmoved blocks at start|21954
|gbc11|mov|7,xl|3,gbcnm||point to next move block|21958
||bze|7,xl|6,gbc12||jump if end of chain|21959
||mov|3,gbcnm|10,(xl)+||move pointer down chain|21960
||mov|8,wa|10,(xl)+||get length to move|21961
||mvw||||perform move|21962
||brn|6,gbc11|||loop back|21963
|gbc12|mov|3,dnamp|7,xr||set next available loc ptr|21967
||mov|8,wb|3,gbsvb||reload move offset|21968
||bze|8,wb|6,gbc13||jump if no move required|21969
||mov|7,xl|7,xr||else copy old top of core|21970
||add|7,xr|8,wb||point to new top of core|21971
||mov|3,dnamp|7,xr||save new top of core pointer|21972
||mov|8,wa|7,xl||copy old top|21973
||sub|8,wa|3,dnamb||minus old bottom = length|21974
||add|3,dnamb|8,wb||bump bottom to get new value|21975
||mwb||||perform move (backwards)|21976
|gbc13|zer|7,xr|||clear garbage value in xr|21980
||mov|3,gbcfl|7,xr||note exit from gbcol|21981
||mov|8,wa|3,dnamb||start of dynamic area|21983
||mov|8,wb|3,dnamp||next available location|21984
||mov|8,wc|3,dname||last available location + 1|21985
||jsr|6,sysgc|||inform sysgc of completion|21986
||sti|3,gbcia|||save ia|21994
||zer|7,xr|||presume no sediment will remain|21995
||mov|8,wb|3,gbcsf||free space in sediment|21996
||btw|8,wb|||convert bytes to words|21997
||mti|8,wb|||put sediment free store in ia|21998
||mli|3,gbsed|||multiply by sediment factor|21999
||iov|6,gb13a|||jump if overflowed|22000
||mov|8,wb|3,dnamp||end of dynamic area in use|22001
||sub|8,wb|3,dnamb||minus start is sediment remaining|22002
||btw|8,wb|||convert to words|22003
||mov|3,gbcsf|8,wb||store it|22004
||sbi|3,gbcsf|||subtract from scaled up free store|22005
||igt|6,gb13a|||jump if large free store in sedimnt|22006
||mov|7,xr|3,dnamp||below threshold, return sediment|22007
||sub|7,xr|3,dnamb||for use by caller|22008
|gb13a|ldi|3,gbcia|||restore ia|22009
||mov|8,wa|3,gbsva||restore wa|22011
||mov|8,wb|3,gbsvb||restore wb|22012
||scp|8,wc|||get code pointer|22013
||add|8,wc|3,r_cod||make absolute again|22014
||lcp|8,wc|||and replace absolute value|22015
||mov|8,wc|3,gbsvc||restore wc|22016
||mov|7,xl|10,(xs)+||restore entry xl|22017
||icv|3,gbcnt|||increment count of collections|22018
||exi||||exit to gbcol caller|22019
|gbc14|icv|3,errft|||fatal error|22023
||erb|1,250|26,insufficient memory to complete dump|||22024
||enp||||end procedure gbcol|22025
||ejc|||||22026
|gbcpf|prc|25,e|1,0||entry point|22041
||zer|11,-(xs)|||set zero to mark bottom of stack|22042
||mov|11,-(xs)|7,xl||save end pointer|22043
|gpf01|mov|7,xl|9,(xr)||load field contents|22053
||mov|8,wc|7,xr||save field pointer|22054
||blt|7,xl|3,dnamb|6,gpf2a|jump if not ptr into dynamic area|22058
||bge|7,xl|3,dnamp|6,gpf2a|jump if not ptr into dynamic area|22059
||mov|8,wa|9,(xl)||load ptr to chain (or entry ptr)|22064
||blt|7,xl|3,gbcsd|6,gpf1a|do not chain if within sediment|22066
||mov|9,(xl)|7,xr||set this field as new head of chain|22068
||mov|9,(xr)|8,wa||set forward pointer|22069
|gpf1a|bod|8,wa|6,gpf03||jump if not already processed|22074
|gpf02|mov|7,xr|8,wc||restore field pointer|22082
|gpf2a|ica|7,xr|||bump to next field|22086
||bne|7,xr|9,(xs)|6,gpf01|loop back if more to go|22087
||ejc|||||22088
||mov|7,xl|10,(xs)+||restore pointer past end|22094
||mov|7,xr|10,(xs)+||restore block pointer|22095
||bnz|7,xr|6,gpf2a||continue loop unless outer levl|22096
||exi||||return to caller if outer level|22097
|gpf03|bge|7,xl|3,gbcsd|6,gpf3a|if not within sediment|22110
||icv|9,(xl)|||mark by making entry point even|22112
|gpf3a|mov|7,xr|7,xl||copy block pointer|22116
||mov|7,xl|8,wa||copy first word of block|22120
||lei|7,xl|||load entry point id (bl_xx)|22121
||bsw|7,xl|2,bl___||switch on block type|22126
||iff|2,bl_ar|6,gpf06||arblk|22164
||iff|2,bl_cd|6,gpf19||cdblk|22164
||iff|2,bl_ex|6,gpf17||exblk|22164
||iff|2,bl_ic|6,gpf02||icblk|22164
||iff|2,bl_nm|6,gpf10||nmblk|22164
||iff|2,bl_p0|6,gpf10||p0blk|22164
||iff|2,bl_p1|6,gpf12||p1blk|22164
||iff|2,bl_p2|6,gpf12||p2blk|22164
||iff|2,bl_rc|6,gpf02||rcblk|22164
||iff|2,bl_sc|6,gpf02||scblk|22164
||iff|2,bl_se|6,gpf02||seblk|22164
||iff|2,bl_tb|6,gpf08||tbblk|22164
||iff|2,bl_vc|6,gpf08||vcblk|22164
||iff|2,bl_xn|6,gpf02||xnblk|22164
||iff|2,bl_xr|6,gpf09||xrblk|22164
||iff|2,bl_bc|6,gpf02||bcblk - dummy to fill out iffs|22164
||iff|2,bl_pd|6,gpf13||pdblk|22164
||iff|2,bl_tr|6,gpf16||trblk|22164
||iff|2,bl_bf|6,gpf02||bfblk|22164
||iff|2,bl_cc|6,gpf07||ccblk|22164
||iff|2,bl_cm|6,gpf04||cmblk|22164
||iff|2,bl_ct|6,gpf02||ctblk|22164
||iff|2,bl_df|6,gpf02||dfblk|22164
||iff|2,bl_ef|6,gpf02||efblk|22164
||iff|2,bl_ev|6,gpf10||evblk|22164
||iff|2,bl_ff|6,gpf11||ffblk|22164
||iff|2,bl_kv|6,gpf02||kvblk|22164
||iff|2,bl_pf|6,gpf14||pfblk|22164
||iff|2,bl_te|6,gpf15||teblk|22164
||esw||||end of jump table|22164
||ejc|||||22165
|gpf04|mov|8,wa|13,cmlen(xr)||load length|22171
||mov|8,wb|19,*cmtyp||set offset|22172
|gpf05|add|8,wa|7,xr||point past last reloc field|22181
||add|7,xr|8,wb||point to first reloc field|22182
||mov|11,-(xs)|8,wc||stack old field pointer|22183
||mov|11,-(xs)|8,wa||stack new limit pointer|22184
||chk||||check for stack overflow|22185
||brn|6,gpf01|||if ok, back to process|22186
|gpf06|mov|8,wa|13,arlen(xr)||load length|22190
||mov|8,wb|13,arofs(xr)||set offset to 1st reloc fld (arpro)|22191
||brn|6,gpf05|||all set|22192
|gpf07|mov|8,wa|13,ccuse(xr)||set length in use|22196
||mov|8,wb|19,*ccuse||1st word (make sure at least one)|22197
||brn|6,gpf05|||all set|22198
||ejc|||||22199
|gpf19|mov|8,wa|13,cdlen(xr)||load length|22206
||mov|8,wb|19,*cdfal||set offset|22207
||brn|6,gpf05|||jump back|22208
|gpf08|mov|8,wa|13,offs2(xr)||load length|22215
||mov|8,wb|19,*offs3||set offset|22216
||brn|6,gpf05|||jump back|22217
|gpf09|mov|8,wa|13,xrlen(xr)||load length|22221
||mov|8,wb|19,*xrptr||set offset|22222
||brn|6,gpf05|||jump back|22223
|gpf10|mov|8,wa|19,*offs2||point past second field|22227
||mov|8,wb|19,*offs1||offset is one (only reloc fld is 2)|22228
||brn|6,gpf05|||all set|22229
|gpf11|mov|8,wa|19,*ffofs||set length|22233
||mov|8,wb|19,*ffnxt||set offset|22234
||brn|6,gpf05|||all set|22235
|gpf12|mov|8,wa|19,*parm2||length (parm2 is non-relocatable)|22239
||mov|8,wb|19,*pthen||set offset|22240
||brn|6,gpf05|||all set|22241
||ejc|||||22242
|gpf13|mov|7,xl|13,pddfp(xr)||load ptr to dfblk|22248
||mov|8,wa|13,dfpdl(xl)||get pdblk length|22249
||mov|8,wb|19,*pdfld||set offset|22250
||brn|6,gpf05|||all set|22251
|gpf14|mov|8,wa|19,*pfarg||length past last reloc|22255
||mov|8,wb|19,*pfcod||offset to first reloc|22256
||brn|6,gpf05|||all set|22257
|gpf15|mov|8,wa|19,*tesi_||set length|22261
||mov|8,wb|19,*tesub||and offset|22262
||brn|6,gpf05|||all set|22263
|gpf16|mov|8,wa|19,*trsi_||set length|22267
||mov|8,wb|19,*trval||and offset|22268
||brn|6,gpf05|||all set|22269
|gpf17|mov|8,wa|13,exlen(xr)||load length|22273
||mov|8,wb|19,*exflc||set offset|22274
||brn|6,gpf05|||jump back|22275
||enp||||end procedure gbcpf|22285
||ejc|||||22286
|gtarr|prc|25,e|1,2||entry point|22302
||mov|3,gtawa|8,wa||save wa indicator|22303
||mov|8,wa|9,(xr)||load type word|22304
||beq|8,wa|22,=b_art|6,gtar8|exit if already an array|22305
||beq|8,wa|22,=b_vct|6,gtar8|exit if already an array|22306
||bne|8,wa|22,=b_tbt|6,gta9a|else fail if not a table (sgd02)|22307
||mov|11,-(xs)|7,xr||replace tbblk pointer on stack|22311
||zer|7,xr|||signal first pass|22312
||zer|8,wb|||zero non-null element count|22313
|gtar1|mov|7,xl|9,(xs)||point to table|22323
||add|7,xl|13,tblen(xl)||point past last bucket|22324
||sub|7,xl|19,*tbbuk||set first bucket offset|22325
||mov|8,wa|7,xl||copy adjusted pointer|22326
|gtar2|mov|7,xl|8,wa||copy bucket pointer|22332
||dca|8,wa|||decrement bucket pointer|22333
|gtar3|mov|7,xl|13,tenxt(xl)||point to next teblk|22337
||beq|7,xl|9,(xs)|6,gtar6|jump if chain end (tbblk ptr)|22338
||mov|3,cnvtp|7,xl||else save teblk pointer|22339
|gtar4|mov|7,xl|13,teval(xl)||load value|22343
||beq|9,(xl)|22,=b_trt|6,gtar4|loop till value found|22344
||mov|8,wc|7,xl||copy value|22345
||mov|7,xl|3,cnvtp||restore teblk pointer|22346
||ejc|||||22347
||beq|8,wc|21,=nulls|6,gtar3|loop back to ignore null value|22353
||bnz|7,xr|6,gtar5||jump if second pass|22354
||icv|8,wb|||for the first pass, bump count|22355
||brn|6,gtar3|||and loop back for next teblk|22356
|gtar5|bze|3,gtawa|6,gta5a||jump if address wanted|22360
||mov|10,(xr)+|13,tesub(xl)||store subscript name|22361
||mov|10,(xr)+|8,wc||store value in arblk|22362
||brn|6,gtar3|||loop back for next teblk|22363
|gta5a|mov|10,(xr)+|7,xl||store teblk address in name|22368
||mov|10,(xr)+|7,xl||and value slots|22369
||brn|6,gtar3|||loop back for next teblk|22370
|gtar6|bne|8,wa|9,(xs)|6,gtar2|loop back if more buckets to go|22374
||bnz|7,xr|6,gtar7||else jump if second pass|22375
||bze|8,wb|6,gtar9||fail if no non-null elements|22379
||mov|8,wa|8,wb||else copy count|22380
||add|8,wa|8,wb||double (two words/element)|22381
||add|8,wa|18,=arvl2||add space for standard fields|22382
||wtb|8,wa|||convert length to bytes|22383
||bgt|8,wa|3,mxlen|6,gta9b|error if too long for array|22384
||jsr|6,alloc|||else allocate space for arblk|22385
||mov|9,(xr)|22,=b_art||store type word|22386
||zer|13,idval(xr)|||zero id for the moment|22387
||mov|13,arlen(xr)|8,wa||store length|22388
||mov|13,arndm(xr)|18,=num02||set dimensions = 2|22389
||ldi|4,intv1|||get integer one|22390
||sti|13,arlbd(xr)|||store as lbd 1|22391
||sti|13,arlb2(xr)|||store as lbd 2|22392
||ldi|4,intv2|||load integer two|22393
||sti|13,ardm2(xr)|||store as dim 2|22394
||mti|8,wb|||get element count as integer|22395
||sti|13,ardim(xr)|||store as dim 1|22396
||zer|13,arpr2(xr)|||zero prototype field for now|22397
||mov|13,arofs(xr)|19,*arpr2||set offset field (signal pass 2)|22398
||mov|8,wb|7,xr||save arblk pointer|22399
||add|7,xr|19,*arvl2||point to first element location|22400
||brn|6,gtar1|||jump back to fill in elements|22401
||ejc|||||22402
|gtar7|mov|7,xr|8,wb||restore arblk pointer|22408
||mov|9,(xs)|8,wb||store as result|22409
||ldi|13,ardim(xr)|||get number of elements (nn)|22415
||mli|4,intvh|||multiply by 100|22416
||adi|4,intv2|||add 2 (nn02)|22417
||jsr|6,icbld|||build integer|22418
||mov|11,-(xs)|7,xr||store ptr for gtstg|22419
||jsr|6,gtstg|||convert to string|22420
||ppm||||convert fail is impossible|22421
||mov|7,xl|7,xr||copy string pointer|22422
||mov|7,xr|10,(xs)+||reload arblk pointer|22423
||mov|13,arpr2(xr)|7,xl||store prototype ptr (nn02)|22424
||sub|8,wa|18,=num02||adjust length to point to zero|22425
||psc|7,xl|8,wa||point to zero|22426
||mov|8,wb|18,=ch_cm||load a comma|22427
||sch|8,wb|9,(xl)||store a comma over the zero|22428
||csc|7,xl|||complete store characters|22429
|gtar8|exi||||return to caller|22433
|gtar9|mov|7,xr|10,(xs)+||restore stack for conv err (sgd02)|22437
||exi|1,1|||return|22438
|gta9a|exi|1,2|||return|22442
|gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||22446
||enp||||procedure gtarr|22447
||ejc|||||22448
|gtcod|prc|25,e|1,1||entry point|22462
||beq|9,(xr)|22,=b_cds|6,gtcd1|jump if already code|22463
||beq|9,(xr)|22,=b_cdc|6,gtcd1|jump if already code|22464
||mov|11,-(xs)|7,xr||stack argument for gtstg|22468
||jsr|6,gtstg|||convert argument to string|22469
||ppm|6,gtcd2|||jump if non-convertible|22470
||mov|3,gtcef|3,flptr||save fail ptr in case of error|22471
||mov|3,r_gtc|3,r_cod||also save code ptr|22472
||mov|3,r_cim|7,xr||else set image pointer|22473
||mov|3,scnil|8,wa||set image length|22474
||zer|3,scnpt|||set scan pointer|22475
||mov|3,stage|18,=stgxc||set stage for execute compile|22476
||mov|3,lstsn|3,cmpsn||in case listr called|22477
||icv|3,cmpln|||bump line number|22479
||jsr|6,cmpil|||compile string|22481
||mov|3,stage|18,=stgxt||reset stage for execute time|22482
||zer|3,r_cim|||clear image|22483
|gtcd1|exi||||give normal gtcod return|22487
|gtcd2|exi|1,1|||give error return|22491
||enp||||end procedure gtcod|22492
||ejc|||||22493
|gtexp|prc|25,e|1,1||entry point|22510
||blo|9,(xr)|22,=b_e__|6,gtex1|jump if already an expression|22511
||mov|11,-(xs)|7,xr||store argument for gtstg|22512
||jsr|6,gtstg|||convert argument to string|22513
||ppm|6,gtex2|||jump if unconvertible|22514
||mov|7,xl|7,xr||copy input string pointer|22522
||plc|7,xl|8,wa||point one past the string end|22523
||lch|7,xl|11,-(xl)||fetch the last character|22524
||beq|7,xl|18,=ch_cl|6,gtex2|error if it is a semicolon|22525
||beq|7,xl|18,=ch_sm|6,gtex2|or if it is a colon|22526
||mov|3,r_cim|7,xr||set input image pointer|22530
||zer|3,scnpt|||set scan pointer|22531
||mov|3,scnil|8,wa||set input image length|22532
||mov|11,-(xs)|8,wb||save value/name flag|22534
||zer|8,wb|||set code for normal scan|22536
||mov|3,gtcef|3,flptr||save fail ptr in case of error|22537
||mov|3,r_gtc|3,r_cod||also save code ptr|22538
||mov|3,stage|18,=stgev||adjust stage for compile|22539
||mov|3,scntp|18,=t_uok||indicate unary operator acceptable|22540
||jsr|6,expan|||build tree for expression|22541
||zer|3,scnrs|||reset rescan flag|22542
||mov|8,wa|10,(xs)+||restore value/name flag|22544
||bne|3,scnpt|3,scnil|6,gtex2|error if not end of image|22546
||zer|8,wb|||set ok value for cdgex call|22547
||mov|7,xl|7,xr||copy tree pointer|22548
||jsr|6,cdgex|||build expression block|22549
||zer|3,r_cim|||clear pointer|22550
||mov|3,stage|18,=stgxt||restore stage for execute time|22551
|gtex1|exi||||return to gtexp caller|22555
|gtex2|exi|1,1|||take error exit|22559
||enp||||end procedure gtexp|22560
||ejc|||||22561
|gtint|prc|25,e|1,1||entry point|22576
||beq|9,(xr)|22,=b_icl|6,gtin2|jump if already an integer|22577
||mov|3,gtina|8,wa||else save wa|22578
||mov|3,gtinb|8,wb||save wb|22579
||jsr|6,gtnum|||convert to numeric|22580
||ppm|6,gtin3|||jump if unconvertible|22581
||beq|8,wa|22,=b_icl|6,gtin1|jump if integer|22584
||ldr|13,rcval(xr)|||load real value|22588
||rti|6,gtin3|||convert to integer (err if ovflow)|22589
||jsr|6,icbld|||if ok build icblk|22590
|gtin1|mov|8,wa|3,gtina||restore wa|22595
||mov|8,wb|3,gtinb||restore wb|22596
|gtin2|exi||||return to gtint caller|22600
|gtin3|exi|1,1|||take convert error exit|22604
||enp||||end procedure gtint|22605
||ejc|||||22606
|gtnum|prc|25,e|1,1||entry point|22621
||mov|8,wa|9,(xr)||load first word of block|22622
||beq|8,wa|22,=b_icl|6,gtn34|jump if integer (no conversion)|22623
||beq|8,wa|22,=b_rcl|6,gtn34|jump if real (no conversion)|22626
||mov|11,-(xs)|7,xr||stack argument in case convert err|22632
||mov|11,-(xs)|7,xr||stack argument for gtstg|22633
||jsr|6,gtstg|||convert argument to string|22635
||ppm|6,gtn36|||jump if unconvertible|22639
||ldi|4,intv0|||initialize integer result to zero|22643
||bze|8,wa|6,gtn32||jump to exit with zero if null|22644
||lct|8,wa|8,wa||set bct counter for following loops|22645
||zer|3,gtnnf|||tentatively indicate result +|22646
||sti|3,gtnex|||initialise exponent to zero|22649
||zer|3,gtnsc|||zero scale in case real|22650
||zer|3,gtndf|||reset flag for dec point found|22651
||zer|3,gtnrd|||reset flag for digits found|22652
||ldr|4,reav0|||zero real accum in case real|22653
||plc|7,xr|||point to argument characters|22655
|gtn01|lch|8,wb|10,(xr)+||load first character|22659
||blt|8,wb|18,=ch_d0|6,gtn02|jump if not digit|22660
||ble|8,wb|18,=ch_d9|6,gtn06|jump if first char is a digit|22661
||ejc|||||22662
|gtn02|bne|8,wb|18,=ch_bl|6,gtn03|jump if non-blank|22668
|gtna2|bct|8,wa|6,gtn01||else decr count and loop back|22669
||brn|6,gtn07|||jump to return zero if all blanks|22670
|gtn03|beq|8,wb|18,=ch_pl|6,gtn04|jump if plus sign|22674
||beq|8,wb|18,=ch_ht|6,gtna2|horizontal tab equiv to blank|22676
||bne|8,wb|18,=ch_mn|6,gtn12|jump if not minus (may be real)|22684
||mnz|3,gtnnf|||if minus sign, set negative flag|22686
|gtn04|bct|8,wa|6,gtn05||jump if chars left|22690
||brn|6,gtn36|||else error|22691
|gtn05|lch|8,wb|10,(xr)+||load next character|22695
||blt|8,wb|18,=ch_d0|6,gtn08|jump if not a digit|22696
||bgt|8,wb|18,=ch_d9|6,gtn08|jump if not a digit|22697
|gtn06|sti|3,gtnsi|||save current value|22701
||cvm|6,gtn35|||current*10-(new dig) jump if ovflow|22705
||mnz|3,gtnrd|||set digit read flag|22706
||bct|8,wa|6,gtn05||else loop back if more chars|22708
|gtn07|bnz|3,gtnnf|6,gtn32||jump if negative (all set)|22712
||ngi||||else negate|22713
||ino|6,gtn32|||jump if no overflow|22714
||brn|6,gtn36|||else signal error|22715
||ejc|||||22716
|gtn08|beq|8,wb|18,=ch_bl|6,gtna9|jump if a blank|22723
||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22725
||itr||||else convert integer to real|22733
||ngr||||negate to get positive value|22734
||brn|6,gtn12|||jump to try for real|22735
|gtn09|lch|8,wb|10,(xr)+||get next char|22740
||beq|8,wb|18,=ch_ht|6,gtna9|jump if horizontal tab|22742
||bne|8,wb|18,=ch_bl|6,gtn36|error if non-blank|22747
|gtna9|bct|8,wa|6,gtn09||loop back if more chars to check|22748
||brn|6,gtn07|||return integer if all blanks|22749
|gtn10|lch|8,wb|10,(xr)+||load next character|22755
||blt|8,wb|18,=ch_d0|6,gtn12|jump if non-numeric|22756
||bgt|8,wb|18,=ch_d9|6,gtn12|jump if non-numeric|22757
|gtn11|sub|8,wb|18,=ch_d0||convert digit to number|22761
||mlr|4,reavt|||multiply real by 10.0|22762
||rov|6,gtn36|||convert error if overflow|22763
||str|3,gtnsr|||save result|22764
||mti|8,wb|||get new digit as integer|22765
||itr||||convert new digit to real|22766
||adr|3,gtnsr|||add to get new total|22767
||add|3,gtnsc|3,gtndf||increment scale if after dec point|22768
||mnz|3,gtnrd|||set digit found flag|22769
||bct|8,wa|6,gtn10||loop back if more chars|22770
||brn|6,gtn22|||else jump to scale|22771
||ejc|||||22772
|gtn12|bne|8,wb|18,=ch_dt|6,gtn13|jump if not dec point|22778
||bnz|3,gtndf|6,gtn36||if dec point, error if one already|22779
||mov|3,gtndf|18,=num01||else set flag for dec point|22780
||bct|8,wa|6,gtn10||loop back if more chars|22781
||brn|6,gtn22|||else jump to scale|22782
|gtn13|beq|8,wb|18,=ch_le|6,gtn15|jump if e for exponent|22786
||beq|8,wb|18,=ch_ld|6,gtn15|jump if d for exponent|22787
|gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|jump if blank|22795
||beq|8,wb|18,=ch_ht|6,gtnb4|jump if horizontal tab|22797
||brn|6,gtn36|||error if non-blank|22802
|gtnb4|lch|8,wb|10,(xr)+||get next character|22804
||bct|8,wa|6,gtn14||loop back to check if more|22805
||brn|6,gtn22|||else jump to scale|22806
|gtn15|zer|3,gtnes|||set exponent sign positive|22810
||ldi|4,intv0|||initialize exponent to zero|22811
||mnz|3,gtndf|||reset no dec point indication|22812
||bct|8,wa|6,gtn16||jump skipping past e or d|22813
||brn|6,gtn36|||error if null exponent|22814
|gtn16|lch|8,wb|10,(xr)+||load first exponent character|22818
||beq|8,wb|18,=ch_pl|6,gtn17|jump if plus sign|22819
||bne|8,wb|18,=ch_mn|6,gtn19|else jump if not minus sign|22820
||mnz|3,gtnes|||set sign negative if minus sign|22821
|gtn17|bct|8,wa|6,gtn18||jump if chars left|22825
||brn|6,gtn36|||else error|22826
|gtn18|lch|8,wb|10,(xr)+||load next character|22830
||ejc|||||22831
|gtn19|blt|8,wb|18,=ch_d0|6,gtn20|jump if not digit|22837
||bgt|8,wb|18,=ch_d9|6,gtn20|jump if not digit|22838
||cvm|6,gtn36|||else current*10, subtract new digit|22839
||bct|8,wa|6,gtn18||loop back if more chars|22840
||brn|6,gtn21|||jump if exponent field is exhausted|22841
|gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|jump if blank|22845
||beq|8,wb|18,=ch_ht|6,gtnc0|jump if horizontal tab|22847
||brn|6,gtn36|||error if non-blank|22852
|gtnc0|lch|8,wb|10,(xr)+||get next character|22854
||bct|8,wa|6,gtn20||loop back till all blanks scanned|22855
|gtn21|sti|3,gtnex|||save collected exponent|22859
||bnz|3,gtnes|6,gtn22||jump if it was negative|22860
||ngi||||else complement|22861
||iov|6,gtn36|||error if overflow|22862
||sti|3,gtnex|||and store positive exponent|22863
|gtn22|bze|3,gtnrd|6,gtn36||error if not digits collected|22867
||bze|3,gtndf|6,gtn36||error if no exponent or dec point|22868
||mti|3,gtnsc|||else load scale as integer|22869
||sbi|3,gtnex|||subtract exponent|22870
||iov|6,gtn36|||error if overflow|22871
||ilt|6,gtn26|||jump if we must scale up|22872
||mfi|8,wa|6,gtn36||load scale factor, err if ovflow|22876
|gtn23|ble|8,wa|18,=num10|6,gtn24|jump if 10 or less to go|22880
||dvr|4,reatt|||else divide by 10**10|22881
||sub|8,wa|18,=num10||decrement scale|22882
||brn|6,gtn23|||and loop back|22883
||ejc|||||22884
|gtn24|bze|8,wa|6,gtn30||jump if scaled|22890
||lct|8,wb|18,=cfp_r||else get indexing factor|22891
||mov|7,xr|21,=reav1||point to powers of ten table|22892
||wtb|8,wa|||convert remaining scale to byte ofs|22893
|gtn25|add|7,xr|8,wa||bump pointer|22897
||bct|8,wb|6,gtn25||once for each value word|22898
||dvr|9,(xr)|||scale down as required|22899
||brn|6,gtn30|||and jump|22900
|gtn26|ngi||||get absolute value of exponent|22904
||iov|6,gtn36|||error if overflow|22905
||mfi|8,wa|6,gtn36||acquire scale, error if ovflow|22906
|gtn27|ble|8,wa|18,=num10|6,gtn28|jump if 10 or less to go|22910
||mlr|4,reatt|||else multiply by 10**10|22911
||rov|6,gtn36|||error if overflow|22912
||sub|8,wa|18,=num10||else decrement scale|22913
||brn|6,gtn27|||and loop back|22914
|gtn28|bze|8,wa|6,gtn30||jump if scaled|22918
||lct|8,wb|18,=cfp_r||else get indexing factor|22919
||mov|7,xr|21,=reav1||point to powers of ten table|22920
||wtb|8,wa|||convert remaining scale to byte ofs|22921
|gtn29|add|7,xr|8,wa||bump pointer|22925
||bct|8,wb|6,gtn29||once for each word in value|22926
||mlr|9,(xr)|||scale up|22927
||rov|6,gtn36|||error if overflow|22928
||ejc|||||22929
|gtn30|bze|3,gtnnf|6,gtn31||jump if positive|22935
||ngr||||else negate|22936
|gtn31|jsr|6,rcbld|||build real block|22940
||brn|6,gtn33|||merge to exit|22941
|gtn32|jsr|6,icbld|||build icblk|22946
|gtn33|mov|8,wa|9,(xr)||load first word of result block|22950
||ica|7,xs|||pop argument off stack|22951
|gtn34|exi||||return to gtnum caller|22955
|gtn35|lch|8,wb|11,-(xr)||reload current character|22962
||lch|8,wb|10,(xr)+||bump character pointer|22963
||ldi|3,gtnsi|||reload integer so far|22964
||itr||||convert to real|22965
||ngr||||make value positive|22966
||brn|6,gtn11|||merge with real circuit|22967
|gtn36|mov|7,xr|10,(xs)+||reload original argument|22972
||exi|1,1|||take convert-error exit|22973
||enp||||end procedure gtnum|22974
||ejc|||||22975
|gtnvr|prc|25,e|1,1||entry point|22989
||bne|9,(xr)|22,=b_nml|6,gnv02|jump if not name|22991
||mov|7,xr|13,nmbas(xr)||else load name base if name|22992
||blo|7,xr|3,state|6,gnv07|skip if vrblk (in static region)|22993
|gnv01|exi|1,1|||take convert-error exit|22997
|gnv02|mov|3,gnvsa|8,wa||save wa|23001
||mov|3,gnvsb|8,wb||save wb|23002
||mov|11,-(xs)|7,xr||stack argument for gtstg|23003
||jsr|6,gtstg|||convert argument to string|23004
||ppm|6,gnv01|||jump if conversion error|23005
||bze|8,wa|6,gnv01||null string is an error|23006
||mov|11,-(xs)|7,xl||save xl|23010
||mov|11,-(xs)|7,xr||stack string ptr for later|23011
||mov|8,wb|7,xr||copy string pointer|23012
||add|8,wb|19,*schar||point to characters of string|23013
||mov|3,gnvst|8,wb||save pointer to characters|23014
||mov|8,wb|8,wa||copy length|23015
||ctw|8,wb|1,0||get number of words in name|23016
||mov|3,gnvnw|8,wb||save for later|23017
||jsr|6,hashs|||compute hash index for string|23018
||rmi|3,hshnb|||compute hash offset by taking mod|23019
||mfi|8,wc|||get as offset|23020
||wtb|8,wc|||convert offset to bytes|23021
||add|8,wc|3,hshtb||point to proper hash chain|23022
||sub|8,wc|19,*vrnxt||subtract offset to merge into loop|23023
||ejc|||||23024
|gnv03|mov|7,xl|8,wc||copy hash chain pointer|23030
||mov|7,xl|13,vrnxt(xl)||point to next vrblk on chain|23031
||bze|7,xl|6,gnv08||jump if end of chain|23032
||mov|8,wc|7,xl||save pointer to this vrblk|23033
||bnz|13,vrlen(xl)|6,gnv04||jump if not system variable|23034
||mov|7,xl|13,vrsvp(xl)||else point to svblk|23035
||sub|7,xl|19,*vrsof||adjust offset for merge|23036
|gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|back for next vrblk if lengths ne|23040
||add|7,xl|19,*vrchs||else point to chars of chain entry|23041
||lct|8,wb|3,gnvnw||get word counter to control loop|23042
||mov|7,xr|3,gnvst||point to chars of new name|23043
|gnv05|cne|9,(xr)|9,(xl)|6,gnv03|jump if no match for next vrblk|23047
||ica|7,xr|||bump new name pointer|23048
||ica|7,xl|||bump vrblk in chain name pointer|23049
||bct|8,wb|6,gnv05||else loop till all compared|23050
||mov|7,xr|8,wc||we have found a match, get vrblk|23051
|gnv06|mov|8,wa|3,gnvsa||restore wa|23055
||mov|8,wb|3,gnvsb||restore wb|23056
||ica|7,xs|||pop string pointer|23057
||mov|7,xl|10,(xs)+||restore xl|23058
|gnv07|exi||||return to gtnvr caller|23062
|gnv08|zer|7,xr|||clear garbage xr pointer|23066
||mov|3,gnvhe|8,wc||save ptr to end of hash chain|23067
||bgt|8,wa|18,=num09|6,gnv14|cannot be system var if length gt 9|23068
||mov|7,xl|8,wa||else copy length|23069
||wtb|7,xl|||convert to byte offset|23070
||mov|7,xl|14,vsrch(xl)||point to first svblk of this length|23071
||ejc|||||23072
|gnv09|mov|3,gnvsp|7,xl||save table pointer|23078
||mov|8,wc|10,(xl)+||load svbit bit string|23079
||mov|8,wb|10,(xl)+||load length from table entry|23080
||bne|8,wa|8,wb|6,gnv14|jump if end of right length entries|23081
||lct|8,wb|3,gnvnw||get word counter to control loop|23082
||mov|7,xr|3,gnvst||point to chars of new name|23083
|gnv10|cne|9,(xr)|9,(xl)|6,gnv11|jump if name mismatch|23087
||ica|7,xr|||else bump new name pointer|23088
||ica|7,xl|||bump svblk pointer|23089
||bct|8,wb|6,gnv10||else loop until all checked|23090
||zer|8,wc|||set vrlen value zero|23094
||mov|8,wa|19,*vrsi_||set standard size|23095
||brn|6,gnv15|||jump to build vrblk|23096
|gnv11|ica|7,xl|||bump past word of chars|23100
||bct|8,wb|6,gnv11||loop back if more to go|23101
||rsh|8,wc|2,svnbt||remove uninteresting bits|23102
|gnv12|mov|8,wb|4,bits1||load bit to test|23106
||anb|8,wb|8,wc||test for word present|23107
||zrb|8,wb|6,gnv13||jump if not present|23108
||ica|7,xl|||else bump table pointer|23109
|gnv13|rsh|8,wc|1,1||remove bit already processed|23113
||nzb|8,wc|6,gnv12||loop back if more bits to test|23114
||brn|6,gnv09|||else loop back for next svblk|23115
|gnv14|mov|8,wc|8,wa||copy vrlen value|23119
||mov|8,wa|18,=vrchs||load standard size -chars|23120
||add|8,wa|3,gnvnw||adjust for chars of name|23121
||wtb|8,wa|||convert length to bytes|23122
||ejc|||||23123
|gnv15|jsr|6,alost|||allocate space for vrblk (static)|23129
||mov|8,wb|7,xr||save vrblk pointer|23130
||mov|7,xl|21,=stnvr||point to model variable block|23131
||mov|8,wa|19,*vrlen||set length of standard fields|23132
||mvw||||set initial fields of new block|23133
||mov|7,xl|3,gnvhe||load pointer to end of hash chain|23134
||mov|13,vrnxt(xl)|8,wb||add new block to end of chain|23135
||mov|10,(xr)+|8,wc||set vrlen field, bump ptr|23136
||mov|8,wa|3,gnvnw||get length in words|23137
||wtb|8,wa|||convert to length in bytes|23138
||bze|8,wc|6,gnv16||jump if system variable|23139
||mov|7,xl|9,(xs)||point back to string name|23143
||add|7,xl|19,*schar||point to chars of name|23144
||mvw||||move characters into place|23145
||mov|7,xr|8,wb||restore vrblk pointer|23146
||brn|6,gnv06|||jump back to exit|23147
|gnv16|mov|7,xl|3,gnvsp||load pointer to svblk|23152
||mov|9,(xr)|7,xl||set svblk ptr in vrblk|23153
||mov|7,xr|8,wb||restore vrblk pointer|23154
||mov|8,wb|13,svbit(xl)||load bit indicators|23155
||add|7,xl|19,*svchs||point to characters of name|23156
||add|7,xl|8,wa||point past characters|23157
||mov|8,wc|4,btknm||load test bit|23161
||anb|8,wc|8,wb||and to test|23162
||zrb|8,wc|6,gnv17||jump if no keyword number|23163
||ica|7,xl|||else bump pointer|23164
||ejc|||||23165
|gnv17|mov|8,wc|4,btfnc||get test bit|23171
||anb|8,wc|8,wb||and to test|23172
||zrb|8,wc|6,gnv18||skip if no system function|23173
||mov|13,vrfnc(xr)|7,xl||else point vrfnc to svfnc field|23174
||add|7,xl|19,*num02||and bump past svfnc, svnar fields|23175
|gnv18|mov|8,wc|4,btlbl||get test bit|23179
||anb|8,wc|8,wb||and to test|23180
||zrb|8,wc|6,gnv19||jump if bit is off (no system labl)|23181
||mov|13,vrlbl(xr)|7,xl||else point vrlbl to svlbl field|23182
||ica|7,xl|||bump past svlbl field|23183
|gnv19|mov|8,wc|4,btval||load test bit|23187
||anb|8,wc|8,wb||and to test|23188
||zrb|8,wc|6,gnv06||all done if no value|23189
||mov|13,vrval(xr)|9,(xl)||else set initial value|23190
||mov|13,vrsto(xr)|22,=b_vre||set error store access|23191
||brn|6,gnv06|||merge back to exit to caller|23192
||enp||||end procedure gtnvr|23193
||ejc|||||23194
|gtpat|prc|25,e|1,1||entry point|23209
||bhi|9,(xr)|22,=p_aaa|6,gtpt5|jump if pattern already|23211
||mov|3,gtpsb|8,wb||save wb|23215
||mov|11,-(xs)|7,xr||stack argument for gtstg|23216
||jsr|6,gtstg|||convert argument to string|23217
||ppm|6,gtpt2|||jump if impossible|23218
||bnz|8,wa|6,gtpt1||jump if non-null|23222
||mov|7,xr|21,=ndnth||point to nothen node|23226
||brn|6,gtpt4|||jump to exit|23227
||ejc|||||23228
|gtpt1|mov|8,wb|22,=p_str||load pcode for multi-char string|23234
||bne|8,wa|18,=num01|6,gtpt3|jump if multi-char string|23235
||plc|7,xr|||point to character|23239
||lch|8,wa|9,(xr)||load character|23240
||mov|7,xr|8,wa||set as parm1|23241
||mov|8,wb|22,=p_ans||point to pcode for 1-char any|23242
||brn|6,gtpt3|||jump to build node|23243
|gtpt2|mov|8,wb|22,=p_exa||set pcode for expression in case|23247
||blo|9,(xr)|22,=b_e__|6,gtpt3|jump to build node if expression|23248
||exi|1,1|||take convert error exit|23252
|gtpt3|jsr|6,pbild|||call routine to build pattern node|23256
|gtpt4|mov|8,wb|3,gtpsb||restore wb|23260
|gtpt5|exi||||return to gtpat caller|23264
||enp||||end procedure gtpat|23265
||ejc|||||23268
|gtrea|prc|25,e|1,1||entry point|23282
||mov|8,wa|9,(xr)||get first word of block|23283
||beq|8,wa|22,=b_rcl|6,gtre2|jump if real|23284
||jsr|6,gtnum|||else convert argument to numeric|23285
||ppm|6,gtre3|||jump if unconvertible|23286
||beq|8,wa|22,=b_rcl|6,gtre2|jump if real was returned|23287
|gtre1|ldi|13,icval(xr)|||load integer|23291
||itr||||convert to real|23292
||jsr|6,rcbld|||build rcblk|23293
|gtre2|exi||||return to gtrea caller|23297
|gtre3|exi|1,1|||take convert error exit|23301
||enp||||end procedure gtrea|23302
||ejc|||||23304
|gtsmi|prc|25,n|1,2||entry point|23324
||mov|7,xr|10,(xs)+||load argument|23325
||beq|9,(xr)|22,=b_icl|6,gtsm1|skip if already an integer|23326
||jsr|6,gtint|||convert argument to integer|23330
||ppm|6,gtsm2|||jump if convert is impossible|23331
|gtsm1|ldi|13,icval(xr)|||load integer value|23335
||mfi|8,wc|6,gtsm3||move as one word, jump if ovflow|23336
||bgt|8,wc|3,mxlen|6,gtsm3|or if too large|23337
||mov|7,xr|8,wc||copy result to xr|23338
||exi||||return to gtsmi caller|23339
|gtsm2|exi|1,1|||take non-integer error exit|23343
|gtsm3|exi|1,2|||take out-of-range error exit|23347
||enp||||end procedure gtsmi|23348
||ejc|||||23349
|gtstg|prc|25,n|1,1||entry point|23415
||mov|7,xr|10,(xs)+||load argument, pop stack|23416
||beq|9,(xr)|22,=b_scl|6,gts30|jump if already a string|23417
|gts01|mov|11,-(xs)|7,xr||restack argument in case error|23421
||mov|11,-(xs)|7,xl||save xl|23422
||mov|3,gtsvb|8,wb||save wb|23423
||mov|3,gtsvc|8,wc||save wc|23424
||mov|8,wa|9,(xr)||load first word of block|23425
||beq|8,wa|22,=b_icl|6,gts05|jump to convert integer|23426
||beq|8,wa|22,=b_rcl|6,gts10|jump to convert real|23429
||beq|8,wa|22,=b_nml|6,gts03|jump to convert name|23431
|gts02|mov|7,xl|10,(xs)+||restore xl|23439
||mov|7,xr|10,(xs)+||reload input argument|23440
||exi|1,1|||take convert error exit|23441
||ejc|||||23442
|gts03|mov|7,xl|13,nmbas(xr)||load name base|23448
||bhi|7,xl|3,state|6,gts02|error if not natural var (static)|23449
||add|7,xl|19,*vrsof||else point to possible string name|23450
||mov|8,wa|13,sclen(xl)||load length|23451
||bnz|8,wa|6,gts04||jump if not system variable|23452
||mov|7,xl|13,vrsvo(xl)||else point to svblk|23453
||mov|8,wa|13,svlen(xl)||and load name length|23454
|gts04|zer|8,wb|||set offset to zero|23458
||jsr|6,sbstr|||use sbstr to copy string|23459
||brn|6,gts29|||jump to exit|23460
|gts05|ldi|13,icval(xr)|||load integer value|23464
||mov|3,gtssf|18,=num01||set sign flag negative|23472
||ilt|6,gts06|||skip if integer is negative|23473
||ngi||||else negate integer|23474
||zer|3,gtssf|||and reset negative flag|23475
||ejc|||||23476
|gts06|mov|7,xr|3,gtswk||point to result work area|23483
||mov|8,wb|18,=nstmx||initialize counter to max length|23484
||psc|7,xr|8,wb||prepare to store (right-left)|23485
|gts07|cvd||||convert one digit into wa|23489
||sch|8,wa|11,-(xr)||store in work area|23490
||dcv|8,wb|||decrement counter|23491
||ine|6,gts07|||loop if more digits to go|23492
||csc|7,xr|||complete store characters|23493
|gts08|mov|8,wa|18,=nstmx||get max number of characters|23499
||sub|8,wa|8,wb||compute length of result|23500
||mov|7,xl|8,wa||remember length for move later on|23501
||add|8,wa|3,gtssf||add one for negative sign if needed|23502
||jsr|6,alocs|||allocate string for result|23503
||mov|8,wc|7,xr||save result pointer for the moment|23504
||psc|7,xr|||point to chars of result block|23505
||bze|3,gtssf|6,gts09||skip if positive|23506
||mov|8,wa|18,=ch_mn||else load negative sign|23507
||sch|8,wa|10,(xr)+||and store it|23508
||csc|7,xr|||complete store characters|23509
|gts09|mov|8,wa|7,xl||recall length to move|23513
||mov|7,xl|3,gtswk||point to result work area|23514
||plc|7,xl|8,wb||point to first result character|23515
||mvc||||move chars to result string|23516
||mov|7,xr|8,wc||restore result pointer|23517
||brn|6,gts29|||jump to exit|23520
||ejc|||||23521
|gts10|ldr|13,rcval(xr)|||load real|23527
||zer|3,gtssf|||reset negative flag|23539
||req|6,gts31|||skip if zero|23540
||rge|6,gts11|||jump if real is positive|23541
||mov|3,gtssf|18,=num01||else set negative flag|23542
||ngr||||and get absolute value of real|23543
|gts11|ldi|4,intv0|||initialize exponent to zero|23547
|gts12|str|3,gtsrs|||save real value|23551
||sbr|4,reap1|||subtract 0.1 to compare|23552
||rge|6,gts13|||jump if scale up not required|23553
||ldr|3,gtsrs|||else reload value|23554
||mlr|4,reatt|||multiply by 10**10|23555
||sbi|4,intvt|||decrement exponent by 10|23556
||brn|6,gts12|||loop back to test again|23557
|gts13|ldr|3,gtsrs|||reload value|23561
||sbr|4,reav1|||subtract 1.0|23562
||rlt|6,gts17|||jump if no scale down required|23563
||ldr|3,gtsrs|||else reload value|23564
|gts14|sbr|4,reatt|||subtract 10**10 to compare|23568
||rlt|6,gts15|||jump if large step not required|23569
||ldr|3,gtsrs|||else restore value|23570
||dvr|4,reatt|||divide by 10**10|23571
||str|3,gtsrs|||store new value|23572
||adi|4,intvt|||increment exponent by 10|23573
||brn|6,gts14|||loop back|23574
||ejc|||||23575
|gts15|mov|7,xr|21,=reav1||point to powers of ten table|23582
|gts16|ldr|3,gtsrs|||reload value|23586
||adi|4,intv1|||increment exponent|23587
||add|7,xr|19,*cfp_r||point to next entry in table|23588
||sbr|9,(xr)|||subtract it to compare|23589
||rge|6,gts16|||loop till we find a larger entry|23590
||ldr|3,gtsrs|||then reload the value|23591
||dvr|9,(xr)|||and complete scaling|23592
||str|3,gtsrs|||store value|23593
|gts17|ldr|3,gtsrs|||get value again|23597
||adr|3,gtsrn|||add rounding factor|23598
||str|3,gtsrs|||store result|23599
||sbr|4,reav1|||subtract 1.0 to compare|23604
||rlt|6,gts18|||skip if ok|23605
||adi|4,intv1|||else increment exponent|23606
||ldr|3,gtsrs|||reload value|23607
||dvr|4,reavt|||divide by 10.0 to rescale|23608
||brn|6,gts19|||jump to merge|23609
|gts18|ldr|3,gtsrs|||reload rounded value|23613
||ejc|||||23614
|gts19|mov|7,xl|18,=cfp_s||set num dec digits = cfp_s|23638
||mov|3,gtses|18,=ch_mn||set exponent sign negative|23639
||ilt|6,gts21|||all set if exponent is negative|23640
||mfi|8,wa|||else fetch exponent|23641
||ble|8,wa|18,=cfp_s|6,gts20|skip if we can use special format|23642
||mti|8,wa|||else restore exponent|23643
||ngi||||set negative for cvd|23644
||mov|3,gtses|18,=ch_pl||set plus sign for exponent sign|23645
||brn|6,gts21|||jump to generate exponent|23646
|gts20|sub|7,xl|8,wa||compute digits after decimal point|23650
||ldi|4,intv0|||reset exponent to zero|23651
||ejc|||||23652
|gts21|mov|7,xr|3,gtswk||point to work area|23663
||mov|8,wb|18,=nstmx||set character ctr to max length|23664
||psc|7,xr|8,wb||prepare to store (right to left)|23665
||ieq|6,gts23|||skip exponent if it is zero|23666
|gts22|cvd||||convert a digit into wa|23670
||sch|8,wa|11,-(xr)||store in work area|23671
||dcv|8,wb|||decrement counter|23672
||ine|6,gts22|||loop back if more digits to go|23673
||mov|8,wa|3,gtses||load exponent sign|23677
||sch|8,wa|11,-(xr)||store in work area|23678
||mov|8,wa|18,=ch_le||get character letter e|23679
||sch|8,wa|11,-(xr)||store in work area|23680
||sub|8,wb|18,=num02||decrement counter for sign and e|23681
|gts23|mlr|3,gtssc|||convert real to integer (10**cfp_s)|23685
||rti||||get integer (overflow impossible)|23686
||ngi||||negate as required by cvd|23687
|gts24|bze|7,xl|6,gts27||jump if no digits left to do|23691
||cvd||||else convert one digit|23692
||bne|8,wa|18,=ch_d0|6,gts26|jump if not a zero|23693
||dcv|7,xl|||decrement counter|23694
||brn|6,gts24|||loop back for next digit|23695
||ejc|||||23696
|gts25|cvd||||convert a digit into wa|23702
|gts26|sch|8,wa|11,-(xr)||store digit|23706
||dcv|8,wb|||decrement counter|23707
||dcv|7,xl|||decrement counter|23708
||bnz|7,xl|6,gts25||loop back if more to go|23709
|gts27|mov|8,wa|18,=ch_dt||load decimal point|23713
||sch|8,wa|11,-(xr)||store in work area|23714
||dcv|8,wb|||decrement counter|23715
|gts28|cvd||||convert a digit into wa|23719
||sch|8,wa|11,-(xr)||store in work area|23720
||dcv|8,wb|||decrement counter|23721
||ine|6,gts28|||loop back if more to go|23722
||csc|7,xr|||complete store characters|23723
||brn|6,gts08|||else jump back to exit|23724
|gts29|mov|7,xl|10,(xs)+||restore xl|23730
||ica|7,xs|||pop argument|23731
||mov|8,wb|3,gtsvb||restore wb|23732
||mov|8,wc|3,gtsvc||restore wc|23733
|gts30|mov|8,wa|13,sclen(xr)||load string length|23737
||exi||||return to caller|23738
|gts31|mov|7,xl|21,=scre0||point to string|23744
||mov|8,wa|18,=num02||2 chars|23745
||zer|8,wb|||zero offset|23746
||jsr|6,sbstr|||copy string|23747
||brn|6,gts29|||return|23748
||enp||||end procedure gtstg|23775
||ejc|||||23776
|gtvar|prc|25,e|1,1||entry point|23791
||bne|9,(xr)|22,=b_nml|6,gtvr2|jump if not a name|23792
||mov|8,wa|13,nmofs(xr)||else load name offset|23793
||mov|7,xl|13,nmbas(xr)||load name base|23794
||beq|9,(xl)|22,=b_evt|6,gtvr1|error if expression variable|23795
||bne|9,(xl)|22,=b_kvt|6,gtvr3|all ok if not keyword variable|23796
|gtvr1|exi|1,1|||take convert error exit|23800
|gtvr2|mov|3,gtvrc|8,wc||save wc|23804
||jsr|6,gtnvr|||locate vrblk if possible|23805
||ppm|6,gtvr1|||jump if convert error|23806
||mov|7,xl|7,xr||else copy vrblk name base|23807
||mov|8,wa|19,*vrval||and set offset|23808
||mov|8,wc|3,gtvrc||restore wc|23809
|gtvr3|bhi|7,xl|3,state|6,gtvr4|all ok if not natural variable|23813
||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|error if protected variable|23814
|gtvr4|exi||||return to caller|23818
||enp||||end procedure gtvar|23819
||ejc|||||23820
||ejc|||||23821
|hashs|prc|25,e|1,0||entry point|23857
||mov|8,wc|18,=e_hnw||get number of words to use|23859
||bze|8,wc|6,hshsa||branch if one character per word|23860
||mov|8,wc|13,sclen(xr)||load string length in characters|23861
||mov|8,wb|8,wc||initialize with length|23862
||bze|8,wc|6,hshs3||jump if null string|23863
||zgb|8,wb|||correct byte ordering if necessary|23864
||ctw|8,wc|1,0||get number of words of chars|23865
||add|7,xr|19,*schar||point to characters of string|23866
||blo|8,wc|18,=e_hnw|6,hshs1|use whole string if short|23867
||mov|8,wc|18,=e_hnw||else set to involve first e_hnw wds|23868
|hshs1|lct|8,wc|8,wc||set counter to control loop|23872
|hshs2|xob|8,wb|10,(xr)+||exclusive or next word of chars|23876
||bct|8,wc|6,hshs2||loop till all processed|23877
|hshs3|zgb|8,wb|||zeroise undefined bits|23881
||anb|8,wb|4,bitsm||ensure in range 0 to cfp_m|23882
||mti|8,wb|||move result as integer|23883
||zer|7,xr|||clear garbage value in xr|23884
||exi||||return to hashs caller|23885
|hshsa|mov|8,wc|13,sclen(xr)||load string length in characters|23889
||mov|8,wb|8,wc||initialize with length|23890
||bze|8,wc|6,hshs3||jump if null string|23891
||zgb|8,wb|||correct byte ordering if necessary|23892
||ctw|8,wc|1,0||get number of words of chars|23893
||plc|7,xr||||23894
||mov|11,-(xs)|7,xl||save xl|23895
||mov|7,xl|8,wc||load length for branch|23896
||bge|7,xl|18,=num25|6,hsh24|use first characters if longer|23897
||bsw|7,xl|1,25||merge to compute hash|23898
||iff|1,0|6,hsh00|||23924
||iff|1,1|6,hsh01|||23924
||iff|1,2|6,hsh02|||23924
||iff|1,3|6,hsh03|||23924
||iff|1,4|6,hsh04|||23924
||iff|1,5|6,hsh05|||23924
||iff|1,6|6,hsh06|||23924
||iff|1,7|6,hsh07|||23924
||iff|1,8|6,hsh08|||23924
||iff|1,9|6,hsh09|||23924
||iff|1,10|6,hsh10|||23924
||iff|1,11|6,hsh11|||23924
||iff|1,12|6,hsh12|||23924
||iff|1,13|6,hsh13|||23924
||iff|1,14|6,hsh14|||23924
||iff|1,15|6,hsh15|||23924
||iff|1,16|6,hsh16|||23924
||iff|1,17|6,hsh17|||23924
||iff|1,18|6,hsh18|||23924
||iff|1,19|6,hsh19|||23924
||iff|1,20|6,hsh20|||23924
||iff|1,21|6,hsh21|||23924
||iff|1,22|6,hsh22|||23924
||iff|1,23|6,hsh23|||23924
||iff|1,24|6,hsh24|||23924
||esw|||||23924
|hsh24|lch|8,wc|10,(xr)+||load next character|23925
||lsh|8,wc|1,24||shift for hash|23926
||xob|8,wb|8,wc||hash character|23927
|hsh23|lch|8,wc|10,(xr)+||load next character|23928
||lsh|8,wc|1,16||shift for hash|23929
||xob|8,wb|8,wc||hash character|23930
|hsh22|lch|8,wc|10,(xr)+||load next character|23931
||lsh|8,wc|1,8||shift for hash|23932
||xob|8,wb|8,wc||hash character|23933
|hsh21|lch|8,wc|10,(xr)+||load next character|23934
||xob|8,wb|8,wc||hash character|23935
|hsh20|lch|8,wc|10,(xr)+||load next character|23936
||lsh|8,wc|1,24||shift for hash|23937
||xob|8,wb|8,wc||hash character|23938
|hsh19|lch|8,wc|10,(xr)+||load next character|23939
||lsh|8,wc|1,16||shift for hash|23940
||xob|8,wb|8,wc||hash character|23941
|hsh18|lch|8,wc|10,(xr)+||load next character|23942
||lsh|8,wc|1,8||shift for hash|23943
||xob|8,wb|8,wc||hash character|23944
|hsh17|lch|8,wc|10,(xr)+||load next character|23945
||xob|8,wb|8,wc||hash character|23946
|hsh16|lch|8,wc|10,(xr)+||load next character|23947
||lsh|8,wc|1,24||shift for hash|23948
||xob|8,wb|8,wc||hash character|23949
|hsh15|lch|8,wc|10,(xr)+||load next character|23950
||lsh|8,wc|1,16||shift for hash|23951
||xob|8,wb|8,wc||hash character|23952
|hsh14|lch|8,wc|10,(xr)+||load next character|23953
||lsh|8,wc|1,8||shift for hash|23954
||xob|8,wb|8,wc||hash character|23955
|hsh13|lch|8,wc|10,(xr)+||load next character|23956
||xob|8,wb|8,wc||hash character|23957
|hsh12|lch|8,wc|10,(xr)+||load next character|23958
||lsh|8,wc|1,24||shift for hash|23959
||xob|8,wb|8,wc||hash character|23960
|hsh11|lch|8,wc|10,(xr)+||load next character|23961
||lsh|8,wc|1,16||shift for hash|23962
||xob|8,wb|8,wc||hash character|23963
|hsh10|lch|8,wc|10,(xr)+||load next character|23964
||lsh|8,wc|1,8||shift for hash|23965
||xob|8,wb|8,wc||hash character|23966
|hsh09|lch|8,wc|10,(xr)+||load next character|23967
||xob|8,wb|8,wc||hash character|23968
|hsh08|lch|8,wc|10,(xr)+||load next character|23969
||lsh|8,wc|1,24||shift for hash|23970
||xob|8,wb|8,wc||hash character|23971
|hsh07|lch|8,wc|10,(xr)+||load next character|23972
||lsh|8,wc|1,16||shift for hash|23973
||xob|8,wb|8,wc||hash character|23974
|hsh06|lch|8,wc|10,(xr)+||load next character|23975
||lsh|8,wc|1,8||shift for hash|23976
||xob|8,wb|8,wc||hash character|23977
|hsh05|lch|8,wc|10,(xr)+||load next character|23978
||xob|8,wb|8,wc||hash character|23979
|hsh04|lch|8,wc|10,(xr)+||load next character|23980
||lsh|8,wc|1,24||shift for hash|23981
||xob|8,wb|8,wc||hash character|23982
|hsh03|lch|8,wc|10,(xr)+||load next character|23983
||lsh|8,wc|1,16||shift for hash|23984
||xob|8,wb|8,wc||hash character|23985
|hsh02|lch|8,wc|10,(xr)+||load next character|23986
||lsh|8,wc|1,8||shift for hash|23987
||xob|8,wb|8,wc||hash character|23988
|hsh01|lch|8,wc|10,(xr)+||load next character|23989
||xob|8,wb|8,wc||hash character|23990
|hsh00|mov|7,xl|10,(xs)+||restore xl|23991
||brn|6,hshs3|||merge to complete hash|23992
||enp||||end procedure hashs|23993
|icbld|prc|25,e|1,0||entry point|24002
||mfi|7,xr|6,icbl1||copy small integers|24004
||ble|7,xr|18,=num02|6,icbl3|jump if 0,1 or 2|24005
|icbl1|mov|7,xr|3,dnamp||load pointer to next available loc|24009
||add|7,xr|19,*icsi_||point past new icblk|24010
||blo|7,xr|3,dname|6,icbl2|jump if there is room|24011
||mov|8,wa|19,*icsi_||else load length of icblk|24012
||jsr|6,alloc|||use standard allocator to get block|24013
||add|7,xr|8,wa||point past block to merge|24014
|icbl2|mov|3,dnamp|7,xr||set new pointer|24018
||sub|7,xr|19,*icsi_||point back to start of block|24019
||mov|9,(xr)|22,=b_icl||store type word|24020
||sti|13,icval(xr)|||store integer value in icblk|24021
||exi||||return to icbld caller|24022
|icbl3|wtb|7,xr|||convert integer to offset|24026
||mov|7,xr|14,intab(xr)||point to pre-built icblk|24027
||exi||||return|24028
||enp||||end procedure icbld|24029
||ejc|||||24030
|ident|prc|25,e|1,1||entry point|24044
||beq|7,xr|7,xl|6,iden7|jump if same pointer (ident)|24045
||mov|8,wc|9,(xr)||else load arg 1 type word|24046
||bne|8,wc|9,(xl)|6,iden1|differ if arg 2 type word differ|24048
||beq|8,wc|22,=b_scl|6,iden2|jump if strings|24052
||beq|8,wc|22,=b_icl|6,iden4|jump if integers|24053
||beq|8,wc|22,=b_rcl|6,iden5|jump if reals|24056
||beq|8,wc|22,=b_nml|6,iden6|jump if names|24058
|iden1|exi||||take differ exit|24101
|iden2|mov|8,wc|13,sclen(xr)||load arg 1 length|24105
||bne|8,wc|13,sclen(xl)|6,iden1|differ if lengths differ|24106
|idn2a|add|7,xr|19,*schar||point to chars of arg 1|24110
||add|7,xl|19,*schar||point to chars of arg 2|24111
||ctw|8,wc|1,0||get number of words in strings|24112
||lct|8,wc|8,wc||set loop counter|24113
|iden3|cne|9,(xr)|9,(xl)|6,iden8|differ if chars do not match|24118
||ica|7,xr|||else bump arg one pointer|24119
||ica|7,xl|||bump arg two pointer|24120
||bct|8,wc|6,iden3||loop back till all checked|24121
||ejc|||||24122
||zer|7,xl|||clear garbage value in xl|24128
||zer|7,xr|||clear garbage value in xr|24129
||exi|1,1|||take ident exit|24130
|iden4|ldi|13,icval(xr)|||load arg 1|24134
||sbi|13,icval(xl)|||subtract arg 2 to compare|24135
||iov|6,iden1|||differ if overflow|24136
||ine|6,iden1|||differ if result is not zero|24137
||exi|1,1|||take ident exit|24138
|iden5|ldr|13,rcval(xr)|||load arg 1|24144
||sbr|13,rcval(xl)|||subtract arg 2 to compare|24145
||rov|6,iden1|||differ if overflow|24146
||rne|6,iden1|||differ if result is not zero|24147
||exi|1,1|||take ident exit|24148
|iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|differ if different offset|24153
||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|differ if different base|24154
|iden7|exi|1,1|||take ident exit|24158
|iden8|zer|7,xr|||clear garbage ptr in xr|24162
||zer|7,xl|||clear garbage ptr in xl|24163
||exi||||return to caller (differ)|24164
||enp||||end procedure ident|24165
||ejc|||||24166
|inout|prc|25,e|1,0||entry point|24181
||mov|11,-(xs)|8,wb||stack trblk type|24182
||mov|8,wa|13,sclen(xl)||get name length|24183
||zer|8,wb|||point to start of name|24184
||jsr|6,sbstr|||build a proper scblk|24185
||jsr|6,gtnvr|||build vrblk|24186
||ppm||||no error return|24187
||mov|8,wc|7,xr||save vrblk pointer|24188
||mov|8,wb|10,(xs)+||get trter field|24189
||zer|7,xl|||zero trfpt|24190
||jsr|6,trbld|||build trblk|24191
||mov|7,xl|8,wc||recall vrblk pointer|24192
||mov|13,trter(xr)|13,vrsvp(xl)||store svblk pointer|24193
||mov|13,vrval(xl)|7,xr||store trblk ptr in vrblk|24194
||mov|13,vrget(xl)|22,=b_vra||set trapped access|24195
||mov|13,vrsto(xl)|22,=b_vrv||set trapped store|24196
||exi||||return to caller|24197
||enp||||end procedure inout|24198
||ejc|||||24199
|insta|prc|25,e|1,0||entry point|24378
||mov|8,wc|3,prlen||no. of chars in print bfr|24383
||mov|3,prbuf|7,xr||print bfr is put at static start|24384
||mov|10,(xr)+|22,=b_scl||store string type code|24385
||mov|10,(xr)+|8,wc||and string length|24386
||ctw|8,wc|1,0||get number of words in buffer|24387
||mov|3,prlnw|8,wc||store for buffer clear|24388
||lct|8,wc|8,wc||words to clear|24389
|inst1|mov|10,(xr)+|4,nullw||store blank|24393
||bct|8,wc|6,inst1||loop|24394
||mov|8,wa|18,=nstmx||get max num chars in output number|24398
||ctb|8,wa|2,scsi_||no of bytes needed|24399
||mov|3,gtswk|7,xr||store bfr adrs|24400
||add|7,xr|8,wa||bump for work bfr|24401
||mov|3,kvalp|7,xr||save alphabet pointer|24405
||mov|9,(xr)|22,=b_scl||string blk type|24406
||mov|8,wc|18,=cfp_a||no of chars in alphabet|24407
||mov|13,sclen(xr)|8,wc||store as string length|24408
||mov|8,wb|8,wc||copy char count|24409
||ctb|8,wb|2,scsi_||no. of bytes needed|24410
||add|8,wb|7,xr||current end address for static|24411
||mov|8,wa|8,wb||save adrs past alphabet string|24412
||lct|8,wc|8,wc||loop counter|24413
||psc|7,xr|||point to chars of string|24414
||zer|8,wb|||set initial character value|24415
|inst2|sch|8,wb|10,(xr)+||store next code|24419
||icv|8,wb|||bump code value|24420
||bct|8,wc|6,inst2||loop till all stored|24421
||csc|7,xr|||complete store characters|24422
||mov|7,xr|8,wa||return current static ptr|24423
||exi||||return to caller|24424
||enp||||end procedure insta|24425
||ejc|||||24426
|iofcb|prc|25,n|1,3||entry point|24444
||jsr|6,gtstg|||get arg as string|24446
||ppm|6,iofc2|||fail|24447
||mov|7,xl|7,xr||copy string ptr|24448
||jsr|6,gtnvr|||get as natural variable|24449
||ppm|6,iofc3|||fail if null|24450
||mov|8,wb|7,xl||copy string pointer again|24451
||mov|7,xl|7,xr||copy vrblk ptr for return|24452
||zer|8,wa|||in case no trblk found|24453
|iofc1|mov|7,xr|13,vrval(xr)||get possible trblk ptr|24457
||bne|9,(xr)|22,=b_trt|6,iofc4|fail if end of chain|24458
||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|loop if not file arg trblk|24459
||mov|8,wa|13,trfpt(xr)||get fcblk ptr|24460
||mov|7,xr|8,wb||copy arg|24461
||exi||||return|24462
|iofc2|exi|1,1|||fail|24466
|iofc3|exi|1,2|||null arg return|24470
|iofc4|exi|1,3|||file not found return|24474
||enp||||end procedure iofcb|24475
||ejc|||||24476
|ioppf|prc|25,n|1,0||entry point|24489
||zer|8,wb|||to count fields extracted|24490
|iopp1|mov|7,xl|18,=iodel||get delimiter|24494
||mov|8,wc|7,xl||copy it|24495
||zer|8,wa|||retain leading blanks in filearg2|24496
||jsr|6,xscan|||get next field|24497
||mov|11,-(xs)|7,xr||stack it|24498
||icv|8,wb|||increment count|24499
||bnz|8,wa|6,iopp1||loop|24500
||mov|8,wc|8,wb||count of fields|24501
||mov|8,wb|3,ioptt||i/o marker|24502
||mov|8,wa|3,r_iof||fcblk ptr or 0|24503
||mov|7,xr|3,r_io2||file arg2 ptr|24504
||mov|7,xl|3,r_io1||filearg1|24505
||exi||||return|24506
||enp||||end procedure ioppf|24507
||ejc|||||24508
||ejc|||||24564
|ioput|prc|25,n|1,7||entry point|24588
||zer|3,r_iot|||in case no trtrf block used|24589
||zer|3,r_iof|||in case no fcblk alocated|24590
||zer|3,r_iop|||in case sysio fails|24591
||mov|3,ioptt|8,wb||store i/o trace type|24592
||jsr|6,xscni|||prepare to scan filearg2|24593
||ppm|6,iop13|||fail|24594
||ppm|6,iopa0|||null file arg2|24595
|iopa0|mov|3,r_io2|7,xr||keep file arg2|24597
||mov|7,xl|8,wa||copy length|24598
||jsr|6,gtstg|||convert filearg1 to string|24599
||ppm|6,iop14|||fail|24600
||mov|3,r_io1|7,xr||keep filearg1 ptr|24601
||jsr|6,gtnvr|||convert to natural variable|24602
||ppm|6,iop00|||jump if null|24603
||brn|6,iop04|||jump to process non-null args|24604
|iop00|bze|7,xl|6,iop01||skip if both args null|24608
||jsr|6,ioppf|||process filearg2|24609
||jsr|6,sysfc|||call for filearg2 check|24610
||ppm|6,iop16|||fail|24611
||ppm|6,iop26|||fail|24612
||brn|6,iop11|||complete file association|24613
||ejc|||||24614
|iop01|mov|8,wb|3,ioptt||get trace type|24620
||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24621
||jsr|6,trbld|||build trblk|24622
||mov|8,wc|7,xr||copy trblk pointer|24623
||mov|7,xr|10,(xs)+||get variable from stack|24624
||mov|11,-(xs)|8,wc||make trblk collectable|24625
||jsr|6,gtvar|||point to variable|24626
||ppm|6,iop15|||fail|24627
||mov|8,wc|10,(xs)+||recover trblk pointer|24628
||mov|3,r_ion|7,xl||save name pointer|24629
||mov|7,xr|7,xl||copy name pointer|24630
||add|7,xr|8,wa||point to variable|24631
||sub|7,xr|19,*vrval||subtract offset,merge into loop|24632
|iop02|mov|7,xl|7,xr||copy blk ptr|24636
||mov|7,xr|13,vrval(xr)||load ptr to next trblk|24637
||bne|9,(xr)|22,=b_trt|6,iop03|jump if not trapped|24638
||bne|13,trtyp(xr)|3,ioptt|6,iop02|loop if not same assocn|24639
||mov|7,xr|13,trnxt(xr)||get value and delete old trblk|24640
|iop03|mov|13,vrval(xl)|8,wc||link to this trblk|24646
||mov|7,xl|8,wc||copy pointer|24647
||mov|13,trnxt(xl)|7,xr||store value in trblk|24648
||mov|7,xr|3,r_ion||restore possible vrblk pointer|24649
||mov|8,wb|8,wa||keep offset to name|24650
||jsr|6,setvr|||if vrblk, set vrget,vrsto|24651
||mov|7,xr|3,r_iot||get 0 or trtrf ptr|24652
||bnz|7,xr|6,iop19||jump if trtrf block exists|24653
||exi||||return to caller|24654
|iop04|zer|8,wa|||in case no fcblk found|24659
||ejc|||||24660
|iop05|mov|8,wb|7,xr||remember blk ptr|24666
||mov|7,xr|13,vrval(xr)||chain along|24667
||bne|9,(xr)|22,=b_trt|6,iop06|jump if end of trblk chain|24668
||bne|13,trtyp(xr)|18,=trtfc|6,iop05|loop if more to go|24669
||mov|3,r_iot|7,xr||point to file arg1 trblk|24670
||mov|8,wa|13,trfpt(xr)||get fcblk ptr from trblk|24671
|iop06|mov|3,r_iof|8,wa||keep possible fcblk ptr|24677
||mov|3,r_iop|8,wb||keep preceding blk ptr|24678
||jsr|6,ioppf|||process filearg2|24679
||jsr|6,sysfc|||see if fcblk required|24680
||ppm|6,iop16|||fail|24681
||ppm|6,iop26|||fail|24682
||bze|8,wa|6,iop12||skip if no new fcblk wanted|24683
||blt|8,wc|18,=num02|6,iop6a|jump if fcblk in dynamic|24684
||jsr|6,alost|||get it in static|24685
||brn|6,iop6b|||skip|24686
|iop6a|jsr|6,alloc|||get space for fcblk|24690
|iop6b|mov|7,xl|7,xr||point to fcblk|24694
||mov|8,wb|8,wa||copy its length|24695
||btw|8,wb|||get count as words (sgd apr80)|24696
||lct|8,wb|8,wb||loop counter|24697
|iop07|zer|10,(xr)+|||clear a word|24701
||bct|8,wb|6,iop07||loop|24702
||beq|8,wc|18,=num02|6,iop09|skip if in static - dont set fields|24703
||mov|9,(xl)|22,=b_xnt||store xnblk code in case|24704
||mov|13,num01(xl)|8,wa||store length|24705
||bnz|8,wc|6,iop09||jump if xnblk wanted|24706
||mov|9,(xl)|22,=b_xrt||xrblk code requested|24707
||ejc|||||24709
|iop09|mov|7,xr|3,r_iot||get possible trblk ptr|24714
||mov|3,r_iof|7,xl||store fcblk ptr|24715
||bnz|7,xr|6,iop10||jump if trblk already found|24716
||mov|8,wb|18,=trtfc||trtyp for fcblk trap blk|24720
||jsr|6,trbld|||make the block|24721
||mov|3,r_iot|7,xr||copy trtrf ptr|24722
||mov|7,xl|3,r_iop||point to preceding blk|24723
||mov|13,vrval(xr)|13,vrval(xl)||copy value field to trblk|24724
||mov|13,vrval(xl)|7,xr||link new trblk into chain|24725
||mov|7,xr|7,xl||point to predecessor blk|24726
||jsr|6,setvr|||set trace intercepts|24727
||mov|7,xr|13,vrval(xr)||recover trblk ptr|24728
||brn|6,iop1a|||store fcblk ptr|24729
|iop10|zer|3,r_iop|||do not release if sysio fails|24733
|iop1a|mov|13,trfpt(xr)|3,r_iof||store fcblk ptr|24737
|iop11|mov|8,wa|3,r_iof||copy fcblk ptr or 0|24741
||mov|8,wb|3,ioptt||get input/output flag|24742
||mov|7,xr|3,r_io2||get file arg2|24743
||mov|7,xl|3,r_io1||get file arg1|24744
||jsr|6,sysio|||associate to the file|24745
||ppm|6,iop17|||fail|24746
||ppm|6,iop18|||fail|24747
||bnz|3,r_iot|6,iop01||not std input if non-null trtrf blk|24748
||bnz|3,ioptt|6,iop01||jump if output|24749
||bze|8,wc|6,iop01||no change to standard read length|24750
||mov|3,cswin|8,wc||store new read length for std file|24751
||brn|6,iop01|||merge to finish the task|24752
|iop12|bnz|7,xl|6,iop09||jump if private fcblk|24756
||brn|6,iop11|||finish the association|24757
|iop13|exi|1,1|||3rd arg not a string|24761
|iop14|exi|1,2|||2nd arg unsuitable|24762
|iop15|ica|7,xs|||discard trblk pointer|24763
||exi|1,3|||1st arg unsuitable|24764
|iop16|exi|1,4|||file spec wrong|24765
|iop26|exi|1,7|||fcblk in use|24766
|iop17|mov|7,xr|3,r_iop||is there a trblk to release|24770
||bze|7,xr|6,iopa7||if not|24771
||mov|7,xl|13,vrval(xr)||point to trblk|24772
||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24773
||jsr|6,setvr|||adjust trace intercepts|24774
|iopa7|exi|1,5|||i/o file does not exist|24775
|iop18|mov|7,xr|3,r_iop||is there a trblk to release|24779
||bze|7,xr|6,iopa7||if not|24780
||mov|7,xl|13,vrval(xr)||point to trblk|24781
||mov|13,vrval(xr)|13,vrval(xl)||unsplice it|24782
||jsr|6,setvr|||adjust trace intercepts|24783
|iopa8|exi|1,6|||i/o file cannot be read/written|24784
||ejc|||||24785
|iop19|mov|8,wc|3,r_ion||wc = name base, wb = name offset|24792
|iop20|mov|7,xr|13,trtrf(xr)||next link of chain|24796
||bze|7,xr|6,iop21||not found|24797
||bne|8,wc|13,ionmb(xr)|6,iop20|no match|24798
||beq|8,wb|13,ionmo(xr)|6,iop22|exit if matched|24799
||brn|6,iop20|||loop|24800
|iop21|mov|8,wa|19,*num05||space needed|24804
||jsr|6,alloc|||get it|24805
||mov|9,(xr)|22,=b_xrt||store xrblk code|24806
||mov|13,num01(xr)|8,wa||store length|24807
||mov|13,ionmb(xr)|8,wc||store name base|24808
||mov|13,ionmo(xr)|8,wb||store name offset|24809
||mov|7,xl|3,r_iot||point to trtrf blk|24810
||mov|8,wa|13,trtrf(xl)||get ptr field contents|24811
||mov|13,trtrf(xl)|7,xr||store ptr to new block|24812
||mov|13,trtrf(xr)|8,wa||complete the linking|24813
|iop22|bze|3,r_iof|6,iop25||skip if no fcblk|24817
||mov|7,xl|3,r_fcb||ptr to head of existing chain|24818
|iop23|bze|7,xl|6,iop24||not on if end of chain|24822
||beq|13,num03(xl)|3,r_iof|6,iop25|dont duplicate if find it|24823
||mov|7,xl|13,num02(xl)||get next link|24824
||brn|6,iop23|||loop|24825
|iop24|mov|8,wa|19,*num04||space needed|24829
||jsr|6,alloc|||get it|24830
||mov|9,(xr)|22,=b_xrt||store block code|24831
||mov|13,num01(xr)|8,wa||store length|24832
||mov|13,num02(xr)|3,r_fcb||store previous link in this node|24833
||mov|13,num03(xr)|3,r_iof||store fcblk ptr|24834
||mov|3,r_fcb|7,xr||insert node into fcblk chain|24835
|iop25|exi||||return to caller|24839
||enp||||end procedure ioput|24840
||ejc|||||24841
|ktrex|prc|25,r|1,0||entry point (recursive)|24853
||bze|7,xl|6,ktrx3||immediate exit if keyword untraced|24854
||bze|3,kvtra|6,ktrx3||immediate exit if trace = 0|24855
||dcv|3,kvtra|||else decrement trace|24856
||mov|11,-(xs)|7,xr||save xr|24857
||mov|7,xr|7,xl||copy trblk pointer|24858
||mov|7,xl|13,trkvr(xr)||load vrblk pointer (nmbas)|24859
||mov|8,wa|19,*vrval||set name offset|24860
||bze|13,trfnc(xr)|6,ktrx1||jump if print trace|24861
||jsr|6,trxeq|||else execute full trace|24862
||brn|6,ktrx2|||and jump to exit|24863
|ktrx1|mov|11,-(xs)|7,xl||stack vrblk ptr for kwnam|24867
||mov|11,-(xs)|8,wa||stack offset for kwnam|24868
||jsr|6,prtsn|||print statement number|24869
||mov|8,wa|18,=ch_am||load ampersand|24870
||jsr|6,prtch|||print ampersand|24871
||jsr|6,prtnm|||print keyword name|24872
||mov|7,xr|21,=tmbeb||point to blank-equal-blank|24873
||jsr|6,prtst|||print blank-equal-blank|24874
||jsr|6,kwnam|||get keyword pseudo-variable name|24875
||mov|3,dnamp|7,xr||reset ptr to delete kvblk|24876
||jsr|6,acess|||get keyword value|24877
||ppm||||failure is impossible|24878
||jsr|6,prtvl|||print keyword value|24879
||jsr|6,prtnl|||terminate print line|24880
|ktrx2|mov|7,xr|10,(xs)+||restore entry xr|24884
|ktrx3|exi||||return to ktrex caller|24888
||enp||||end procedure ktrex|24889
||ejc|||||24890
|kwnam|prc|25,n|1,0||entry point|24901
||ica|7,xs|||ignore name offset|24902
||mov|7,xr|10,(xs)+||load name base|24903
||bge|7,xr|3,state|6,kwnm1|jump if not natural variable name|24904
||bnz|13,vrlen(xr)|6,kwnm1||error if not system variable|24905
||mov|7,xr|13,vrsvp(xr)||else point to svblk|24906
||mov|8,wa|13,svbit(xr)||load bit mask|24907
||anb|8,wa|4,btknm||and with keyword bit|24908
||zrb|8,wa|6,kwnm1||error if no keyword association|24909
||mov|8,wa|13,svlen(xr)||else load name length in characters|24910
||ctb|8,wa|2,svchs||compute offset to field we want|24911
||add|7,xr|8,wa||point to svknm field|24912
||mov|8,wb|9,(xr)||load svknm value|24913
||mov|8,wa|19,*kvsi_||set size of kvblk|24914
||jsr|6,alloc|||allocate kvblk|24915
||mov|9,(xr)|22,=b_kvt||store type word|24916
||mov|13,kvnum(xr)|8,wb||store keyword number|24917
||mov|13,kvvar(xr)|21,=trbkv||set dummy trblk pointer|24918
||mov|7,xl|7,xr||copy kvblk pointer|24919
||mov|8,wa|19,*kvvar||set proper offset|24920
||exi||||return to kvnam caller|24921
|kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||24925
||enp||||end procedure kwnam|24926
||ejc|||||24927
|lcomp|prc|25,n|1,5||entry point|24944
||jsr|6,gtstg|||convert second arg to string|24946
||ppm|6,lcmp6|||jump if second arg not string|24950
||mov|7,xl|7,xr||else save pointer|24951
||mov|8,wc|8,wa||and length|24952
||jsr|6,gtstg|||convert first argument to string|24954
||ppm|6,lcmp5|||jump if not string|24958
||mov|8,wb|8,wa||save arg 1 length|24959
||plc|7,xr|||point to chars of arg 1|24960
||plc|7,xl|||point to chars of arg 2|24961
||blo|8,wa|8,wc|6,lcmp1|jump if arg 1 length is smaller|24973
||mov|8,wa|8,wc||else set arg 2 length as smaller|24974
|lcmp1|bze|8,wa|6,lcmp7||if null string, compare lengths|24978
||cmc|6,lcmp4|6,lcmp3||compare strings, jump if unequal|24979
|lcmp7|bne|8,wb|8,wc|6,lcmp2|if equal, jump if lengths unequal|24980
||exi|1,4|||else identical strings, leq exit|24981
||ejc|||||24982
|lcmp2|bhi|8,wb|8,wc|6,lcmp4|jump if arg 1 length gt arg 2 leng|24988
|lcmp3|exi|1,3|||take llt exit|24993
|lcmp4|exi|1,5|||take lgt exit|24997
|lcmp5|exi|1,1|||take bad first arg exit|25001
|lcmp6|exi|1,2|||take bad second arg error exit|25005
||enp||||end procedure lcomp|25006
||ejc|||||25007
|listr|prc|25,e|1,0||entry point|25046
||bnz|3,cnttl|6,list5||jump if -title or -stitl|25047
||bnz|3,lstpf|6,list4||immediate exit if already listed|25048
||bge|3,lstlc|3,lstnp|6,list6|jump if no room|25049
|list0|mov|7,xr|3,r_cim||load pointer to current image|25053
||bze|7,xr|6,list4||jump if no image to print|25054
||plc|7,xr|||point to characters|25055
||lch|8,wa|9,(xr)||load first character|25056
||mov|7,xr|3,lstsn||load statement number|25057
||bze|7,xr|6,list2||jump if no statement number|25058
||mti|7,xr|||else get stmnt number as integer|25059
||bne|3,stage|18,=stgic|6,list1|skip if execute time|25060
||beq|8,wa|18,=ch_as|6,list2|no stmnt number list if comment|25061
||beq|8,wa|18,=ch_mn|6,list2|no stmnt no. if control card|25062
|list1|jsr|6,prtin|||else print statement number|25066
||zer|3,lstsn|||and clear for next time in|25067
|list2|mov|7,xr|3,lstid||include depth of image|25072
||bze|7,xr|6,list8||if not from an include file|25073
||mov|8,wa|18,=stnpd||position for start of statement|25074
||sub|8,wa|18,=num03||position to place include depth|25075
||mov|3,profs|8,wa||set as starting position|25076
||mti|7,xr|||include depth as integer|25077
||jsr|6,prtin|||print include depth|25078
||ejc|||||25079
|list8|mov|3,profs|18,=stnpd||point past statement number|25085
||mov|7,xr|3,r_cim||load pointer to current image|25095
||jsr|6,prtst|||print it|25096
||icv|3,lstlc|||bump line counter|25097
||bnz|3,erlst|6,list3||jump if error copy to int.ch.|25098
||jsr|6,prtnl|||terminate line|25099
||bze|3,cswdb|6,list3||jump if -single mode|25100
||jsr|6,prtnl|||else add a blank line|25101
||icv|3,lstlc|||and bump line counter|25102
|list3|mnz|3,lstpf|||set flag for line printed|25106
|list4|exi||||return to listr caller|25110
|list5|zer|3,cnttl|||clear flag|25114
|list6|jsr|6,prtps|||eject|25118
||bze|3,prich|6,list7||skip if listing to regular printer|25119
||beq|3,r_ttl|21,=nulls|6,list0|terminal listing omits null title|25120
|list7|jsr|6,listt|||list title|25124
||brn|6,list0|||merge|25125
||enp||||end procedure listr|25126
||ejc|||||25127
|listt|prc|25,e|1,0||entry point|25136
||mov|7,xr|3,r_ttl||point to source listing title|25137
||jsr|6,prtst|||print title|25138
||mov|3,profs|3,lstpo||set offset|25139
||mov|7,xr|21,=lstms||set page message|25140
||jsr|6,prtst|||print page message|25141
||icv|3,lstpg|||bump page number|25142
||mti|3,lstpg|||load page number as integer|25143
||jsr|6,prtin|||print page number|25144
||jsr|6,prtnl|||terminate title line|25145
||add|3,lstlc|18,=num02||count title line and blank line|25146
||mov|7,xr|3,r_stl||load pointer to sub-title|25150
||bze|7,xr|6,lstt1||jump if no sub-title|25151
||jsr|6,prtst|||else print sub-title|25152
||jsr|6,prtnl|||terminate line|25153
||icv|3,lstlc|||bump line count|25154
|lstt1|jsr|6,prtnl|||print a blank line|25158
||exi||||return to caller|25159
||enp||||end procedure listt|25160
||ejc|||||25161
|newfn|prc|25,e|1,0||entry point|25178
||mov|11,-(xs)|7,xr||save new name|25179
||mov|7,xl|3,r_sfc||load previous name|25180
||jsr|6,ident|||check for equality|25181
||ppm|6,nwfn1|||jump if identical|25182
||mov|7,xr|10,(xs)+||different, restore name|25183
||mov|3,r_sfc|7,xr||record current file name|25184
||mov|8,wb|3,cmpsn||get current statement|25185
||mti|8,wb|||convert to integer|25186
||jsr|6,icbld|||build icblk for stmt number|25187
||mov|7,xl|3,r_sfn||file name table|25188
||mnz|8,wb|||lookup statement number by name|25189
||jsr|6,tfind|||allocate new teblk|25190
||ppm||||always possible to allocate block|25191
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|25192
||exi|||||25193
|nwfn1|ica|7,xs|||pop stack|25197
||exi|||||25198
||ejc|||||25199
|nexts|prc|25,e|1,0||entry point|25231
||bze|3,cswls|6,nxts2||jump if -nolist|25232
||mov|7,xr|3,r_cim||point to image|25233
||bze|7,xr|6,nxts2||jump if no image|25234
||plc|7,xr|||get char ptr|25235
||lch|8,wa|9,(xr)||get first char|25236
||bne|8,wa|18,=ch_mn|6,nxts1|jump if not ctrl card|25237
||bze|3,cswpr|6,nxts2||jump if -noprint|25238
|nxts1|jsr|6,listr|||list line|25242
|nxts2|mov|7,xr|3,r_cni||point to next image|25246
||mov|3,r_cim|7,xr||set as next image|25247
||mov|3,rdcln|3,rdnln||set as current line number|25248
||mov|3,lstid|3,cnind||set as current include depth|25250
||zer|3,r_cni|||clear next image pointer|25252
||mov|8,wa|13,sclen(xr)||get input image length|25253
||mov|8,wb|3,cswin||get max allowable length|25254
||blo|8,wa|8,wb|6,nxts3|skip if not too long|25255
||mov|8,wa|8,wb||else truncate|25256
|nxts3|mov|3,scnil|8,wa||use as record length|25260
||zer|3,scnse|||reset scnse|25261
||zer|3,lstpf|||set line not listed yet|25262
||exi||||return to nexts caller|25263
||enp||||end procedure nexts|25264
||ejc|||||25265
|patin|prc|25,n|1,2||entry point|25281
||mov|7,xl|8,wa||preserve expression arg pcode|25282
||jsr|6,gtsmi|||try to convert arg as small integer|25283
||ppm|6,ptin2|||jump if not integer|25284
||ppm|6,ptin3|||jump if out of range|25285
|ptin1|jsr|6,pbild|||build pattern node|25289
||exi||||return to caller|25290
|ptin2|mov|8,wb|7,xl||copy expr arg case pcode|25294
||blo|9,(xr)|22,=b_e__|6,ptin1|all ok if expression arg|25295
||exi|1,1|||else take error exit for wrong type|25296
|ptin3|exi|1,2|||take out-of-range error exit|25300
||enp||||end procedure patin|25301
||ejc|||||25302
|patst|prc|25,n|1,1||entry point|25326
||jsr|6,gtstg|||convert argument as string|25327
||ppm|6,pats7|||jump if not string|25328
||bze|8,wa|6,pats7||jump if null string (catspaw)|25329
||bne|8,wa|18,=num01|6,pats2|jump if not one char string|25330
||bze|8,wb|6,pats2||treat as multi-char if evals call|25334
||plc|7,xr|||point to character|25335
||lch|7,xr|9,(xr)||load character|25336
|pats1|jsr|6,pbild|||call routine to build node|25340
||exi||||return to patst caller|25341
||ejc|||||25342
|pats2|mov|11,-(xs)|7,xl||save multi-char pcode|25348
||mov|8,wc|3,ctmsk||load current mask bit|25349
||beq|7,xr|3,r_cts|6,pats6|jump if same as last string c3.738|25350
||mov|11,-(xs)|7,xr||save string pointer|25351
||lsh|8,wc|1,1||shift to next position|25352
||nzb|8,wc|6,pats4||skip if position left in this tbl|25353
||mov|8,wa|19,*ctsi_||set size of ctblk|25357
||jsr|6,alloc|||allocate ctblk|25358
||mov|3,r_ctp|7,xr||store ptr to new ctblk|25359
||mov|10,(xr)+|22,=b_ctt||store type code, bump ptr|25360
||lct|8,wb|18,=cfp_a||set number of words to clear|25361
||mov|8,wc|4,bits0||load all zero bits|25362
|pats3|mov|10,(xr)+|8,wc||move word of zero bits|25366
||bct|8,wb|6,pats3||loop till all cleared|25367
||mov|8,wc|4,bits1||set initial bit position|25368
|pats4|mov|3,ctmsk|8,wc||save parm2 (new bit position)|25372
||mov|7,xl|10,(xs)+||restore pointer to argument string|25373
||mov|3,r_cts|7,xl||save for next time   c3.738|25374
||mov|8,wb|13,sclen(xl)||load string length|25375
||bze|8,wb|6,pats6||jump if null string case|25376
||lct|8,wb|8,wb||else set loop counter|25377
||plc|7,xl|||point to characters in argument|25378
||ejc|||||25379
|pats5|lch|8,wa|10,(xl)+||load next character|25385
||wtb|8,wa|||convert to byte offset|25386
||mov|7,xr|3,r_ctp||point to ctblk|25387
||add|7,xr|8,wa||point to ctblk entry|25388
||mov|8,wa|8,wc||copy bit mask|25389
||orb|8,wa|13,ctchs(xr)||or in bits already set|25390
||mov|13,ctchs(xr)|8,wa||store resulting bit string|25391
||bct|8,wb|6,pats5||loop till all bits set|25392
|pats6|mov|7,xr|3,r_ctp||load ctblk ptr as parm1 for pbild|25396
||zer|7,xl|||clear garbage ptr in xl|25397
||mov|8,wb|10,(xs)+||load pcode for multi-char str case|25398
||brn|6,pats1|||back to exit (wc=bitstring=parm2)|25399
|pats7|mov|8,wb|8,wc||set pcode for expression argument|25406
||blo|9,(xr)|22,=b_e__|6,pats1|jump to exit if expression arg|25407
||exi|1,1|||else take wrong type error exit|25408
||enp||||end procedure patst|25409
||ejc|||||25410
|pbild|prc|25,e|1,0||entry point|25421
||mov|11,-(xs)|7,xr||stack possible parm1|25422
||mov|7,xr|8,wb||copy pcode|25423
||lei|7,xr|||load entry point id (bl_px)|25424
||beq|7,xr|18,=bl_p1|6,pbld1|jump if one parameter|25425
||beq|7,xr|18,=bl_p0|6,pbld3|jump if no parameters|25426
||mov|8,wa|19,*pcsi_||set size of p2blk|25430
||jsr|6,alloc|||allocate block|25431
||mov|13,parm2(xr)|8,wc||store second parameter|25432
||brn|6,pbld2|||merge with one parm case|25433
|pbld1|mov|8,wa|19,*pbsi_||set size of p1blk|25437
||jsr|6,alloc|||allocate node|25438
|pbld2|mov|13,parm1(xr)|9,(xs)||store first parameter|25442
||brn|6,pbld4|||merge with no parameter case|25443
|pbld3|mov|8,wa|19,*pasi_||set size of p0blk|25447
||jsr|6,alloc|||allocate node|25448
|pbld4|mov|9,(xr)|8,wb||store pcode|25452
||ica|7,xs|||pop first parameter|25453
||mov|13,pthen(xr)|21,=ndnth||set nothen successor pointer|25454
||exi||||return to pbild caller|25455
||enp||||end procedure pbild|25456
||ejc|||||25457
|pconc|prc|25,e|1,0||entry point|25492
||zer|11,-(xs)|||make room for one entry at bottom|25493
||mov|8,wc|7,xs||store pointer to start of list|25494
||mov|11,-(xs)|21,=ndnth||stack nothen node as old node|25495
||mov|11,-(xs)|7,xl||store right arg as copy of nothen|25496
||mov|7,xt|7,xs||initialize pointer to stack entries|25497
||jsr|6,pcopy|||copy first node of left arg|25498
||mov|13,num02(xt)|8,wa||store as result under list|25499
||ejc|||||25500
|pcnc1|beq|7,xt|7,xs|6,pcnc2|jump if all entries processed|25507
||mov|7,xr|11,-(xt)||else load next old address|25508
||mov|7,xr|13,pthen(xr)||load pointer to successor|25509
||jsr|6,pcopy|||copy successor node|25510
||mov|7,xr|11,-(xt)||load pointer to new node (copy)|25511
||mov|13,pthen(xr)|8,wa||store ptr to new successor|25512
||bne|9,(xr)|22,=p_alt|6,pcnc1|loop back if not|25517
||mov|7,xr|13,parm1(xr)||else load pointer to alternative|25518
||jsr|6,pcopy|||copy it|25519
||mov|7,xr|9,(xt)||restore ptr to new node|25520
||mov|13,parm1(xr)|8,wa||store ptr to copied alternative|25521
||brn|6,pcnc1|||loop back for next entry|25522
|pcnc2|mov|7,xs|8,wc||restore stack pointer|25526
||mov|7,xr|10,(xs)+||load pointer to copy|25527
||exi||||return to pconc caller|25528
||enp||||end procedure pconc|25529
||ejc|||||25530
|pcopy|prc|25,n|1,0||entry point|25545
||mov|8,wb|7,xt||save xt|25546
||mov|7,xt|8,wc||point to start of list|25547
|pcop1|dca|7,xt|||point to next entry on list|25551
||beq|7,xr|9,(xt)|6,pcop2|jump if match|25552
||dca|7,xt|||else skip over copied address|25553
||bne|7,xt|7,xs|6,pcop1|loop back if more to test|25554
||mov|8,wa|9,(xr)||load first word of block|25558
||jsr|6,blkln|||get length of block|25559
||mov|7,xl|7,xr||save pointer to old node|25560
||jsr|6,alloc|||allocate space for copy|25561
||mov|11,-(xs)|7,xl||store old address on list|25562
||mov|11,-(xs)|7,xr||store new address on list|25563
||chk||||check for stack overflow|25564
||mvw||||move words from old block to copy|25565
||mov|8,wa|9,(xs)||load pointer to copy|25566
||brn|6,pcop3|||jump to exit|25567
|pcop2|mov|8,wa|11,-(xt)||load address of copy from list|25571
|pcop3|mov|7,xt|8,wb||restore xt|25575
||exi||||return to pcopy caller|25576
||enp||||end procedure pcopy|25577
||ejc|||||25578
|prflr|prc|25,e|1,0|||25589
||bze|3,pfdmp|6,prfl4||no printing if no profiling done|25590
||mov|11,-(xs)|7,xr||preserve entry xr|25591
||mov|3,pfsvw|8,wb||and also wb|25592
||jsr|6,prtpg|||eject|25593
||mov|7,xr|21,=pfms1||load msg /program profile/|25594
||jsr|6,prtst|||and print it|25595
||jsr|6,prtnl|||followed by newline|25596
||jsr|6,prtnl|||and another|25597
||mov|7,xr|21,=pfms2||point to first hdr|25598
||jsr|6,prtst|||print it|25599
||jsr|6,prtnl|||new line|25600
||mov|7,xr|21,=pfms3||second hdr|25601
||jsr|6,prtst|||print it|25602
||jsr|6,prtnl|||new line|25603
||jsr|6,prtnl|||and another blank line|25604
||zer|8,wb|||initial stmt count|25605
||mov|7,xr|3,pftbl||point to table origin|25606
||add|7,xr|19,*xndta||bias past xnblk header (sgd07)|25607
|prfl1|icv|8,wb|||bump stmt nr|25611
||ldi|9,(xr)|||load nr of executions|25612
||ieq|6,prfl3|||no printing if zero|25613
||mov|3,profs|18,=pfpd1||point where to print|25614
||jsr|6,prtin|||and print it|25615
||zer|3,profs|||back to start of line|25616
||mti|8,wb|||load stmt nr|25617
||jsr|6,prtin|||print it there|25618
||mov|3,profs|18,=pfpd2||and pad past count|25619
||ldi|13,cfp_i(xr)|||load total exec time|25620
||jsr|6,prtin|||print that too|25621
||ldi|13,cfp_i(xr)|||reload time|25622
||mli|4,intth|||convert to microsec|25623
||iov|6,prfl2|||omit next bit if overflow|25624
||dvi|9,(xr)|||divide by executions|25625
||mov|3,profs|18,=pfpd3||pad last print|25626
||jsr|6,prtin|||and print mcsec/execn|25627
|prfl2|jsr|6,prtnl|||thats another line|25631
|prfl3|add|7,xr|19,*pf_i2||bump index ptr (sgd07)|25635
||blt|8,wb|3,pfnte|6,prfl1|loop if more stmts|25636
||mov|7,xr|10,(xs)+||restore callers xr|25637
||mov|8,wb|3,pfsvw||and wb too|25638
|prfl4|exi||||return|25642
||enp||||end of prflr|25643
||ejc|||||25644
|prflu|prc|25,e|1,0|||25653
||bnz|3,pffnc|6,pflu4||skip if just entered function|25654
||mov|11,-(xs)|7,xr||preserve entry xr|25655
||mov|3,pfsvw|8,wa||save wa (sgd07)|25656
||bnz|3,pftbl|6,pflu2||branch if table allocated|25657
||sub|3,pfnte|18,=num01||adjust for extra count (sgd07)|25667
||mti|4,pfi2a|||convrt entry size to int|25668
||sti|3,pfste|||and store safely for later|25669
||mti|3,pfnte|||load table length as integer|25670
||mli|3,pfste|||multiply by entry size|25671
||mfi|8,wa|||get back address-style|25672
||add|8,wa|18,=num02||add on 2 word overhead|25673
||wtb|8,wa|||convert the whole lot to bytes|25674
||jsr|6,alost|||gimme the space|25675
||mov|3,pftbl|7,xr||save block pointer|25676
||mov|10,(xr)+|22,=b_xnt||put block type and ...|25677
||mov|10,(xr)+|8,wa||... length into header|25678
||mfi|8,wa|||get back nr of wds in data area|25679
||lct|8,wa|8,wa||load the counter|25680
|pflu1|zer|10,(xr)+|||blank a word|25684
||bct|8,wa|6,pflu1||and alllllll the rest|25685
|pflu2|mti|3,kvstn|||load nr of stmt just ended|25689
||sbi|4,intv1|||make into index offset|25690
||mli|3,pfste|||make offset of table entry|25691
||mfi|8,wa|||convert to address|25692
||wtb|8,wa|||get as baus|25693
||add|8,wa|19,*num02||offset includes table header|25694
||mov|7,xr|3,pftbl||get table start|25695
||bge|8,wa|13,num01(xr)|6,pflu3|if out of table, skip it|25696
||add|7,xr|8,wa||else point to entry|25697
||ldi|9,(xr)|||get nr of executions so far|25698
||adi|4,intv1|||nudge up one|25699
||sti|9,(xr)|||and put back|25700
||jsr|6,systm|||get time now|25701
||sti|3,pfetm|||stash ending time|25702
||sbi|3,pfstm|||subtract start time|25703
||adi|13,cfp_i(xr)|||add cumulative time so far|25704
||sti|13,cfp_i(xr)|||and put back new total|25705
||ldi|3,pfetm|||load end time of this stmt ...|25706
||sti|3,pfstm|||... which is start time of next|25707
|pflu3|mov|7,xr|10,(xs)+||restore callers xr|25711
||mov|8,wa|3,pfsvw||restore saved reg|25712
||exi||||and return|25713
|pflu4|zer|3,pffnc|||reset the condition flag|25719
||exi||||and immediate return|25720
||enp||||end of procedure prflu|25721
||ejc|||||25722
|prpar|prc|25,e|1,0||entry point|25735
||bnz|8,wc|6,prpa8||jump to associate terminal|25736
||jsr|6,syspp|||get print parameters|25737
||bnz|8,wb|6,prpa1||jump if lines/page specified|25738
||mov|8,wb|3,mxint||else use a large value|25739
||rsh|8,wb|1,1||but not too large|25740
|prpa1|mov|3,lstnp|8,wb||store number of lines/page|25744
||mov|3,lstlc|8,wb||pretend page is full initially|25745
||zer|3,lstpg|||clear page number|25746
||mov|8,wb|3,prlen||get prior length if any|25747
||bze|8,wb|6,prpa2||skip if no length|25748
||bgt|8,wa|8,wb|6,prpa3|skip storing if too big|25749
|prpa2|mov|3,prlen|8,wa||store value|25753
|prpa3|mov|8,wb|4,bits3||bit 3 mask|25757
||anb|8,wb|8,wc||get -nolist bit|25758
||zrb|8,wb|6,prpa4||skip if clear|25759
||zer|3,cswls|||set -nolist|25760
|prpa4|mov|8,wb|4,bits1||bit 1 mask|25764
||anb|8,wb|8,wc||get bit|25765
||mov|3,erich|8,wb||store int. chan. error flag|25766
||mov|8,wb|4,bits2||bit 2 mask|25767
||anb|8,wb|8,wc||get bit|25768
||mov|3,prich|8,wb||flag for std printer on int. chan.|25769
||mov|8,wb|4,bits4||bit 4 mask|25770
||anb|8,wb|8,wc||get bit|25771
||mov|3,cpsts|8,wb||flag for compile stats suppressn.|25772
||mov|8,wb|4,bits5||bit 5 mask|25773
||anb|8,wb|8,wc||get bit|25774
||mov|3,exsts|8,wb||flag for exec stats suppression|25775
||ejc|||||25776
||mov|8,wb|4,bits6||bit 6 mask|25780
||anb|8,wb|8,wc||get bit|25781
||mov|3,precl|8,wb||extended/compact listing flag|25782
||sub|8,wa|18,=num08||point 8 chars from line end|25783
||zrb|8,wb|6,prpa5||jump if not extended|25784
||mov|3,lstpo|8,wa||store for listing page headings|25785
|prpa5|mov|8,wb|4,bits7||bit 7 mask|25789
||anb|8,wb|8,wc||get bit 7|25790
||mov|3,cswex|8,wb||set -noexecute if non-zero|25791
||mov|8,wb|4,bit10||bit 10 mask|25792
||anb|8,wb|8,wc||get bit 10|25793
||mov|3,headp|8,wb||pretend printed to omit headers|25794
||mov|8,wb|4,bits9||bit 9 mask|25795
||anb|8,wb|8,wc||get bit 9|25796
||mov|3,prsto|8,wb||keep it as std listing option|25797
||mov|8,wb|4,bit12||bit 12 mask|25804
||anb|8,wb|8,wc||get bit 12|25805
||mov|3,cswer|8,wb||keep it as errors/noerrors option|25806
||zrb|8,wb|6,prpa6||skip if clear|25807
||mov|8,wa|3,prlen||get print buffer length|25808
||sub|8,wa|18,=num08||point 8 chars from line end|25809
||mov|3,lstpo|8,wa||store page offset|25810
|prpa6|mov|8,wb|4,bit11||bit 11 mask|25814
||anb|8,wb|8,wc||get bit 11|25815
||mov|3,cswpr|8,wb||set -print if non-zero|25816
||anb|8,wc|4,bits8||see if terminal to be activated|25820
||bnz|8,wc|6,prpa8||jump if terminal required|25821
||bze|3,initr|6,prpa9||jump if no terminal to detach|25822
||mov|7,xl|21,=v_ter||ptr to /terminal/|25823
||jsr|6,gtnvr|||get vrblk pointer|25824
||ppm||||cant fail|25825
||mov|13,vrval(xr)|21,=nulls||clear value of terminal|25826
||jsr|6,setvr|||remove association|25827
||brn|6,prpa9|||return|25828
|prpa8|mnz|3,initr|||note terminal associated|25832
||bze|3,dnamb|6,prpa9||cant if memory not organised|25833
||mov|7,xl|21,=v_ter||point to terminal string|25834
||mov|8,wb|18,=trtou||output trace type|25835
||jsr|6,inout|||attach output trblk to vrblk|25836
||mov|11,-(xs)|7,xr||stack trblk ptr|25837
||mov|7,xl|21,=v_ter||point to terminal string|25838
||mov|8,wb|18,=trtin||input trace type|25839
||jsr|6,inout|||attach input trace blk|25840
||mov|13,vrval(xr)|10,(xs)+||add output trblk to chain|25841
|prpa9|exi||||return|25845
||enp||||end procedure prpar|25846
||ejc|||||25847
|prtch|prc|25,e|1,0||entry point|25856
||mov|11,-(xs)|7,xr||save xr|25857
||bne|3,profs|3,prlen|6,prch1|jump if room in buffer|25858
||jsr|6,prtnl|||else print this line|25859
|prch1|mov|7,xr|3,prbuf||point to print buffer|25863
||psc|7,xr|3,profs||point to next character location|25864
||sch|8,wa|9,(xr)||store new character|25865
||csc|7,xr|||complete store characters|25866
||icv|3,profs|||bump pointer|25867
||mov|7,xr|10,(xs)+||restore entry xr|25868
||exi||||return to prtch caller|25869
||enp||||end procedure prtch|25870
||ejc|||||25871
|prtic|prc|25,e|1,0||entry point|25883
||mov|11,-(xs)|7,xr||save xr|25884
||mov|7,xr|3,prbuf||point to buffer|25885
||mov|8,wa|3,profs||no of chars|25886
||jsr|6,syspi|||print|25887
||ppm|6,prtc2|||fail return|25888
|prtc1|mov|7,xr|10,(xs)+||restore xr|25892
||exi||||return|25893
|prtc2|zer|3,erich|||prevent looping|25897
||erb|1,252|26,error on printing to interactive channel|||25898
||brn|6,prtc1|||return|25899
||enp||||procedure prtic|25900
||ejc|||||25901
|prtis|prc|25,e|1,0||entry point|25914
||bnz|3,prich|6,prts1||jump if standard printer is int.ch.|25915
||bze|3,erich|6,prts1||skip if not doing int. error reps.|25916
||jsr|6,prtic|||print to interactive channel|25917
|prts1|jsr|6,prtnl|||print to standard printer|25921
||exi||||return|25922
||enp||||end procedure prtis|25923
||ejc|||||25924
|prtin|prc|25,e|1,0||entry point|25936
||mov|11,-(xs)|7,xr||save xr|25937
||jsr|6,icbld|||build integer block|25938
||blo|7,xr|3,dnamb|6,prti1|jump if icblk below dynamic|25939
||bhi|7,xr|3,dnamp|6,prti1|jump if above dynamic|25940
||mov|3,dnamp|7,xr||immediately delete it|25941
|prti1|mov|11,-(xs)|7,xr||stack ptr for gtstg|25945
||jsr|6,gtstg|||convert to string|25946
||ppm||||convert error is impossible|25947
||mov|3,dnamp|7,xr||reset pointer to delete scblk|25948
||jsr|6,prtst|||print integer string|25949
||mov|7,xr|10,(xs)+||restore entry xr|25950
||exi||||return to prtin caller|25951
||enp||||end procedure prtin|25952
||ejc|||||25953
|prtmi|prc|25,e|1,0||entry point|25963
||jsr|6,prtst|||print string message|25964
||mov|3,profs|18,=prtmf||set column offset|25965
||jsr|6,prtin|||print integer|25966
||jsr|6,prtnl|||print line|25967
||exi||||return to prtmi caller|25968
||enp||||end procedure prtmi|25969
||ejc|||||25970
|prtmm|prc|25,e|1,0|||25979
||mov|8,wa|3,dnamp||next available loc|25980
||sub|8,wa|3,statb||minus start|25981
||mti|8,wa|||convert to integer|25986
||mov|7,xr|21,=encm1||point to /memory used (words)/|25987
||jsr|6,prtmi|||print message|25988
||mov|8,wa|3,dname||end of memory|25989
||sub|8,wa|3,dnamp||minus next available loc|25990
||mti|8,wa|||convert to integer|25995
||mov|7,xr|21,=encm2||point to /memory available (words)/|25996
||jsr|6,prtmi|||print line|25997
||exi||||return to prtmm caller|25998
||enp||||end of procedure prtmm|25999
||ejc|||||26000
|prtmx|prc|25,e|1,0||entry point|26007
||jsr|6,prtst|||print string message|26008
||mov|3,profs|18,=prtmf||set column offset|26009
||jsr|6,prtin|||print integer|26010
||jsr|6,prtis|||print line|26011
||exi||||return|26012
||enp||||end procedure prtmx|26013
||ejc|||||26014
|prtnl|prc|25,r|1,0||entry point|26023
||bnz|3,headp|6,prnl0||were headers printed|26024
||jsr|6,prtps|||no - print them|26025
|prnl0|mov|11,-(xs)|7,xr||save entry xr|26029
||mov|3,prtsa|8,wa||save wa|26030
||mov|3,prtsb|8,wb||save wb|26031
||mov|7,xr|3,prbuf||load pointer to buffer|26032
||mov|8,wa|3,profs||load number of chars in buffer|26033
||jsr|6,syspr|||call system print routine|26034
||ppm|6,prnl2|||jump if failed|26035
||lct|8,wa|3,prlnw||load length of buffer in words|26036
||add|7,xr|19,*schar||point to chars of buffer|26037
||mov|8,wb|4,nullw||get word of blanks|26038
|prnl1|mov|10,(xr)+|8,wb||store word of blanks, bump ptr|26042
||bct|8,wa|6,prnl1||loop till all blanked|26043
||mov|8,wb|3,prtsb||restore wb|26047
||mov|8,wa|3,prtsa||restore wa|26048
||mov|7,xr|10,(xs)+||restore entry xr|26049
||zer|3,profs|||reset print buffer pointer|26050
||exi||||return to prtnl caller|26051
|prnl2|bnz|3,prtef|6,prnl3||jump if not first time|26055
||mnz|3,prtef|||mark first occurrence|26056
||erb|1,253|26,print limit exceeded on standard output channel|||26057
|prnl3|mov|8,wb|18,=nini8||ending code|26061
||mov|8,wa|3,kvstn||statement number|26062
||mov|7,xl|3,r_fcb||get fcblk chain head|26063
||jsr|6,sysej|||stop|26064
||enp||||end procedure prtnl|26065
||ejc|||||26066
|prtnm|prc|25,r|1,0||entry point (recursive, see prtvl)|26079
||mov|11,-(xs)|8,wa||save wa (offset is collectable)|26080
||mov|11,-(xs)|7,xr||save entry xr|26081
||mov|11,-(xs)|7,xl||save name base|26082
||bhi|7,xl|3,state|6,prn02|jump if not natural variable|26083
||mov|7,xr|7,xl||point to vrblk|26088
||jsr|6,prtvn|||print name of variable|26089
|prn01|mov|7,xl|10,(xs)+||restore name base|26093
||mov|7,xr|10,(xs)+||restore entry value of xr|26094
||mov|8,wa|10,(xs)+||restore wa|26095
||exi||||return to prtnm caller|26096
|prn02|mov|8,wb|8,wa||copy name offset|26100
||bne|9,(xl)|22,=b_pdt|6,prn03|jump if array or table|26101
||mov|7,xr|13,pddfp(xl)||load pointer to dfblk|26105
||add|7,xr|8,wa||add name offset|26106
||mov|7,xr|13,pdfof(xr)||load vrblk pointer for field|26107
||jsr|6,prtvn|||print field name|26108
||mov|8,wa|18,=ch_pp||load left paren|26109
||jsr|6,prtch|||print character|26110
||ejc|||||26111
|prn03|bne|9,(xl)|22,=b_tet|6,prn04|jump if we got there (or not te)|26124
||mov|7,xl|13,tenxt(xl)||else move out on chain|26125
||brn|6,prn03|||and loop back|26126
|prn04|mov|7,xr|3,prnmv||point to vrblk we found last time|26134
||mov|8,wa|3,hshtb||point to hash table in case not|26135
||brn|6,prn07|||jump into search for special check|26136
|prn05|mov|7,xr|8,wa||copy slot pointer|26140
||ica|8,wa|||bump slot pointer|26141
||sub|7,xr|19,*vrnxt||introduce standard vrblk offset|26142
|prn06|mov|7,xr|13,vrnxt(xr)||point to next vrblk on hash chain|26146
|prn07|mov|8,wc|7,xr||copy vrblk pointer|26150
||bze|8,wc|6,prn09||jump if chain end (or prnmv zero)|26151
||ejc|||||26152
|prn08|mov|7,xr|13,vrval(xr)||load value|26158
||beq|9,(xr)|22,=b_trt|6,prn08|loop if that was a trblk|26159
||beq|7,xr|7,xl|6,prn10|jump if this matches the name base|26163
||mov|7,xr|8,wc||else point back to that vrblk|26164
||brn|6,prn06|||and loop back|26165
|prn09|blt|8,wa|3,hshte|6,prn05|loop back if more to go|26169
||mov|7,xr|7,xl||else not found, copy value pointer|26170
||jsr|6,prtvl|||print value|26171
||brn|6,prn11|||and merge ahead|26172
|prn10|mov|7,xr|8,wc||copy vrblk pointer|26176
||mov|3,prnmv|7,xr||save for next time in|26177
||jsr|6,prtvn|||print variable name|26178
|prn11|mov|8,wc|9,(xl)||load first word of name base|26182
||bne|8,wc|22,=b_pdt|6,prn13|jump if not program defined|26183
||mov|8,wa|18,=ch_rp||load right paren, merge|26187
|prn12|jsr|6,prtch|||print final character|26191
||mov|8,wa|8,wb||restore name offset|26192
||brn|6,prn01|||merge back to exit|26193
||ejc|||||26194
|prn13|mov|8,wa|18,=ch_bb||load left bracket|26200
||jsr|6,prtch|||and print it|26201
||mov|7,xl|9,(xs)||restore block pointer|26202
||mov|8,wc|9,(xl)||load type word again|26203
||bne|8,wc|22,=b_tet|6,prn15|jump if not table|26204
||mov|7,xr|13,tesub(xl)||load subscript value|26208
||mov|7,xl|8,wb||save name offset|26209
||jsr|6,prtvl|||print subscript value|26210
||mov|8,wb|7,xl||restore name offset|26211
|prn14|mov|8,wa|18,=ch_rb||load right bracket|26215
||brn|6,prn12|||merge back to print it|26216
|prn15|mov|8,wa|8,wb||copy name offset|26220
||btw|8,wa|||convert to words|26221
||beq|8,wc|22,=b_art|6,prn16|jump if arblk|26222
||sub|8,wa|18,=vcvlb||adjust for standard fields|26226
||mti|8,wa|||move to integer accum|26227
||jsr|6,prtin|||print linear subscript|26228
||brn|6,prn14|||merge back for right bracket|26229
||ejc|||||26230
|prn16|mov|8,wc|13,arofs(xl)||load length of bounds info|26239
||ica|8,wc|||adjust for arpro field|26240
||btw|8,wc|||convert to words|26241
||sub|8,wa|8,wc||get linear zero-origin subscript|26242
||mti|8,wa|||get integer value|26243
||lct|8,wa|13,arndm(xl)||set num of dimensions as loop count|26244
||add|7,xl|13,arofs(xl)||point past bounds information|26245
||sub|7,xl|19,*arlbd||set ok offset for proper ptr later|26246
|prn17|sub|7,xl|19,*ardms||point to next set of bounds|26250
||sti|3,prnsi|||save current offset|26251
||rmi|13,ardim(xl)|||get remainder on dividing by dimens|26252
||mfi|11,-(xs)|||store on stack (one word)|26253
||ldi|3,prnsi|||reload argument|26254
||dvi|13,ardim(xl)|||divide to get quotient|26255
||bct|8,wa|6,prn17||loop till all stacked|26256
||zer|7,xr|||set offset to first set of bounds|26257
||lct|8,wb|13,arndm(xl)||load count of dims to control loop|26258
||brn|6,prn19|||jump into print loop|26259
|prn18|mov|8,wa|18,=ch_cm||load a comma|26264
||jsr|6,prtch|||print it|26265
|prn19|mti|10,(xs)+|||load subscript offset as integer|26269
||add|7,xl|7,xr||point to current lbd|26270
||adi|13,arlbd(xl)|||add lbd to get signed subscript|26271
||sub|7,xl|7,xr||point back to start of arblk|26272
||jsr|6,prtin|||print subscript|26273
||add|7,xr|19,*ardms||bump offset to next bounds|26274
||bct|8,wb|6,prn18||loop back till all printed|26275
||brn|6,prn14|||merge back to print right bracket|26276
||enp||||end procedure prtnm|26277
||ejc|||||26278
|prtnv|prc|25,e|1,0||entry point|26294
||jsr|6,prtnm|||print argument name|26295
||mov|11,-(xs)|7,xr||save entry xr|26296
||mov|11,-(xs)|8,wa||save name offset (collectable)|26297
||mov|7,xr|21,=tmbeb||point to blank equal blank|26298
||jsr|6,prtst|||print it|26299
||mov|7,xr|7,xl||copy name base|26300
||add|7,xr|8,wa||point to value|26301
||mov|7,xr|9,(xr)||load value pointer|26302
||jsr|6,prtvl|||print value|26303
||jsr|6,prtnl|||terminate line|26304
||mov|8,wa|10,(xs)+||restore name offset|26305
||mov|7,xr|10,(xs)+||restore entry xr|26306
||exi||||return to caller|26307
||enp||||end procedure prtnv|26308
||ejc|||||26309
|prtpg|prc|25,e|1,0||entry point|26318
||beq|3,stage|18,=stgxt|6,prp01|jump if execution time|26319
||bze|3,lstlc|6,prp06||return if top of page already|26320
||zer|3,lstlc|||clear line count|26321
|prp01|mov|11,-(xs)|7,xr||preserve xr|26325
||bnz|3,prstd|6,prp02||eject if flag set|26326
||bnz|3,prich|6,prp03||jump if interactive listing channel|26327
||bze|3,precl|6,prp03||jump if compact listing|26328
|prp02|jsr|6,sysep|||eject|26332
||brn|6,prp04|||merge|26333
|prp03|mov|7,xr|3,headp||remember headp|26339
||mnz|3,headp|||set to avoid repeated prtpg calls|26340
||jsr|6,prtnl|||print blank line|26341
||jsr|6,prtnl|||print blank line|26342
||jsr|6,prtnl|||print blank line|26343
||mov|3,lstlc|18,=num03||count blank lines|26344
||mov|3,headp|7,xr||restore header flag|26345
||ejc|||||26346
|prp04|bnz|3,headp|6,prp05||jump if header listed|26352
||mnz|3,headp|||mark headers printed|26353
||mov|11,-(xs)|7,xl||keep xl|26354
||mov|7,xr|21,=headr||point to listing header|26355
||jsr|6,prtst|||place it|26356
||jsr|6,sysid|||get system identification|26357
||jsr|6,prtst|||append extra chars|26358
||jsr|6,prtnl|||print it|26359
||mov|7,xr|7,xl||extra header line|26360
||jsr|6,prtst|||place it|26361
||jsr|6,prtnl|||print it|26362
||jsr|6,prtnl|||print a blank|26363
||jsr|6,prtnl|||and another|26364
||add|3,lstlc|18,=num04||four header lines printed|26365
||mov|7,xl|10,(xs)+||restore xl|26366
|prp05|mov|7,xr|10,(xs)+||restore xr|26370
|prp06|exi||||return|26374
||enp||||end procedure prtpg|26375
||ejc|||||26376
|prtps|prc|25,e|1,0||entry point|26385
||mov|3,prstd|3,prsto||copy option flag|26386
||jsr|6,prtpg|||print page|26387
||zer|3,prstd|||clear flag|26388
||exi||||return|26389
||enp||||end procedure prtps|26390
||ejc|||||26391
|prtsn|prc|25,e|1,0||entry point|26410
||mov|11,-(xs)|7,xr||save entry xr|26411
||mov|3,prsna|8,wa||save entry wa|26412
||mov|7,xr|21,=tmasb||point to asterisks|26413
||jsr|6,prtst|||print asterisks|26414
||mov|3,profs|18,=num04||point into middle of asterisks|26415
||mti|3,kvstn|||load statement number as integer|26416
||jsr|6,prtin|||print integer statement number|26417
||mov|3,profs|18,=prsnf||point past asterisks plus blank|26418
||mov|7,xr|3,kvfnc||get fnclevel|26419
||mov|8,wa|18,=ch_li||set letter i|26420
|prsn1|bze|7,xr|6,prsn2||jump if all set|26424
||jsr|6,prtch|||else print an i|26425
||dcv|7,xr|||decrement counter|26426
||brn|6,prsn1|||loop back|26427
|prsn2|mov|8,wa|18,=ch_bl||get blank|26431
||jsr|6,prtch|||print blank|26432
||mov|8,wa|3,prsna||restore entry wa|26433
||mov|7,xr|10,(xs)+||restore entry xr|26434
||exi||||return to prtsn caller|26435
||enp||||end procedure prtsn|26436
||ejc|||||26437
|prtst|prc|25,r|1,0||entry point|26452
||bnz|3,headp|6,prst0||were headers printed|26453
||jsr|6,prtps|||no - print them|26454
|prst0|mov|3,prsva|8,wa||save wa|26458
||mov|3,prsvb|8,wb||save wb|26459
||zer|8,wb|||set chars printed count to zero|26460
|prst1|mov|8,wa|13,sclen(xr)||load string length|26464
||sub|8,wa|8,wb||subtract count of chars already out|26465
||bze|8,wa|6,prst4||jump to exit if none left|26466
||mov|11,-(xs)|7,xl||else stack entry xl|26467
||mov|11,-(xs)|7,xr||save argument|26468
||mov|7,xl|7,xr||copy for eventual move|26469
||mov|7,xr|3,prlen||load print buffer length|26470
||sub|7,xr|3,profs||get chars left in print buffer|26471
||bnz|7,xr|6,prst2||skip if room left on this line|26472
||jsr|6,prtnl|||else print this line|26473
||mov|7,xr|3,prlen||and set full width available|26474
||ejc|||||26475
|prst2|blo|8,wa|7,xr|6,prst3|jump if room for rest of string|26481
||mov|8,wa|7,xr||else set to fill line|26482
|prst3|mov|7,xr|3,prbuf||point to print buffer|26486
||plc|7,xl|8,wb||point to location in string|26487
||psc|7,xr|3,profs||point to location in buffer|26488
||add|8,wb|8,wa||bump string chars count|26489
||add|3,profs|8,wa||bump buffer pointer|26490
||mov|3,prsvc|8,wb||preserve char counter|26491
||mvc||||move characters to buffer|26492
||mov|8,wb|3,prsvc||recover char counter|26493
||mov|7,xr|10,(xs)+||restore argument pointer|26494
||mov|7,xl|10,(xs)+||restore entry xl|26495
||brn|6,prst1|||loop back to test for more|26496
|prst4|mov|8,wb|3,prsvb||restore entry wb|26500
||mov|8,wa|3,prsva||restore entry wa|26501
||exi||||return to prtst caller|26502
||enp||||end procedure prtst|26503
||ejc|||||26504
|prttr|prc|25,e|1,0||entry point|26514
||mov|11,-(xs)|7,xr||save xr|26515
||jsr|6,prtic|||print buffer contents|26516
||mov|7,xr|3,prbuf||point to print bfr to clear it|26517
||lct|8,wa|3,prlnw||get buffer length|26518
||add|7,xr|19,*schar||point past scblk header|26519
||mov|8,wb|4,nullw||get blanks|26520
|prtt1|mov|10,(xr)+|8,wb||clear a word|26524
||bct|8,wa|6,prtt1||loop|26525
||zer|3,profs|||reset profs|26526
||mov|7,xr|10,(xs)+||restore xr|26527
||exi||||return|26528
||enp||||end procedure prttr|26529
||ejc|||||26530
|prtvl|prc|25,r|1,0||entry point, recursive|26541
||mov|11,-(xs)|7,xl||save entry xl|26542
||mov|11,-(xs)|7,xr||save argument|26543
||chk||||check for stack overflow|26544
|prv01|mov|3,prvsi|13,idval(xr)||copy idval (if any)|26548
||mov|7,xl|9,(xr)||load first word of block|26549
||lei|7,xl|||load entry point id|26550
||bsw|7,xl|2,bl__t|6,prv02|switch on block type|26551
||iff|2,bl_ar|6,prv05||arblk|26569
||iff|1,1|6,prv02|||26569
||iff|1,2|6,prv02|||26569
||iff|2,bl_ic|6,prv08||icblk|26569
||iff|2,bl_nm|6,prv09||nmblk|26569
||iff|1,5|6,prv02|||26569
||iff|1,6|6,prv02|||26569
||iff|1,7|6,prv02|||26569
||iff|2,bl_rc|6,prv08||rcblk|26569
||iff|2,bl_sc|6,prv11||scblk|26569
||iff|2,bl_se|6,prv12||seblk|26569
||iff|2,bl_tb|6,prv13||tbblk|26569
||iff|2,bl_vc|6,prv13||vcblk|26569
||iff|1,13|6,prv02|||26569
||iff|1,14|6,prv02|||26569
||iff|1,15|6,prv02|||26569
||iff|2,bl_pd|6,prv10||pdblk|26569
||iff|2,bl_tr|6,prv04||trblk|26569
||esw||||end of switch on block type|26569
|prv02|jsr|6,dtype|||get datatype name|26573
||jsr|6,prtst|||print datatype name|26574
|prv03|mov|7,xr|10,(xs)+||reload argument|26578
||mov|7,xl|10,(xs)+||restore xl|26579
||exi||||return to prtvl caller|26580
|prv04|mov|7,xr|13,trval(xr)||load real value|26584
||brn|6,prv01|||and loop back|26585
||ejc|||||26586
|prv05|mov|7,xl|7,xr||preserve argument|26594
||mov|7,xr|21,=scarr||point to datatype name (array)|26595
||jsr|6,prtst|||print it|26596
||mov|8,wa|18,=ch_pp||load left paren|26597
||jsr|6,prtch|||print left paren|26598
||add|7,xl|13,arofs(xl)||point to prototype|26599
||mov|7,xr|9,(xl)||load prototype|26600
||jsr|6,prtst|||print prototype|26601
|prv06|mov|8,wa|18,=ch_rp||load right paren|26605
||jsr|6,prtch|||print right paren|26606
|prv07|mov|8,wa|18,=ch_bl||load blank|26610
||jsr|6,prtch|||print it|26611
||mov|8,wa|18,=ch_nm||load number sign|26612
||jsr|6,prtch|||print it|26613
||mti|3,prvsi|||get idval|26614
||jsr|6,prtin|||print id number|26615
||brn|6,prv03|||back to exit|26616
|prv08|mov|11,-(xs)|7,xr||stack argument for gtstg|26622
||jsr|6,gtstg|||convert to string|26623
||ppm||||error return is impossible|26624
||jsr|6,prtst|||print the string|26625
||mov|3,dnamp|7,xr||delete garbage string from storage|26626
||brn|6,prv03|||back to exit|26627
||ejc|||||26628
|prv09|mov|7,xl|13,nmbas(xr)||load name base|26637
||mov|8,wa|9,(xl)||load first word of block|26638
||beq|8,wa|22,=b_kvt|6,prv02|just print name if keyword|26639
||beq|8,wa|22,=b_evt|6,prv02|just print name if expression var|26640
||mov|8,wa|18,=ch_dt||else get dot|26641
||jsr|6,prtch|||and print it|26642
||mov|8,wa|13,nmofs(xr)||load name offset|26643
||jsr|6,prtnm|||print name|26644
||brn|6,prv03|||back to exit|26645
|prv10|jsr|6,dtype|||get datatype name|26651
||jsr|6,prtst|||print datatype name|26652
||brn|6,prv07|||merge back to print id|26653
|prv11|mov|8,wa|18,=ch_sq||load single quote|26659
||jsr|6,prtch|||print quote|26660
||jsr|6,prtst|||print string value|26661
||jsr|6,prtch|||print another quote|26662
||brn|6,prv03|||back to exit|26663
||ejc|||||26664
|prv12|mov|8,wa|18,=ch_as||load asterisk|26672
||jsr|6,prtch|||print asterisk|26673
||mov|7,xr|13,sevar(xr)||load variable pointer|26674
||jsr|6,prtvn|||print variable name|26675
||brn|6,prv03|||jump back to exit|26676
|prv13|mov|7,xl|7,xr||preserve argument|26682
||jsr|6,dtype|||get datatype name|26683
||jsr|6,prtst|||print datatype name|26684
||mov|8,wa|18,=ch_pp||load left paren|26685
||jsr|6,prtch|||print left paren|26686
||mov|8,wa|13,tblen(xl)||load length of block (=vclen)|26687
||btw|8,wa|||convert to word count|26688
||sub|8,wa|18,=tbsi_||allow for standard fields|26689
||beq|9,(xl)|22,=b_tbt|6,prv14|jump if table|26690
||add|8,wa|18,=vctbd||for vcblk, adjust size|26691
|prv14|mti|8,wa|||move as integer|26695
||jsr|6,prtin|||print integer prototype|26696
||brn|6,prv06|||merge back for rest|26697
||enp||||end procedure prtvl|26720
||ejc|||||26721
|prtvn|prc|25,e|1,0||entry point|26730
||mov|11,-(xs)|7,xr||stack vrblk pointer|26731
||add|7,xr|19,*vrsof||point to possible string name|26732
||bnz|13,sclen(xr)|6,prvn1||jump if not system variable|26733
||mov|7,xr|13,vrsvo(xr)||point to svblk with name|26734
|prvn1|jsr|6,prtst|||print string name of variable|26738
||mov|7,xr|10,(xs)+||restore vrblk pointer|26739
||exi||||return to prtvn caller|26740
||enp||||end procedure prtvn|26741
||ejc|||||26744
|rcbld|prc|25,e|1,0||entry point|26753
||mov|7,xr|3,dnamp||load pointer to next available loc|26754
||add|7,xr|19,*rcsi_||point past new rcblk|26755
||blo|7,xr|3,dname|6,rcbl1|jump if there is room|26756
||mov|8,wa|19,*rcsi_||else load rcblk length|26757
||jsr|6,alloc|||use standard allocator to get block|26758
||add|7,xr|8,wa||point past block to merge|26759
|rcbl1|mov|3,dnamp|7,xr||set new pointer|26763
||sub|7,xr|19,*rcsi_||point back to start of block|26764
||mov|9,(xr)|22,=b_rcl||store type word|26765
||str|13,rcval(xr)|||store real value in rcblk|26766
||exi||||return to rcbld caller|26767
||enp||||end procedure rcbld|26768
||ejc|||||26770
|readr|prc|25,e|1,0||entry point|26784
||mov|7,xr|3,r_cni||get ptr to next image|26785
||bnz|7,xr|6,read3||exit if already read|26786
||bnz|3,cnind|6,reada||if within include file|26788
||bne|3,stage|18,=stgic|6,read3|exit if not initial compile|26790
|reada|mov|8,wa|3,cswin||max read length|26791
||zer|7,xl|||clear any dud value in xl|26792
||jsr|6,alocs|||allocate buffer|26793
||jsr|6,sysrd|||read input image|26794
||ppm|6,read4|||jump if eof or new file name|26795
||icv|3,rdnln|||increment next line number|26796
||dcv|3,polct|||test if time to poll interface|26798
||bnz|3,polct|6,read0||not yet|26799
||zer|8,wa|||=0 for poll|26800
||mov|8,wb|3,rdnln||line number|26801
||jsr|6,syspl|||allow interactive access|26802
||err|1,320|26,user interrupt|||26803
||ppm||||single step|26804
||ppm||||expression evaluation|26805
||mov|3,polcs|8,wa||new countdown start value|26806
||mov|3,polct|8,wa||new counter value|26807
|read0|ble|13,sclen(xr)|3,cswin|6,read1|use smaller of string lnth ...|26809
||mov|13,sclen(xr)|3,cswin||... and xxx of -inxxx|26810
|read1|mnz|8,wb|||set trimr to perform trim|26814
||jsr|6,trimr|||trim trailing blanks|26815
|read2|mov|3,r_cni|7,xr||store copy of pointer|26819
|read3|exi||||return to readr caller|26823
|read4|bze|13,sclen(xr)|6,read5||jump if true end of file|26832
||zer|8,wb|||new source file name|26833
||mov|3,rdnln|8,wb||restart line counter for new file|26834
||jsr|6,trimr|||remove unused space in block|26835
||jsr|6,newfn|||record new file name|26836
||brn|6,reada|||now reissue read for record data|26837
|read5|mov|3,dnamp|7,xr||pop unused scblk|26841
||bze|3,cnind|6,read6||jump if not within an include file|26843
||zer|7,xl|||eof within include file|26844
||jsr|6,sysif|||switch stream back to previous file|26845
||ppm|||||26846
||mov|8,wa|3,cnind||restore prev line number, file name|26847
||add|8,wa|18,=vcvlb||vector offset in words|26848
||wtb|8,wa|||convert to bytes|26849
||mov|7,xr|3,r_ifa||file name array|26850
||add|7,xr|8,wa||ptr to element|26851
||mov|3,r_sfc|9,(xr)||change source file name|26852
||mov|9,(xr)|21,=nulls||release scblk|26853
||mov|7,xr|3,r_ifl||line number array|26854
||add|7,xr|8,wa||ptr to element|26855
||mov|7,xl|9,(xr)||icblk containing saved line number|26856
||ldi|13,icval(xl)|||line number integer|26857
||mfi|3,rdnln|||change source line number|26858
||mov|9,(xr)|21,=inton||release icblk|26859
||dcv|3,cnind|||decrement nesting level|26860
||mov|8,wb|3,cmpsn||current statement number|26861
||icv|8,wb|||anticipate end of previous stmt|26862
||mti|8,wb|||convert to integer|26863
||jsr|6,icbld|||build icblk for stmt number|26864
||mov|7,xl|3,r_sfn||file name table|26865
||mnz|8,wb|||lookup statement number by name|26866
||jsr|6,tfind|||allocate new teblk|26867
||ppm||||always possible to allocate block|26868
||mov|13,teval(xl)|3,r_sfc||record file name as entry value|26869
||beq|3,stage|18,=stgic|6,reada|if initial compile, reissue read|26870
||bnz|3,cnind|6,reada||still reading from include file|26871
||mov|7,xl|3,r_ici||restore code argument string|26876
||zer|3,r_ici|||release original string|26877
||mov|8,wa|3,cnsil||get length of string|26878
||mov|8,wb|3,cnspt||offset of characters left|26879
||sub|8,wa|8,wb||number of characters left|26880
||mov|3,scnil|8,wa||set new scan length|26881
||zer|3,scnpt|||scan from start of substring|26882
||jsr|6,sbstr|||create substring of remainder|26883
||mov|3,r_cim|7,xr||set scan image|26884
||brn|6,read2|||return|26885
|read6|zer|7,xr|||zero ptr as result|26901
||brn|6,read2|||merge|26902
||enp||||end procedure readr|26903
||ejc|||||26904
|sbstr|prc|25,e|1,0||entry point|26999
||bze|8,wa|6,sbst2||jump if null substring|27000
||jsr|6,alocs|||else allocate scblk|27001
||mov|8,wa|8,wc||move number of characters|27002
||mov|8,wc|7,xr||save ptr to new scblk|27003
||plc|7,xl|8,wb||prepare to load chars from old blk|27004
||psc|7,xr|||prepare to store chars in new blk|27005
||mvc||||move characters to new string|27006
||mov|7,xr|8,wc||then restore scblk pointer|27007
|sbst1|zer|7,xl|||clear garbage pointer in xl|27011
||exi||||return to sbstr caller|27012
|sbst2|mov|7,xr|21,=nulls||set null string as result|27016
||brn|6,sbst1|||return|27017
||enp||||end procedure sbstr|27018
||ejc|||||27019
|stgcc|prc|25,e|1,0|||27030
||mov|8,wa|3,polcs||assume no profiling or stcount tracing|27032
||mov|8,wb|18,=num01||poll each time polcs expires|27033
||ldi|3,kvstl|||get stmt limit|27037
||bnz|3,kvpfl|6,stgc1||jump if profiling enabled|27038
||ilt|6,stgc3|||no stcount tracing if negative|27039
||bze|3,r_stc|6,stgc2||jump if not stcount tracing|27040
|stgc1|mov|8,wb|8,wa||count polcs times within stmg|27045
||mov|8,wa|18,=num01||break out of stmgo on each stmt|27046
||brn|6,stgc3||||27050
|stgc2|mti|8,wa|||breakout count start value|27054
||sbi|3,kvstl|||proposed stmcs minus stmt limit|27055
||ile|6,stgc3|||jump if stmt count does not limit|27056
||ldi|3,kvstl|||stlimit limits breakcount count|27057
||mfi|8,wa|||use it instead|27058
|stgc3|mov|3,stmcs|8,wa||update breakout count start value|27062
||mov|3,stmct|8,wa||reset breakout counter|27063
||mov|3,polct|8,wb|||27065
||exi|||||27067
||ejc|||||27068
|tfind|prc|25,e|1,1||entry point|27087
||mov|11,-(xs)|8,wb||save name/value indicator|27088
||mov|11,-(xs)|7,xr||save subscript value|27089
||mov|11,-(xs)|7,xl||save table pointer|27090
||mov|8,wa|13,tblen(xl)||load length of tbblk|27091
||btw|8,wa|||convert to word count|27092
||sub|8,wa|18,=tbbuk||get number of buckets|27093
||mti|8,wa|||convert to integer value|27094
||sti|3,tfnsi|||save for later|27095
||mov|7,xl|9,(xr)||load first word of subscript|27096
||lei|7,xl|||load block entry id (bl_xx)|27097
||bsw|7,xl|2,bl__d|6,tfn00|switch on block type|27098
||iff|1,0|6,tfn00|||27109
||iff|1,1|6,tfn00|||27109
||iff|1,2|6,tfn00|||27109
||iff|2,bl_ic|6,tfn02||jump if integer|27109
||iff|2,bl_nm|6,tfn04||jump if name|27109
||iff|2,bl_p0|6,tfn03||jump if pattern|27109
||iff|2,bl_p1|6,tfn03||jump if pattern|27109
||iff|2,bl_p2|6,tfn03||jump if pattern|27109
||iff|2,bl_rc|6,tfn02||real|27109
||iff|2,bl_sc|6,tfn05||jump if string|27109
||iff|1,10|6,tfn00|||27109
||iff|1,11|6,tfn00|||27109
||iff|1,12|6,tfn00|||27109
||iff|1,13|6,tfn00|||27109
||iff|1,14|6,tfn00|||27109
||iff|1,15|6,tfn00|||27109
||iff|1,16|6,tfn00|||27109
||esw||||end switch on block type|27109
|tfn00|mov|8,wa|12,1(xr)||load second word|27114
|tfn01|mti|8,wa|||convert to integer|27118
||brn|6,tfn06|||jump to merge|27119
||ejc|||||27120
|tfn02|ldi|12,1(xr)|||load value as hash source|27130
||ige|6,tfn06|||ok if positive or zero|27131
||ngi||||make positive|27132
||iov|6,tfn06|||clear possible overflow|27133
||brn|6,tfn06|||merge|27134
|tfn03|mov|8,wa|9,(xr)||load first word as hash source|27138
||brn|6,tfn01|||merge back|27139
|tfn04|mov|8,wa|13,nmofs(xr)||load offset as hash source|27143
||brn|6,tfn01|||merge back|27144
|tfn05|jsr|6,hashs|||call routine to compute hash|27148
|tfn06|rmi|3,tfnsi|||compute hash index by remaindering|27152
||mfi|8,wc|||get as one word integer|27153
||wtb|8,wc|||convert to byte offset|27154
||mov|7,xl|9,(xs)||get table ptr again|27155
||add|7,xl|8,wc||point to proper bucket|27156
||mov|7,xr|13,tbbuk(xl)||load first teblk pointer|27157
||beq|7,xr|9,(xs)|6,tfn10|jump if no teblks on chain|27158
|tfn07|mov|8,wb|7,xr||save teblk pointer|27162
||mov|7,xr|13,tesub(xr)||load subscript value|27163
||mov|7,xl|12,1(xs)||load input argument subscript val|27164
||jsr|6,ident|||compare them|27165
||ppm|6,tfn08|||jump if equal (ident)|27166
||mov|7,xl|8,wb||restore teblk pointer|27170
||mov|7,xr|13,tenxt(xl)||point to next teblk on chain|27171
||bne|7,xr|9,(xs)|6,tfn07|jump if there is one|27172
||mov|8,wc|19,*tenxt||set offset to link field (xl base)|27176
||brn|6,tfn11|||jump to merge|27177
||ejc|||||27178
|tfn08|mov|7,xl|8,wb||restore teblk pointer|27184
||mov|8,wa|19,*teval||set teblk name offset|27185
||mov|8,wb|12,2(xs)||restore name/value indicator|27186
||bnz|8,wb|6,tfn09||jump if called by name|27187
||jsr|6,acess|||else get value|27188
||ppm|6,tfn12|||jump if reference fails|27189
||zer|8,wb|||restore name/value indicator|27190
|tfn09|add|7,xs|19,*num03||pop stack entries|27194
||exi||||return to tfind caller|27195
|tfn10|add|8,wc|19,*tbbuk||get offset to bucket ptr|27199
||mov|7,xl|9,(xs)||set tbblk ptr as base|27200
|tfn11|mov|7,xr|9,(xs)||tbblk pointer|27204
||mov|7,xr|13,tbinv(xr)||load default value in case|27205
||mov|8,wb|12,2(xs)||load name/value indicator|27206
||bze|8,wb|6,tfn09||exit with default if value call|27207
||mov|8,wb|7,xr||copy default value|27208
||mov|8,wa|19,*tesi_||set size of teblk|27212
||jsr|6,alloc|||allocate teblk|27213
||add|7,xl|8,wc||point to hash link|27214
||mov|9,(xl)|7,xr||link new teblk at end of chain|27215
||mov|9,(xr)|22,=b_tet||store type word|27216
||mov|13,teval(xr)|8,wb||set default as initial value|27217
||mov|13,tenxt(xr)|10,(xs)+||set tbblk ptr to mark end of chain|27218
||mov|13,tesub(xr)|10,(xs)+||store subscript value|27219
||mov|8,wb|10,(xs)+||restore name/value indicator|27220
||mov|7,xl|7,xr||copy teblk pointer (name base)|27221
||mov|8,wa|19,*teval||set offset|27222
||exi||||return to caller with new teblk|27223
|tfn12|exi|1,1|||alternative return|27227
||enp||||end procedure tfind|27228
||ejc|||||27229
|tmake|prc|25,e|1,0|||27239
||mov|8,wa|8,wc||copy number of headers|27240
||add|8,wa|18,=tbsi_||adjust for standard fields|27241
||wtb|8,wa|||convert length to bytes|27242
||jsr|6,alloc|||allocate space for tbblk|27243
||mov|8,wb|7,xr||copy pointer to tbblk|27244
||mov|10,(xr)+|22,=b_tbt||store type word|27245
||zer|10,(xr)+|||zero id for the moment|27246
||mov|10,(xr)+|8,wa||store length (tblen)|27247
||mov|10,(xr)+|7,xl||store initial lookup value|27248
||lct|8,wc|8,wc||set loop counter (num headers)|27249
|tma01|mov|10,(xr)+|8,wb||store tbblk ptr in bucket header|27253
||bct|8,wc|6,tma01||loop till all stored|27254
||mov|7,xr|8,wb||recall pointer to tbblk|27255
||exi|||||27256
||enp|||||27257
||ejc|||||27258
|vmake|prc|25,e|1,1||entry point|27270
||lct|8,wb|8,wa||copy elements for loop later on|27271
||add|8,wa|18,=vcsi_||add space for standard fields|27272
||wtb|8,wa|||convert length to bytes|27273
||bgt|8,wa|3,mxlen|6,vmak2|fail if too large|27274
||jsr|6,alloc|||allocate space for vcblk|27275
||mov|9,(xr)|22,=b_vct||store type word|27276
||zer|13,idval(xr)|||initialize idval|27277
||mov|13,vclen(xr)|8,wa||set length|27278
||mov|8,wc|7,xl||copy default value|27279
||mov|7,xl|7,xr||copy vcblk pointer|27280
||add|7,xl|19,*vcvls||point to first element value|27281
|vmak1|mov|10,(xl)+|8,wc||store one value|27285
||bct|8,wb|6,vmak1||loop till all stored|27286
||exi||||success return|27287
|vmak2|exi|1,1|||fail return|27291
||enp|||||27292
||ejc|||||27293
||ejc|||||27341
||ejc|||||27386
|scane|prc|25,e|1,0||entry point|27392
||zer|3,scnbl|||reset blanks flag|27393
||mov|3,scnsa|8,wa||save wa|27394
||mov|3,scnsb|8,wb||save wb|27395
||mov|3,scnsc|8,wc||save wc|27396
||bze|3,scnrs|6,scn03||jump if no rescan|27397
||mov|7,xl|3,scntp||set previous returned scan type|27401
||mov|7,xr|3,r_scp||set previous returned pointer|27402
||zer|3,scnrs|||reset rescan switch|27403
||brn|6,scn13|||jump to exit|27404
|scn01|jsr|6,readr|||read next image|27408
||mov|8,wb|19,*dvubs||set wb for not reading name|27409
||bze|7,xr|6,scn30||treat as semi-colon if none|27410
||plc|7,xr|||else point to first character|27411
||lch|8,wc|9,(xr)||load first character|27412
||beq|8,wc|18,=ch_dt|6,scn02|jump if dot for continuation|27413
||bne|8,wc|18,=ch_pl|6,scn30|else treat as semicolon unless plus|27414
|scn02|jsr|6,nexts|||acquire next source image|27418
||mov|3,scnpt|18,=num01||set scan pointer past continuation|27419
||mnz|3,scnbl|||set blanks flag|27420
||ejc|||||27421
|scn03|mov|8,wa|3,scnpt||load current offset|27427
||beq|8,wa|3,scnil|6,scn01|check continuation if end|27428
||mov|7,xl|3,r_cim||point to current line|27429
||plc|7,xl|8,wa||point to current character|27430
||mov|3,scnse|8,wa||set start of element location|27431
||mov|8,wc|21,=opdvs||point to operator dv list|27432
||mov|8,wb|19,*dvubs||set constant for operator circuit|27433
||brn|6,scn06|||start scanning|27434
|scn05|bze|8,wb|6,scn10||jump if trailing|27438
||icv|3,scnse|||increment start of element|27439
||beq|8,wa|3,scnil|6,scn01|jump if end of image|27440
||mnz|3,scnbl|||note blanks seen|27441
|scn06|lch|7,xr|10,(xl)+||get next character|27453
||icv|8,wa|||bump scan offset|27454
||mov|3,scnpt|8,wa||store offset past char scanned|27455
||bsw|7,xr|2,cfp_u|6,scn07|switch on scanned character|27457
||ejc|||||27484
||ejc|||||27540
||iff|1,0|6,scn07|||27573
||iff|1,1|6,scn07|||27573
||iff|1,2|6,scn07|||27573
||iff|1,3|6,scn07|||27573
||iff|1,4|6,scn07|||27573
||iff|1,5|6,scn07|||27573
||iff|1,6|6,scn07|||27573
||iff|1,7|6,scn07|||27573
||iff|1,8|6,scn07|||27573
||iff|2,ch_ht|6,scn05||horizontal tab|27573
||iff|1,10|6,scn07|||27573
||iff|1,11|6,scn07|||27573
||iff|1,12|6,scn07|||27573
||iff|1,13|6,scn07|||27573
||iff|1,14|6,scn07|||27573
||iff|1,15|6,scn07|||27573
||iff|1,16|6,scn07|||27573
||iff|1,17|6,scn07|||27573
||iff|1,18|6,scn07|||27573
||iff|1,19|6,scn07|||27573
||iff|1,20|6,scn07|||27573
||iff|1,21|6,scn07|||27573
||iff|1,22|6,scn07|||27573
||iff|1,23|6,scn07|||27573
||iff|1,24|6,scn07|||27573
||iff|1,25|6,scn07|||27573
||iff|1,26|6,scn07|||27573
||iff|1,27|6,scn07|||27573
||iff|1,28|6,scn07|||27573
||iff|1,29|6,scn07|||27573
||iff|1,30|6,scn07|||27573
||iff|1,31|6,scn07|||27573
||iff|2,ch_bl|6,scn05||blank|27573
||iff|2,ch_ex|6,scn37||exclamation mark|27573
||iff|2,ch_dq|6,scn17||double quote|27573
||iff|2,ch_nm|6,scn41||number sign|27573
||iff|2,ch_dl|6,scn36||dollar|27573
||iff|1,37|6,scn07|||27573
||iff|2,ch_am|6,scn44||ampersand|27573
||iff|2,ch_sq|6,scn16||single quote|27573
||iff|2,ch_pp|6,scn25||left paren|27573
||iff|2,ch_rp|6,scn26||right paren|27573
||iff|2,ch_as|6,scn49||asterisk|27573
||iff|2,ch_pl|6,scn33||plus|27573
||iff|2,ch_cm|6,scn31||comma|27573
||iff|2,ch_mn|6,scn34||minus|27573
||iff|2,ch_dt|6,scn32||dot|27573
||iff|2,ch_sl|6,scn40||slash|27573
||iff|2,ch_d0|6,scn08||digit 0|27573
||iff|2,ch_d1|6,scn08||digit 1|27573
||iff|2,ch_d2|6,scn08||digit 2|27573
||iff|2,ch_d3|6,scn08||digit 3|27573
||iff|2,ch_d4|6,scn08||digit 4|27573
||iff|2,ch_d5|6,scn08||digit 5|27573
||iff|2,ch_d6|6,scn08||digit 6|27573
||iff|2,ch_d7|6,scn08||digit 7|27573
||iff|2,ch_d8|6,scn08||digit 8|27573
||iff|2,ch_d9|6,scn08||digit 9|27573
||iff|2,ch_cl|6,scn29||colon|27573
||iff|2,ch_sm|6,scn30||semi-colon|27573
||iff|2,ch_bb|6,scn28||left bracket|27573
||iff|2,ch_eq|6,scn46||equal|27573
||iff|2,ch_rb|6,scn27||right bracket|27573
||iff|2,ch_qu|6,scn45||question mark|27573
||iff|2,ch_at|6,scn42||at|27573
||iff|2,ch_ua|6,scn09||shifted a|27573
||iff|2,ch_ub|6,scn09||shifted b|27573
||iff|2,ch_uc|6,scn09||shifted c|27573
||iff|2,ch_ud|6,scn09||shifted d|27573
||iff|2,ch_ue|6,scn09||shifted e|27573
||iff|2,ch_uf|6,scn20||shifted f|27573
||iff|2,ch_ug|6,scn09||shifted g|27573
||iff|2,ch_uh|6,scn09||shifted h|27573
||iff|2,ch_ui|6,scn09||shifted i|27573
||iff|2,ch_uj|6,scn09||shifted j|27573
||iff|2,ch_uk|6,scn09||shifted k|27573
||iff|2,ch_ul|6,scn09||shifted l|27573
||iff|2,ch_um|6,scn09||shifted m|27573
||iff|2,ch_un|6,scn09||shifted n|27573
||iff|2,ch_uo|6,scn09||shifted o|27573
||iff|2,ch_up|6,scn09||shifted p|27573
||iff|2,ch_uq|6,scn09||shifted q|27573
||iff|2,ch_ur|6,scn09||shifted r|27573
||iff|2,ch_us|6,scn21||shifted s|27573
||iff|2,ch_ut|6,scn09||shifted t|27573
||iff|2,ch_uu|6,scn09||shifted u|27573
||iff|2,ch_uv|6,scn09||shifted v|27573
||iff|2,ch_uw|6,scn09||shifted w|27573
||iff|2,ch_ux|6,scn09||shifted x|27573
||iff|2,ch_uy|6,scn09||shifted y|27573
||iff|2,ch_uz|6,scn09||shifted z|27573
||iff|2,ch_ob|6,scn28||left bracket|27573
||iff|1,92|6,scn07|||27573
||iff|2,ch_cb|6,scn27||right bracket|27573
||iff|2,ch_pc|6,scn38||percent|27573
||iff|2,ch_u_|6,scn24||underline|27573
||iff|1,96|6,scn07|||27573
||iff|2,ch_la|6,scn09||letter a|27573
||iff|2,ch_lb|6,scn09||letter b|27573
||iff|2,ch_lc|6,scn09||letter c|27573
||iff|2,ch_ld|6,scn09||letter d|27573
||iff|2,ch_le|6,scn09||letter e|27573
||iff|2,ch_lf|6,scn20||letter f|27573
||iff|2,ch_lg|6,scn09||letter g|27573
||iff|2,ch_lh|6,scn09||letter h|27573
||iff|2,ch_li|6,scn09||letter i|27573
||iff|2,ch_lj|6,scn09||letter j|27573
||iff|2,ch_lk|6,scn09||letter k|27573
||iff|2,ch_ll|6,scn09||letter l|27573
||iff|2,ch_lm|6,scn09||letter m|27573
||iff|2,ch_ln|6,scn09||letter n|27573
||iff|2,ch_lo|6,scn09||letter o|27573
||iff|2,ch_lp|6,scn09||letter p|27573
||iff|2,ch_lq|6,scn09||letter q|27573
||iff|2,ch_lr|6,scn09||letter r|27573
||iff|2,ch_ls|6,scn21||letter s|27573
||iff|2,ch_lt|6,scn09||letter t|27573
||iff|2,ch_lu|6,scn09||letter u|27573
||iff|2,ch_lv|6,scn09||letter v|27573
||iff|2,ch_lw|6,scn09||letter w|27573
||iff|2,ch_lx|6,scn09||letter x|27573
||iff|2,ch_ly|6,scn09||letter y|27573
||iff|2,ch_l_|6,scn09||letter z|27573
||iff|1,123|6,scn07|||27573
||iff|2,ch_br|6,scn43||vertical bar|27573
||iff|1,125|6,scn07|||27573
||iff|2,ch_nt|6,scn35||not|27573
||iff|1,127|6,scn07|||27573
||esw||||end switch on character|27573
|scn07|bze|8,wb|6,scn10||jump if scanning name or constant|27577
||erb|1,230|26,syntax error: illegal character|||27578
||ejc|||||27579
|scn08|bze|8,wb|6,scn09||keep scanning if name/constant|27585
||zer|8,wc|||else set flag for scanning constant|27586
|scn09|beq|8,wa|3,scnil|6,scn11|jump if end of image|27590
||zer|8,wb|||set flag for scanning name/const|27591
||brn|6,scn06|||merge back to continue scan|27592
|scn10|dcv|8,wa|||reset offset to point to delimiter|27596
|scn11|mov|3,scnpt|8,wa||store updated scan offset|27600
||mov|8,wb|3,scnse||point to start of element|27601
||sub|8,wa|8,wb||get number of characters|27602
||mov|7,xl|3,r_cim||point to line image|27603
||bnz|8,wc|6,scn15||jump if name|27604
||jsr|6,sbstr|||get string for constant|27608
||mov|3,dnamp|7,xr||delete from storage (not needed)|27609
||jsr|6,gtnum|||convert to numeric|27610
||ppm|6,scn14|||jump if conversion failure|27611
|scn12|mov|7,xl|18,=t_con||set result type of constant|27615
||ejc|||||27616
|scn13|mov|8,wa|3,scnsa||restore wa|27622
||mov|8,wb|3,scnsb||restore wb|27623
||mov|8,wc|3,scnsc||restore wc|27624
||mov|3,r_scp|7,xr||save xr in case rescan|27625
||mov|3,scntp|7,xl||save xl in case rescan|27626
||zer|3,scngo|||reset possible goto flag|27627
||exi||||return to scane caller|27628
|scn14|erb|1,231|26,syntax error: invalid numeric item|||27632
|scn15|jsr|6,sbstr|||build string name of variable|27636
||bnz|3,scncc|6,scn13||return if cncrd call|27637
||jsr|6,gtnvr|||locate/build vrblk|27638
||ppm||||dummy (unused) error return|27639
||mov|7,xl|18,=t_var||set type as variable|27640
||brn|6,scn13|||back to exit|27641
|scn16|bze|8,wb|6,scn10||terminator if scanning name or cnst|27645
||mov|8,wb|18,=ch_sq||set terminator as single quote|27646
||brn|6,scn18|||merge|27647
|scn17|bze|8,wb|6,scn10||terminator if scanning name or cnst|27651
||mov|8,wb|18,=ch_dq||set double quote terminator, merge|27652
|scn18|beq|8,wa|3,scnil|6,scn19|error if end of image|27656
||lch|8,wc|10,(xl)+||else load next character|27657
||icv|8,wa|||bump offset|27658
||bne|8,wc|8,wb|6,scn18|loop back if not terminator|27659
||ejc|||||27660
||mov|8,wb|3,scnpt||point to first character|27666
||mov|3,scnpt|8,wa||save offset past final quote|27667
||dcv|8,wa|||point back past last character|27668
||sub|8,wa|8,wb||get number of characters|27669
||mov|7,xl|3,r_cim||point to input image|27670
||jsr|6,sbstr|||build substring value|27671
||brn|6,scn12|||back to exit with constant result|27672
|scn19|mov|3,scnpt|8,wa||set updated scan pointer|27676
||erb|1,232|26,syntax error: unmatched string quote|||27677
|scn20|mov|7,xr|18,=t_fgo||set return code for fail goto|27681
||brn|6,scn22|||jump to merge|27682
|scn21|mov|7,xr|18,=t_sgo||set success goto as return code|27686
|scn22|bze|3,scngo|6,scn09||treat as normal letter if not goto|27690
|scn23|bze|8,wb|6,scn10||jump if end of name/constant|27694
||mov|7,xl|7,xr||else copy code|27695
||brn|6,scn13|||and jump to exit|27696
|scn24|bze|8,wb|6,scn09||part of name if scanning name|27700
||brn|6,scn07|||else illegal|27701
||ejc|||||27702
|scn25|mov|7,xr|18,=t_lpr||set left paren return code|27708
||bnz|8,wb|6,scn23||return left paren unless name|27709
||bze|8,wc|6,scn10||delimiter if scanning constant|27710
||mov|8,wb|3,scnse||point to start of name|27714
||mov|3,scnpt|8,wa||set pointer past left paren|27715
||dcv|8,wa|||point back past last char of name|27716
||sub|8,wa|8,wb||get name length|27717
||mov|7,xl|3,r_cim||point to input image|27718
||jsr|6,sbstr|||get string name for function|27719
||jsr|6,gtnvr|||locate/build vrblk|27720
||ppm||||dummy (unused) error return|27721
||mov|7,xl|18,=t_fnc||set code for function call|27722
||brn|6,scn13|||back to exit|27723
|scn26|mov|7,xr|18,=t_rpr||right paren, set code|27727
||brn|6,scn23|||take special character exit|27728
|scn27|mov|7,xr|18,=t_rbr||right bracket, set code|27730
||brn|6,scn23|||take special character exit|27731
|scn28|mov|7,xr|18,=t_lbr||left bracket, set code|27733
||brn|6,scn23|||take special character exit|27734
|scn29|mov|7,xr|18,=t_col||colon, set code|27736
||brn|6,scn23|||take special character exit|27737
|scn30|mov|7,xr|18,=t_smc||semi-colon, set code|27739
||brn|6,scn23|||take special character exit|27740
|scn31|mov|7,xr|18,=t_cma||comma, set code|27742
||brn|6,scn23|||take special character exit|27743
||ejc|||||27744
|scn32|bze|8,wb|6,scn09||dot can be part of name or constant|27756
||add|8,wc|8,wb||else bump pointer|27757
|scn33|bze|8,wc|6,scn09||plus can be part of constant|27759
||bze|8,wb|6,scn48||plus cannot be part of name|27760
||add|8,wc|8,wb||else bump pointer|27761
|scn34|bze|8,wc|6,scn09||minus can be part of constant|27763
||bze|8,wb|6,scn48||minus cannot be part of name|27764
||add|8,wc|8,wb||else bump pointer|27765
|scn35|add|8,wc|8,wb||not|27767
|scn36|add|8,wc|8,wb||dollar|27768
|scn37|add|8,wc|8,wb||exclamation|27769
|scn38|add|8,wc|8,wb||percent|27770
|scn39|add|8,wc|8,wb||asterisk|27771
|scn40|add|8,wc|8,wb||slash|27772
|scn41|add|8,wc|8,wb||number sign|27773
|scn42|add|8,wc|8,wb||at sign|27774
|scn43|add|8,wc|8,wb||vertical bar|27775
|scn44|add|8,wc|8,wb||ampersand|27776
|scn45|add|8,wc|8,wb||question mark|27777
|scn46|bze|8,wb|6,scn10||operator terminates name/constant|27782
||mov|7,xr|8,wc||else copy dv pointer|27783
||lch|8,wc|9,(xl)||load next character|27784
||mov|7,xl|18,=t_bop||set binary op in case|27785
||beq|8,wa|3,scnil|6,scn47|should be binary if image end|27786
||beq|8,wc|18,=ch_bl|6,scn47|should be binary if followed by blk|27787
||beq|8,wc|18,=ch_ht|6,scn47|jump if horizontal tab|27789
||beq|8,wc|18,=ch_sm|6,scn47|semicolon can immediately follow =|27794
||beq|8,wc|18,=ch_cl|6,scn47|colon can immediately follow =|27795
||beq|8,wc|18,=ch_rp|6,scn47|right paren can immediately follow =|27796
||beq|8,wc|18,=ch_rb|6,scn47|right bracket can immediately follow =|27797
||beq|8,wc|18,=ch_cb|6,scn47|right bracket can immediately follow =|27798
||add|7,xr|19,*dvbs_||point to dv for unary op|27802
||mov|7,xl|18,=t_uop||set type for unary operator|27803
||ble|3,scntp|18,=t_uok|6,scn13|ok unary if ok preceding element|27804
||ejc|||||27805
|scn47|bnz|3,scnbl|6,scn13||all ok if preceding blanks, exit|27811
|scn48|erb|1,233|26,syntax error: invalid use of operator|||27815
|scn49|bze|8,wb|6,scn10||end of name if scanning name|27819
||beq|8,wa|3,scnil|6,scn39|not ** if * at image end|27820
||mov|7,xr|8,wa||else save offset past first *|27821
||mov|3,scnof|8,wa||save another copy|27822
||lch|8,wa|10,(xl)+||load next character|27823
||bne|8,wa|18,=ch_as|6,scn50|not ** if next char not *|27824
||icv|7,xr|||else step offset past second *|27825
||beq|7,xr|3,scnil|6,scn51|ok exclam if end of image|27826
||lch|8,wa|9,(xl)||else load next character|27827
||beq|8,wa|18,=ch_bl|6,scn51|exclamation if blank|27828
||beq|8,wa|18,=ch_ht|6,scn51|exclamation if horizontal tab|27830
|scn50|mov|8,wa|3,scnof||recover stored offset|27838
||mov|7,xl|3,r_cim||point to line again|27839
||plc|7,xl|8,wa||point to current char|27840
||brn|6,scn39|||merge with unary *|27841
|scn51|mov|3,scnpt|7,xr||save scan pointer past 2nd *|27845
||mov|8,wa|7,xr||copy scan pointer|27846
||brn|6,scn37|||merge with exclamation|27847
||enp||||end procedure scane|27848
||ejc|||||27849
|scngf|prc|25,e|1,0||entry point|27866
||jsr|6,scane|||scan initial element|27867
||beq|7,xl|18,=t_lpr|6,scng1|skip if left paren (normal goto)|27868
||beq|7,xl|18,=t_lbr|6,scng2|skip if left bracket (direct goto)|27869
||erb|1,234|26,syntax error: goto field incorrect|||27870
|scng1|mov|8,wb|18,=num01||set expan flag for normal goto|27874
||jsr|6,expan|||analyze goto field|27875
||mov|8,wa|21,=opdvn||point to opdv for complex goto|27876
||ble|7,xr|3,statb|6,scng3|jump if not in static (sgd15)|27877
||blo|7,xr|3,state|6,scng4|jump to exit if simple label name|27878
||brn|6,scng3|||complex goto - merge|27879
|scng2|mov|8,wb|18,=num02||set expan flag for direct goto|27883
||jsr|6,expan|||scan goto field|27884
||mov|8,wa|21,=opdvd||set opdv pointer for direct goto|27885
||ejc|||||27886
|scng3|mov|11,-(xs)|8,wa||stack operator dv pointer|27892
||mov|11,-(xs)|7,xr||stack pointer to expression tree|27893
||jsr|6,expop|||pop operator off|27894
||mov|7,xr|10,(xs)+||reload new expression tree pointer|27895
|scng4|exi||||return to caller|27899
||enp||||end procedure scngf|27900
||ejc|||||27901
|setvr|prc|25,e|1,0||entry point|27916
||bhi|7,xr|3,state|6,setv1|exit if not natural variable|27917
||mov|7,xl|7,xr||copy vrblk pointer|27921
||mov|13,vrget(xr)|22,=b_vrl||store normal get value|27922
||beq|13,vrsto(xr)|22,=b_vre|6,setv1|skip if protected variable|27923
||mov|13,vrsto(xr)|22,=b_vrs||store normal store value|27924
||mov|7,xl|13,vrval(xl)||point to next entry on chain|27925
||bne|9,(xl)|22,=b_trt|6,setv1|jump if end of trblk chain|27926
||mov|13,vrget(xr)|22,=b_vra||store trapped routine address|27927
||mov|13,vrsto(xr)|22,=b_vrv||set trapped routine address|27928
|setv1|exi||||return to setvr caller|27932
||enp||||end procedure setvr|27933
||ejc|||||27936
||ejc|||||27973
|sorta|prc|25,n|1,1||entry point|27977
||mov|3,srtsr|8,wa||sort/rsort indicator|27978
||mov|3,srtst|19,*num01||default stride of 1|27979
||zer|3,srtof|||default zero offset to sort key|27980
||mov|3,srtdf|21,=nulls||clear datatype field name|27981
||mov|3,r_sxr|10,(xs)+||unstack argument 2|27982
||mov|7,xr|10,(xs)+||get first argument|27983
||mnz|8,wa|||use key/values of table entries|27984
||jsr|6,gtarr|||convert to array|27985
||ppm|6,srt18|||signal that table is empty|27986
||ppm|6,srt16|||error if non-convertable|27987
||mov|11,-(xs)|7,xr||stack ptr to resulting key array|27988
||mov|11,-(xs)|7,xr||another copy for copyb|27989
||jsr|6,copyb|||get copy array for sorting into|27990
||ppm||||cant fail|27991
||mov|11,-(xs)|7,xr||stack pointer to sort array|27992
||mov|7,xr|3,r_sxr||get second arg|27993
||mov|7,xl|13,num01(xs)||get ptr to key array|27994
||bne|9,(xl)|22,=b_vct|6,srt02|jump if arblk|27995
||beq|7,xr|21,=nulls|6,srt01|jump if null second arg|27996
||jsr|6,gtnvr|||get vrblk ptr for it|27997
||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||27998
||mov|3,srtdf|7,xr||store datatype field name vrblk|27999
|srt01|mov|8,wc|19,*vclen||offset to a(0)|28003
||mov|8,wb|19,*vcvls||offset to first item|28004
||mov|8,wa|13,vclen(xl)||get block length|28005
||sub|8,wa|19,*vcsi_||get no. of entries, n (in bytes)|28006
||brn|6,srt04|||merge|28007
|srt02|ldi|13,ardim(xl)|||get possible dimension|28011
||mfi|8,wa|||convert to short integer|28012
||wtb|8,wa|||further convert to baus|28013
||mov|8,wb|19,*arvls||offset to first value if one|28014
||mov|8,wc|19,*arpro||offset before values if one dim.|28015
||beq|13,arndm(xl)|18,=num01|6,srt04|jump in fact if one dim.|28016
||bne|13,arndm(xl)|18,=num02|6,srt16|fail unless two dimens|28017
||ldi|13,arlb2(xl)|||get lower bound 2 as default|28018
||beq|7,xr|21,=nulls|6,srt03|jump if default second arg|28019
||jsr|6,gtint|||convert to integer|28020
||ppm|6,srt17|||fail|28021
||ldi|13,icval(xr)|||get actual integer value|28022
||ejc|||||28023
|srt03|sbi|13,arlb2(xl)|||subtract low bound|28029
||iov|6,srt17|||fail if overflow|28030
||ilt|6,srt17|||fail if below low bound|28031
||sbi|13,ardm2(xl)|||check against dimension|28032
||ige|6,srt17|||fail if too large|28033
||adi|13,ardm2(xl)|||restore value|28034
||mfi|8,wa|||get as small integer|28035
||wtb|8,wa|||offset within row to key|28036
||mov|3,srtof|8,wa||keep offset|28037
||ldi|13,ardm2(xl)|||second dimension is row length|28038
||mfi|8,wa|||convert to short integer|28039
||mov|7,xr|8,wa||copy row length|28040
||wtb|8,wa|||convert to bytes|28041
||mov|3,srtst|8,wa||store as stride|28042
||ldi|13,ardim(xl)|||get number of rows|28043
||mfi|8,wa|||as a short integer|28044
||wtb|8,wa|||convert n to baus|28045
||mov|8,wc|13,arlen(xl)||offset past array end|28046
||sub|8,wc|8,wa||adjust, giving space for n offsets|28047
||dca|8,wc|||point to a(0)|28048
||mov|8,wb|13,arofs(xl)||offset to word before first item|28049
||ica|8,wb|||offset to first item|28050
|srt04|ble|8,wa|19,*num01|6,srt15|return if only a single item|28062
||mov|3,srtsn|8,wa||store number of items (in baus)|28063
||mov|3,srtso|8,wc||store offset to a(0)|28064
||mov|8,wc|13,arlen(xl)||length of array or vec (=vclen)|28065
||add|8,wc|7,xl||point past end of array or vector|28066
||mov|3,srtsf|8,wb||store offset to first row|28067
||add|7,xl|8,wb||point to first item in key array|28068
|srt05|mov|7,xr|9,(xl)||get an entry|28072
|srt06|bne|9,(xr)|22,=b_trt|6,srt07|jump out if not trblk|28076
||mov|7,xr|13,trval(xr)||get value field|28077
||brn|6,srt06|||loop|28078
||ejc|||||28079
|srt07|mov|10,(xl)+|7,xr||store as array entry|28085
||blt|7,xl|8,wc|6,srt05|loop if not done|28086
||mov|7,xl|9,(xs)||get adrs of sort array|28087
||mov|7,xr|3,srtsf||initial offset to first key|28088
||mov|8,wb|3,srtst||get stride|28089
||add|7,xl|3,srtso||offset to a(0)|28090
||ica|7,xl|||point to a(1)|28091
||mov|8,wc|3,srtsn||get n|28092
||btw|8,wc|||convert from bytes|28093
||mov|3,srtnr|8,wc||store as row count|28094
||lct|8,wc|8,wc||loop counter|28095
|srt08|mov|10,(xl)+|7,xr||store an offset|28099
||add|7,xr|8,wb||bump offset by stride|28100
||bct|8,wc|6,srt08||loop through rows|28101
|srt09|mov|8,wa|3,srtsn||get n|28108
||mov|8,wc|3,srtnr||get number of rows|28109
||rsh|8,wc|1,1||i = n / 2 (wc=i, index into array)|28110
||wtb|8,wc|||convert back to bytes|28111
|srt10|jsr|6,sorth|||sorth(i,n)|28115
||dca|8,wc|||i = i - 1|28116
||bnz|8,wc|6,srt10||loop if i gt 0|28117
||mov|8,wc|8,wa||i = n|28118
|srt11|dca|8,wc|||i = i - 1 (n - 1 initially)|28124
||bze|8,wc|6,srt12||jump if done|28125
||mov|7,xr|9,(xs)||get sort array address|28126
||add|7,xr|3,srtso||point to a(0)|28127
||mov|7,xl|7,xr||a(0) address|28128
||add|7,xl|8,wc||a(i) address|28129
||mov|8,wb|13,num01(xl)||copy a(i+1)|28130
||mov|13,num01(xl)|13,num01(xr)||move a(1) to a(i+1)|28131
||mov|13,num01(xr)|8,wb||complete exchange of a(1), a(i+1)|28132
||mov|8,wa|8,wc||n = i for sorth|28133
||mov|8,wc|19,*num01||i = 1 for sorth|28134
||jsr|6,sorth|||sorth(1,n)|28135
||mov|8,wc|8,wa||restore wc|28136
||brn|6,srt11|||loop|28137
||ejc|||||28138
|srt12|mov|7,xr|9,(xs)||base adrs of key array|28145
||mov|8,wc|7,xr||copy it|28146
||add|8,wc|3,srtso||offset of a(0)|28147
||add|7,xr|3,srtsf||adrs of first row of sort array|28148
||mov|8,wb|3,srtst||get stride|28149
|srt13|ica|8,wc|||adrs of next of sorted offsets|28154
||mov|7,xl|8,wc||copy it for access|28155
||mov|7,xl|9,(xl)||get offset|28156
||add|7,xl|13,num01(xs)||add key array base adrs|28157
||mov|8,wa|8,wb||get count of characters in row|28158
||mvw||||copy a complete row|28159
||dcv|3,srtnr|||decrement row count|28160
||bnz|3,srtnr|6,srt13||repeat till all rows done|28161
|srt15|mov|7,xr|10,(xs)+||pop result array ptr|28165
||ica|7,xs|||pop key array ptr|28166
||zer|3,r_sxl|||clear junk|28167
||zer|3,r_sxr|||clear junk|28168
||exi||||return|28169
|srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||28173
|srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||28174
|srt18|exi|1,1|||return indication of null table|28178
||enp||||end procudure sorta|28179
||ejc|||||28180
|sortc|prc|25,e|1,1||entry point|28201
||mov|3,srts1|8,wa||save offset 1|28202
||mov|3,srts2|8,wb||save offset 2|28203
||mov|3,srtsc|8,wc||save wc|28204
||add|7,xl|3,srtof||add offset to comparand field|28205
||mov|7,xr|7,xl||copy base + offset|28206
||add|7,xl|8,wa||add key1 offset|28207
||add|7,xr|8,wb||add key2 offset|28208
||mov|7,xl|9,(xl)||get key1|28209
||mov|7,xr|9,(xr)||get key2|28210
||bne|3,srtdf|21,=nulls|6,src12|jump if datatype field name used|28211
||ejc|||||28212
|src01|mov|8,wc|9,(xl)||get type code|28218
||bne|8,wc|9,(xr)|6,src02|skip if not same datatype|28219
||beq|8,wc|22,=b_scl|6,src09|jump if both strings|28220
||beq|8,wc|22,=b_icl|6,src14|jump if both integers|28221
|src02|mov|3,r_sxl|7,xl||keep arg1|28229
||mov|3,r_sxr|7,xr||keep arg2|28230
||beq|8,wc|22,=b_scl|6,src11|do not allow conversion to number|28233
||beq|9,(xr)|22,=b_scl|6,src11|if either arg is a string|28234
|src14|mov|11,-(xs)|7,xl||stack|28277
||mov|11,-(xs)|7,xr||args|28278
||jsr|6,acomp|||compare objects|28279
||ppm|6,src10|||not numeric|28280
||ppm|6,src10|||not numeric|28281
||ppm|6,src03|||key1 less|28282
||ppm|6,src08|||keys equal|28283
||ppm|6,src05|||key1 greater|28284
|src03|bnz|3,srtsr|6,src06||jump if rsort|28288
|src04|mov|8,wc|3,srtsc||restore wc|28290
||exi|1,1|||return|28291
|src05|bnz|3,srtsr|6,src04||jump if rsort|28295
|src06|mov|8,wc|3,srtsc||restore wc|28297
||exi||||return|28298
|src07|blt|7,xl|7,xr|6,src03|item first created is less|28302
||bgt|7,xl|7,xr|6,src05|addresses rise in order of creation|28303
|src08|blt|3,srts1|3,srts2|6,src04|test offsets or key addrss instead|28307
||brn|6,src06|||offset 1 greater|28308
||ejc|||||28309
|src09|mov|11,-(xs)|7,xl||stack|28319
||mov|11,-(xs)|7,xr||args|28320
||jsr|6,lcomp|||compare objects|28321
||ppm||||cant|28322
||ppm||||fail|28323
||ppm|6,src03|||key1 less|28324
||ppm|6,src08|||keys equal|28325
||ppm|6,src05|||key1 greater|28326
|src10|mov|7,xl|3,r_sxl||get arg1|28330
||mov|7,xr|3,r_sxr||get arg2|28331
||mov|8,wc|9,(xl)||get type of key1|28332
||beq|8,wc|9,(xr)|6,src07|jump if keys of same type|28333
|src11|mov|7,xl|8,wc||get block type word|28337
||mov|7,xr|9,(xr)||get block type word|28338
||lei|7,xl|||entry point id for key1|28339
||lei|7,xr|||entry point id for key2|28340
||bgt|7,xl|7,xr|6,src05|jump if key1 gt key2|28341
||brn|6,src03|||key1 lt key2|28342
|src12|jsr|6,sortf|||call routine to find field 1|28346
||mov|11,-(xs)|7,xl||stack item pointer|28347
||mov|7,xl|7,xr||get key2|28348
||jsr|6,sortf|||find field 2|28349
||mov|7,xr|7,xl||place as key2|28350
||mov|7,xl|10,(xs)+||recover key1|28351
||brn|6,src01|||merge|28352
||enp||||procedure sortc|28353
||ejc|||||28354
|sortf|prc|25,e|1,0||entry point|28372
||bne|9,(xl)|22,=b_pdt|6,srtf3|return if not pdblk|28373
||mov|11,-(xs)|7,xr||keep xr|28374
||mov|7,xr|3,srtfd||get possible former dfblk ptr|28375
||bze|7,xr|6,srtf4||jump if not|28376
||bne|7,xr|13,pddfp(xl)|6,srtf4|jump if not right datatype|28377
||bne|3,srtdf|3,srtff|6,srtf4|jump if not right field name|28378
||add|7,xl|3,srtfo||add offset to required field|28379
|srtf1|mov|7,xl|9,(xl)||get item from field|28383
|srtf2|mov|7,xr|10,(xs)+||restore xr|28387
|srtf3|exi||||return|28389
||ejc|||||28390
|srtf4|mov|7,xr|7,xl||copy original pointer|28396
||mov|7,xr|13,pddfp(xr)||point to dfblk|28397
||mov|3,srtfd|7,xr||keep a copy|28398
||mov|8,wc|13,fargs(xr)||get number of fields|28399
||wtb|8,wc|||convert to bytes|28400
||add|7,xr|13,dflen(xr)||point past last field|28401
|srtf5|dca|8,wc|||count down|28405
||dca|7,xr|||point in front|28406
||beq|9,(xr)|3,srtdf|6,srtf6|skip out if found|28407
||bnz|8,wc|6,srtf5||loop|28408
||brn|6,srtf2|||return - not found|28409
|srtf6|mov|3,srtff|9,(xr)||keep field name ptr|28413
||add|8,wc|19,*pdfld||add offset to first field|28414
||mov|3,srtfo|8,wc||store as field offset|28415
||add|7,xl|8,wc||point to field|28416
||brn|6,srtf1|||return|28417
||enp||||procedure sortf|28418
||ejc|||||28419
|sorth|prc|25,n|1,0||entry point|28434
||mov|3,srtsn|8,wa||save n|28435
||mov|3,srtwc|8,wc||keep wc|28436
||mov|7,xl|9,(xs)||sort array base adrs|28437
||add|7,xl|3,srtso||add offset to a(0)|28438
||add|7,xl|8,wc||point to a(j)|28439
||mov|3,srtrt|9,(xl)||get offset to root|28440
||add|8,wc|8,wc||double j - cant exceed n|28441
|srh01|bgt|8,wc|3,srtsn|6,srh03|done if j gt n|28445
||beq|8,wc|3,srtsn|6,srh02|skip if j equals n|28446
||mov|7,xr|9,(xs)||sort array base adrs|28447
||mov|7,xl|13,num01(xs)||key array base adrs|28448
||add|7,xr|3,srtso||point to a(0)|28449
||add|7,xr|8,wc||adrs of a(j)|28450
||mov|8,wa|13,num01(xr)||get a(j+1)|28451
||mov|8,wb|9,(xr)||get a(j)|28452
||jsr|6,sortc|||compare keys - lt(a(j+1),a(j))|28456
||ppm|6,srh02|||a(j+1) lt a(j)|28457
||ica|8,wc|||point to greater son, a(j+1)|28458
||ejc|||||28459
|srh02|mov|7,xl|13,num01(xs)||key array base adrs|28465
||mov|7,xr|9,(xs)||get sort array address|28466
||add|7,xr|3,srtso||adrs of a(0)|28467
||mov|8,wb|7,xr||copy this adrs|28468
||add|7,xr|8,wc||adrs of greater son, a(j)|28469
||mov|8,wa|9,(xr)||get a(j)|28470
||mov|7,xr|8,wb||point back to a(0)|28471
||mov|8,wb|3,srtrt||get root|28472
||jsr|6,sortc|||compare them - lt(a(j),root)|28473
||ppm|6,srh03|||father exceeds sons - done|28474
||mov|7,xr|9,(xs)||get sort array adrs|28475
||add|7,xr|3,srtso||point to a(0)|28476
||mov|7,xl|7,xr||copy it|28477
||mov|8,wa|8,wc||copy j|28478
||btw|8,wc|||convert to words|28479
||rsh|8,wc|1,1||get j/2|28480
||wtb|8,wc|||convert back to bytes|28481
||add|7,xl|8,wa||point to a(j)|28482
||add|7,xr|8,wc||adrs of a(j/2)|28483
||mov|9,(xr)|9,(xl)||a(j/2) = a(j)|28484
||mov|8,wc|8,wa||recover j|28485
||aov|8,wc|8,wc|6,srh03|j = j*2. done if too big|28486
||brn|6,srh01|||loop|28487
|srh03|btw|8,wc|||convert to words|28491
||rsh|8,wc|1,1||j = j/2|28492
||wtb|8,wc|||convert back to bytes|28493
||mov|7,xr|9,(xs)||sort array adrs|28494
||add|7,xr|3,srtso||adrs of a(0)|28495
||add|7,xr|8,wc||adrs of a(j/2)|28496
||mov|9,(xr)|3,srtrt||a(j/2) = root|28497
||mov|8,wa|3,srtsn||restore wa|28498
||mov|8,wc|3,srtwc||restore wc|28499
||exi||||return|28500
||enp||||end procedure sorth|28501
||ejc|||||28503
|trace|prc|25,n|1,2||entry point|28519
||jsr|6,gtstg|||get trace type string|28520
||ppm|6,trc15|||jump if not string|28521
||plc|7,xr|||else point to string|28522
||lch|8,wa|9,(xr)||load first character|28523
||mov|7,xr|9,(xs)||load name argument|28527
||mov|9,(xs)|7,xl||stack trblk ptr or zero|28528
||mov|8,wc|18,=trtac||set trtyp for access trace|28529
||beq|8,wa|18,=ch_la|6,trc10|jump if a (access)|28530
||mov|8,wc|18,=trtvl||set trtyp for value trace|28531
||beq|8,wa|18,=ch_lv|6,trc10|jump if v (value)|28532
||beq|8,wa|18,=ch_bl|6,trc10|jump if blank (value)|28533
||beq|8,wa|18,=ch_lf|6,trc01|jump if f (function)|28537
||beq|8,wa|18,=ch_lr|6,trc01|jump if r (return)|28538
||beq|8,wa|18,=ch_ll|6,trc03|jump if l (label)|28539
||beq|8,wa|18,=ch_lk|6,trc06|jump if k (keyword)|28540
||bne|8,wa|18,=ch_lc|6,trc15|else error if not c (call)|28541
|trc01|jsr|6,gtnvr|||point to vrblk for name|28545
||ppm|6,trc16|||jump if bad name|28546
||ica|7,xs|||pop stack|28547
||mov|7,xr|13,vrfnc(xr)||point to function block|28548
||bne|9,(xr)|22,=b_pfc|6,trc17|error if not program function|28549
||beq|8,wa|18,=ch_lr|6,trc02|jump if r (return)|28550
||ejc|||||28551
||mov|13,pfctr(xr)|7,xl||set/reset call trace|28557
||beq|8,wa|18,=ch_lc|6,exnul|exit with null if c (call)|28558
|trc02|mov|13,pfrtr(xr)|7,xl||set/reset return trace|28562
||exi||||return|28563
|trc03|jsr|6,gtnvr|||point to vrblk|28567
||ppm|6,trc16|||jump if bad name|28568
||mov|7,xl|13,vrlbl(xr)||load label pointer|28569
||bne|9,(xl)|22,=b_trt|6,trc04|jump if no old trace|28570
||mov|7,xl|13,trlbl(xl)||else delete old trace association|28571
|trc04|beq|7,xl|21,=stndl|6,trc16|error if undefined label|28575
||mov|8,wb|10,(xs)+||get trblk ptr again|28576
||bze|8,wb|6,trc05||jump if stoptr case|28577
||mov|13,vrlbl(xr)|8,wb||else set new trblk pointer|28578
||mov|13,vrtra(xr)|22,=b_vrt||set label trace routine address|28579
||mov|7,xr|8,wb||copy trblk pointer|28580
||mov|13,trlbl(xr)|7,xl||store real label in trblk|28581
||exi||||return|28582
|trc05|mov|13,vrlbl(xr)|7,xl||store label ptr back in vrblk|28586
||mov|13,vrtra(xr)|22,=b_vrg||store normal transfer address|28587
||exi||||return|28588
||ejc|||||28589
|trc06|jsr|6,gtnvr|||point to vrblk|28595
||ppm|6,trc16|||error if not natural var|28596
||bnz|13,vrlen(xr)|6,trc16||error if not system var|28597
||ica|7,xs|||pop stack|28598
||bze|7,xl|6,trc07||jump if stoptr case|28599
||mov|13,trkvr(xl)|7,xr||store vrblk ptr in trblk for ktrex|28600
|trc07|mov|7,xr|13,vrsvp(xr)||point to svblk|28604
||beq|7,xr|21,=v_ert|6,trc08|jump if errtype|28605
||beq|7,xr|21,=v_stc|6,trc09|jump if stcount|28606
||bne|7,xr|21,=v_fnc|6,trc17|else error if not fnclevel|28607
||mov|3,r_fnc|7,xl||set/reset fnclevel trace|28611
||exi||||return|28612
|trc08|mov|3,r_ert|7,xl||set/reset errtype trace|28616
||exi||||return|28617
|trc09|mov|3,r_stc|7,xl||set/reset stcount trace|28621
||jsr|6,stgcc|||update countdown counters|28622
||exi||||return|28623
||ejc|||||28624
|trc10|jsr|6,gtvar|||locate variable|28630
||ppm|6,trc16|||error if not appropriate name|28631
||mov|8,wb|10,(xs)+||get new trblk ptr again|28632
||add|8,wa|7,xl||point to variable location|28633
||mov|7,xr|8,wa||copy variable pointer|28634
|trc11|mov|7,xl|9,(xr)||point to next entry|28638
||bne|9,(xl)|22,=b_trt|6,trc13|jump if not trblk|28639
||blt|8,wc|13,trtyp(xl)|6,trc13|jump if too far out on chain|28640
||beq|8,wc|13,trtyp(xl)|6,trc12|jump if this matches our type|28641
||add|7,xl|19,*trnxt||else point to link field|28642
||mov|7,xr|7,xl||copy pointer|28643
||brn|6,trc11|||and loop back|28644
|trc12|mov|7,xl|13,trnxt(xl)||get ptr to next block or value|28648
||mov|9,(xr)|7,xl||store to delete this trblk|28649
|trc13|bze|8,wb|6,trc14||jump if stoptr case|28653
||mov|9,(xr)|8,wb||else link new trblk in|28654
||mov|7,xr|8,wb||copy trblk pointer|28655
||mov|13,trnxt(xr)|7,xl||store forward pointer|28656
||mov|13,trtyp(xr)|8,wc||store appropriate trap type code|28657
|trc14|mov|7,xr|8,wa||recall possible vrblk pointer|28661
||sub|7,xr|19,*vrval||point back to vrblk|28662
||jsr|6,setvr|||set fields if vrblk|28663
||exi||||return|28664
|trc15|exi|1,2|||take bad trace type error exit|28668
|trc16|ica|7,xs|||pop stack|28672
|trc17|exi|1,1|||take bad name error exit|28676
||enp||||end procedure trace|28677
||ejc|||||28678
|trbld|prc|25,e|1,0||entry point|28692
||mov|11,-(xs)|7,xr||stack trtag (or trfnm)|28693
||mov|8,wa|19,*trsi_||set size of trblk|28694
||jsr|6,alloc|||allocate trblk|28695
||mov|9,(xr)|22,=b_trt||store first word|28696
||mov|13,trfnc(xr)|7,xl||store trfnc (or trfpt)|28697
||mov|13,trtag(xr)|10,(xs)+||store trtag (or trfnm)|28698
||mov|13,trtyp(xr)|8,wb||store type|28699
||mov|13,trval(xr)|21,=nulls||for now, a null value|28700
||exi||||return to caller|28701
||enp||||end procedure trbld|28702
||ejc|||||28703
|trimr|prc|25,e|1,0||entry point|28721
||mov|7,xl|7,xr||copy string pointer|28722
||mov|8,wa|13,sclen(xr)||load string length|28723
||bze|8,wa|6,trim2||jump if null input|28724
||plc|7,xl|8,wa||else point past last character|28725
||bze|8,wb|6,trim3||jump if no trim|28726
||mov|8,wc|18,=ch_bl||load blank character|28727
|trim0|lch|8,wb|11,-(xl)||load next character|28731
||beq|8,wb|18,=ch_ht|6,trim1|jump if horizontal tab|28733
||bne|8,wb|8,wc|6,trim3|jump if non-blank found|28735
|trim1|dcv|8,wa|||else decrement character count|28736
||bnz|8,wa|6,trim0||loop back if more to check|28737
|trim2|mov|3,dnamp|7,xr||wipe out input string block|28741
||mov|7,xr|21,=nulls||load null result|28742
||brn|6,trim5|||merge to exit|28743
||ejc|||||28744
|trim3|mov|13,sclen(xr)|8,wa||set new length|28750
||mov|7,xl|7,xr||copy string pointer|28751
||psc|7,xl|8,wa||ready for storing blanks|28752
||ctb|8,wa|2,schar||get length of block in bytes|28753
||add|8,wa|7,xr||point past new block|28754
||mov|3,dnamp|8,wa||set new top of storage pointer|28755
||lct|8,wa|18,=cfp_c||get count of chars in word|28756
||zer|8,wc|||set zero char|28757
|trim4|sch|8,wc|10,(xl)+||store zero character|28761
||bct|8,wa|6,trim4||loop back till all stored|28762
||csc|7,xl|||complete store characters|28763
|trim5|zer|7,xl|||clear garbage xl pointer|28767
||exi||||return to caller|28768
||enp||||end procedure trimr|28769
||ejc|||||28770
|trxeq|prc|25,r|1,0||entry point (recursive)|28801
||mov|8,wc|3,r_cod||load code block pointer|28802
||scp|8,wb|||get current code pointer|28803
||sub|8,wb|8,wc||make code pointer into offset|28804
||mov|11,-(xs)|3,kvtra||stack trace keyword value|28805
||mov|11,-(xs)|7,xr||stack trblk pointer|28806
||mov|11,-(xs)|7,xl||stack name base|28807
||mov|11,-(xs)|8,wa||stack name offset|28808
||mov|11,-(xs)|8,wc||stack code block pointer|28809
||mov|11,-(xs)|8,wb||stack code pointer offset|28810
||mov|11,-(xs)|3,flptr||stack old failure pointer|28811
||zer|11,-(xs)|||set dummy fail offset|28812
||mov|3,flptr|7,xs||set new failure pointer|28813
||zer|3,kvtra|||reset trace keyword to zero|28814
||mov|8,wc|21,=trxdc||load new (dummy) code blk pointer|28815
||mov|3,r_cod|8,wc||set as code block pointer|28816
||lcp|8,wc|||and new code pointer|28817
||ejc|||||28818
||mov|8,wb|8,wa||save name offset|28824
||mov|8,wa|19,*nmsi_||load nmblk size|28825
||jsr|6,alloc|||allocate space for nmblk|28826
||mov|9,(xr)|22,=b_nml||set type word|28827
||mov|13,nmbas(xr)|7,xl||store name base|28828
||mov|13,nmofs(xr)|8,wb||store name offset|28829
||mov|7,xl|12,6(xs)||reload pointer to trblk|28830
||mov|11,-(xs)|7,xr||stack nmblk pointer (1st argument)|28831
||mov|11,-(xs)|13,trtag(xl)||stack trace tag (2nd argument)|28832
||mov|7,xl|13,trfnc(xl)||load trace vrblk pointer|28833
||mov|7,xl|13,vrfnc(xl)||load trace function pointer|28834
||beq|7,xl|21,=stndf|6,trxq2|jump if not a defined function|28835
||mov|8,wa|18,=num02||set number of arguments to two|28836
||brn|6,cfunc|||jump to call function|28837
|trxq1|mov|7,xs|3,flptr||point back to our stack entries|28841
||ica|7,xs|||pop off garbage fail offset|28842
||mov|3,flptr|10,(xs)+||restore old failure pointer|28843
||mov|8,wb|10,(xs)+||reload code offset|28844
||mov|8,wc|10,(xs)+||load old code base pointer|28845
||mov|7,xr|8,wc||copy cdblk pointer|28846
||mov|3,kvstn|13,cdstm(xr)||restore stmnt no|28847
||mov|8,wa|10,(xs)+||reload name offset|28848
||mov|7,xl|10,(xs)+||reload name base|28849
||mov|7,xr|10,(xs)+||reload trblk pointer|28850
||mov|3,kvtra|10,(xs)+||restore trace keyword value|28851
||add|8,wb|8,wc||recompute absolute code pointer|28852
||lcp|8,wb|||restore code pointer|28853
||mov|3,r_cod|8,wc||and code block pointer|28854
||exi||||return to trxeq caller|28855
|trxq2|erb|1,197|26,trace fourth arg is not function name or null|||28859
||enp||||end procedure trxeq|28861
||ejc|||||28862
||ejc|||||28902
|xscan|prc|25,e|1,0||entry point|28906
||mov|3,xscwb|8,wb||preserve wb|28907
||mov|11,-(xs)|8,wa||record blank skip flag|28908
||mov|11,-(xs)|8,wa||and second copy|28909
||mov|7,xr|3,r_xsc||point to argument string|28910
||mov|8,wa|13,sclen(xr)||load string length|28911
||mov|8,wb|3,xsofs||load current offset|28912
||sub|8,wa|8,wb||get number of remaining characters|28913
||bze|8,wa|6,xscn3||jump if no characters left|28914
||plc|7,xr|8,wb||point to current character|28915
|xscn1|lch|8,wb|10,(xr)+||load next character|28919
||beq|8,wb|8,wc|6,xscn4|jump if delimiter one found|28920
||beq|8,wb|7,xl|6,xscn5|jump if delimiter two found|28921
||bze|9,(xs)|6,xscn2||jump if not skipping blanks|28922
||icv|3,xsofs|||assume blank and delete it|28923
||beq|8,wb|18,=ch_ht|6,xscn2|jump if horizontal tab|28925
||beq|8,wb|18,=ch_bl|6,xscn2|jump if blank|28930
||dcv|3,xsofs|||undelete non-blank character|28931
||zer|9,(xs)|||and discontinue blank checking|28932
|xscn2|dcv|8,wa|||decrement count of chars left|28936
||bnz|8,wa|6,xscn1||loop back if more chars to go|28937
|xscn3|mov|7,xl|3,r_xsc||point to string block|28941
||mov|8,wa|13,sclen(xl)||get string length|28942
||mov|8,wb|3,xsofs||load offset|28943
||sub|8,wa|8,wb||get substring length|28944
||zer|3,r_xsc|||clear string ptr for collector|28945
||zer|3,xscrt|||set zero (runout) return code|28946
||brn|6,xscn7|||jump to exit|28947
||ejc|||||28948
|xscn4|mov|3,xscrt|18,=num01||set return code|28954
||brn|6,xscn6|||jump to merge|28955
|xscn5|mov|3,xscrt|18,=num02||set return code|28959
|xscn6|mov|7,xl|3,r_xsc||reload pointer to string|28963
||mov|8,wc|13,sclen(xl)||get original length of string|28964
||sub|8,wc|8,wa||minus chars left = chars scanned|28965
||mov|8,wa|8,wc||move to reg for sbstr|28966
||mov|8,wb|3,xsofs||set offset|28967
||sub|8,wa|8,wb||compute length for sbstr|28968
||icv|8,wc|||adjust new cursor past delimiter|28969
||mov|3,xsofs|8,wc||store new offset|28970
|xscn7|zer|7,xr|||clear garbage character ptr in xr|28974
||jsr|6,sbstr|||build sub-string|28975
||ica|7,xs|||remove copy of blank flag|28976
||mov|8,wb|10,(xs)+||original blank skip/trim flag|28977
||bze|13,sclen(xr)|6,xscn8||cannot trim the null string|28978
||jsr|6,trimr|||trim trailing blanks if requested|28979
|xscn8|mov|8,wa|3,xscrt||load return code|28983
||mov|8,wb|3,xscwb||restore wb|28984
||exi||||return to xscan caller|28985
||enp||||end procedure xscan|28986
||ejc|||||28987
|xscni|prc|25,n|1,2||entry point|29004
||jsr|6,gtstg|||fetch argument as string|29005
||ppm|6,xsci1|||jump if not convertible|29006
||mov|3,r_xsc|7,xr||else store scblk ptr for xscan|29007
||zer|3,xsofs|||set offset to zero|29008
||bze|8,wa|6,xsci2||jump if null string|29009
||exi||||return to xscni caller|29010
|xsci1|exi|1,1|||take not-string error exit|29014
|xsci2|exi|1,2|||take null-string error exit|29018
||enp||||end procedure xscni|29019
||ttl|27,s p i t b o l -- stack overflow section||||29020
||sec||||start of stack overflow section|29024
||add|3,errft|18,=num04||force conclusive fatal error|29026
||mov|7,xs|3,flptr||pop stack to avoid more fails|29027
||bnz|3,gbcfl|6,stak1||jump if garbage collecting|29028
||erb|1,246|26,stack overflow|||29029
|stak1|mov|7,xr|21,=endso||point to message|29033
||zer|3,kvdmp|||memory is undumpable|29034
||brn|6,stopr|||give up|29035
||ttl|27,s p i t b o l -- error section||||29036
||sec||||start of error section|29066
|error|beq|3,r_cim|20,=cmlab|6,cmple|jump if error in scanning label|29068
||mov|3,kvert|8,wa||save error code|29069
||zer|3,scnrs|||reset rescan switch for scane|29070
||zer|3,scngo|||reset goto switch for scane|29071
||mov|3,polcs|18,=num01||reset poll count|29073
||mov|3,polct|18,=num01||reset poll count|29074
||mov|7,xr|3,stage||load current stage|29076
||bsw|7,xr|2,stgno||jump to appropriate error circuit|29077
||iff|2,stgic|6,err01||initial compile|29085
||iff|2,stgxc|6,err04||execute time compile|29085
||iff|2,stgev|6,err04||eval compiling expr.|29085
||iff|2,stgxt|6,err05||execute time|29085
||iff|2,stgce|6,err01||compile - after end|29085
||iff|2,stgxe|6,err04||xeq compile-past end|29085
||iff|2,stgee|6,err04||eval evaluating expr|29085
||esw||||end switch on error type|29085
||ejc|||||29086
|err01|mov|7,xs|3,cmpxs||reset stack pointer|29102
||ssl|3,cmpss|||restore s-r stack ptr for cmpil|29103
||bnz|3,errsp|6,err03||jump if error suppress flag set|29104
||mov|8,wc|3,cmpsn||current statement|29107
||jsr|6,filnm|||obtain file name for this statement|29108
||mov|8,wb|3,scnse||column number|29110
||mov|8,wc|3,rdcln||line number|29111
||mov|7,xr|3,stage|||29112
||jsr|6,sysea|||advise system of error|29113
||ppm|6,erra3|||if system does not want print|29114
||mov|11,-(xs)|7,xr||save any provided print message|29115
||mov|3,erlst|3,erich||set flag for listr|29117
||jsr|6,listr|||list line|29118
||jsr|6,prtis|||terminate listing|29119
||zer|3,erlst|||clear listr flag|29120
||mov|8,wa|3,scnse||load scan element offset|29121
||bze|8,wa|6,err02||skip if not set|29122
||lct|8,wb|8,wa||loop counter|29124
||icv|8,wa|||increase for ch_ex|29125
||mov|7,xl|3,r_cim||point to bad statement|29126
||jsr|6,alocs|||string block for error flag|29127
||mov|8,wa|7,xr||remember string ptr|29128
||psc|7,xr|||ready for character storing|29129
||plc|7,xl|||ready to get chars|29130
|erra1|lch|8,wc|10,(xl)+||get next char|29134
||beq|8,wc|18,=ch_ht|6,erra2|skip if tab|29135
||mov|8,wc|18,=ch_bl||get a blank|29136
||ejc|||||29137
|erra2|sch|8,wc|10,(xr)+||store char|29141
||bct|8,wb|6,erra1||loop|29142
||mov|7,xl|18,=ch_ex||exclamation mark|29143
||sch|7,xl|9,(xr)||store at end of error line|29144
||csc|7,xr|||end of sch loop|29145
||mov|3,profs|18,=stnpd||allow for statement number|29146
||mov|7,xr|8,wa||point to error line|29147
||jsr|6,prtst|||print error line|29148
|err02|jsr|6,prtis|||print blank line|29162
||mov|7,xr|10,(xs)+||restore any sysea message|29164
||bze|7,xr|6,erra0||did sysea provide message to print|29165
||jsr|6,prtst|||print sysea message|29166
|erra0|jsr|6,ermsg|||generate flag and error message|29168
||add|3,lstlc|18,=num03||bump page ctr for blank, error, blk|29169
|erra3|zer|7,xr|||in case of fatal error|29170
||bhi|3,errft|18,=num03|6,stopr|pack up if several fatals|29171
||icv|3,cmerc|||bump error count|29175
||add|3,noxeq|3,cswer||inhibit xeq if -noerrors|29176
||bne|3,stage|18,=stgic|6,cmp10|special return if after end line|29177
||ejc|||||29178
|err03|mov|7,xr|3,r_cim||point to start of image|29182
||plc|7,xr|||point to first char|29183
||lch|7,xr|9,(xr)||get first char|29184
||beq|7,xr|18,=ch_mn|6,cmpce|jump if error in control card|29185
||zer|3,scnrs|||clear rescan flag|29186
||mnz|3,errsp|||set error suppress flag|29187
||jsr|6,scane|||scan next element|29188
||bne|7,xl|18,=t_smc|6,err03|loop back if not statement end|29189
||zer|3,errsp|||clear error suppress flag|29190
||mov|3,cwcof|19,*cdcod||reset offset in ccblk|29194
||mov|8,wa|21,=ocer_||load compile error call|29195
||jsr|6,cdwrd|||generate it|29196
||mov|13,cmsoc(xs)|3,cwcof||set success fill in offset|29197
||mnz|13,cmffc(xs)|||set failure fill in flag|29198
||jsr|6,cdwrd|||generate succ. fill in word|29199
||brn|6,cmpse|||merge to generate error as cdfal|29200
|err04|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29210
||beq|3,kvert|18,=nm320|6,err06|treat user interrupt specially|29212
||zer|3,r_ccb|||forget garbage code block|29214
||mov|3,cwcof|19,*cccod||set initial offset (mbe catspaw)|29215
||ssl|3,iniss|||restore main prog s-r stack ptr|29216
||jsr|6,ertex|||get fail message text|29217
||dca|7,xs|||ensure stack ok on loop start|29218
|erra4|ica|7,xs|||pop stack|29223
||beq|7,xs|3,flprt|6,errc4|jump if prog defined fn call found|29224
||bne|7,xs|3,gtcef|6,erra4|loop if not eval or code call yet|29225
||mov|3,stage|18,=stgxt||re-set stage for execute|29226
||mov|3,r_cod|3,r_gtc||recover code ptr|29227
||mov|3,flptr|7,xs||restore fail pointer|29228
||zer|3,r_cim|||forget possible image|29229
||zer|3,cnind|||forget possible include|29231
|errb4|bnz|3,kverl|6,err07||jump if errlimit non-zero|29236
||brn|6,exfal|||fail|29237
|errc4|mov|7,xs|3,flptr||restore stack from flptr|29241
||brn|6,errb4|||merge|29242
||ejc|||||29243
|err05|ssl|3,iniss|||restore main prog s-r stack ptr|29261
||bnz|3,dmvch|6,err08||jump if in mid-dump|29262
|err06|bze|3,kverl|6,labo1||abort if errlimit is zero|29266
||jsr|6,ertex|||get fail message text|29267
|err07|bge|3,errft|18,=num03|6,labo1|abort if too many fatal errors|29271
||dcv|3,kverl|||decrement errlimit|29272
||mov|7,xl|3,r_ert||load errtype trace pointer|29273
||jsr|6,ktrex|||generate errtype trace if required|29274
||mov|8,wa|3,r_cod||get current code block|29275
||mov|3,r_cnt|8,wa||set cdblk ptr for continuation|29276
||scp|8,wb|||current code pointer|29277
||sub|8,wb|8,wa||offset within code block|29278
||mov|3,stxoc|8,wb||save code ptr offset for scontinue|29279
||mov|7,xr|3,flptr||set ptr to failure offset|29280
||mov|3,stxof|9,(xr)||save failure offset for continue|29281
||mov|7,xr|3,r_sxc||load setexit cdblk pointer|29282
||bze|7,xr|6,lcnt1||continue if no setexit trap|29283
||zer|3,r_sxc|||else reset trap|29284
||mov|3,stxvr|21,=nulls||reset setexit arg to null|29285
||mov|7,xl|9,(xr)||load ptr to code block routine|29286
||bri|7,xl|||execute first trap statement|29287
|err08|mov|7,xr|3,dmvch||chain head for affected vrblks|29292
||bze|7,xr|6,err06||done if zero|29293
||mov|3,dmvch|9,(xr)||set next link as chain head|29294
||jsr|6,setvr|||restore vrget field|29295
|s_yyy|brn|6,err08|||loop through chain|29299
||ttl|27,s p i t b o l -- here endeth the code||||29300
||end||||end macro-spitbol assembly|29304
